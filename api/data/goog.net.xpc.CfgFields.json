{"2":{"1":[{"1":"goog.net.xpc.CfgFields","5":{"1":"closure/goog/net/xpc/xpc.js","2":93,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L93"},"7":{"1":[{"2":"<p>Field names used on configuration object.</p>\n"}]},"8":{},"13":[{"1":{"1":"AUTH_TOKEN","2":{"1":"closure/goog/net/xpc/xpc.js","2":105,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L105"},"3":{"1":[{"2":"<p>Authorization token. If set, NIX will use this authorization token\nto validate the setup.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"CHANNEL_NAME","2":{"1":"closure/goog/net/xpc/xpc.js","2":100,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L100"},"3":{"1":[{"2":"<p>Channel name identifier.\nBoth peers have to be initialized with\nthe same channel name.  If not present, a channel name is\ngenerated (which then has to transferred to the peer somehow).</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"DIRECT_TRANSPORT_SYNC_MODE","2":{"1":"closure/goog/net/xpc/xpc.js","2":201,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L201"},"3":{"1":[{"2":"<p>Whether the direct transport runs in synchronous mode. The default is to\nemulate the other transports and run asyncronously but there are some\ncircumstances where syncronous calls are required. If this property is\nset to true, the transport will send the messages synchronously.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"IFRAME_ID","2":{"1":"closure/goog/net/xpc/xpc.js","2":119,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L119"},"3":{"1":[{"2":"<p>Ifame-ID identifier.\nThe id of the iframe element the peer-document lives in.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"LOCAL_POLL_URI","2":{"1":"closure/goog/net/xpc/xpc.js","2":144,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L144"},"3":{"1":[{"2":"<p>Local poll URI identifier (IframePollingTransport-specific).\nThe URI  (can&#39;t contain a fragment identifier)which is polled\nto receive data from the peer.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"LOCAL_RELAY_URI","2":{"1":"closure/goog/net/xpc/xpc.js","2":132,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L132"},"3":{"1":[{"2":"<p>Local relay URI identifier (IframeRelayTransport-specific).\nThe URI (can&#39;t contain a fragment identifier) used by the peer to\nrelay data through.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"NATIVE_TRANSPORT_PROTOCOL_VERSION","2":{"1":"closure/goog/net/xpc/xpc.js","2":194,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L194"},"3":{"1":[{"2":"<p>Which version of the native transport startup protocol should be used, the\ndefault being &#39;2&#39;.  Version 1 had various timing vulnerabilities, which\nhad to be compensated for by introducing delays, and is deprecated.  V1\nand V2 are broadly compatible, although the more robust timing and lack\nof delays is not gained unless both sides are using V2.  The only\nunsupported case of cross-protocol interoperation is where a connection\nstarts out with V2 at both ends, and one of the ends reconnects as a V1.\nAll other initial startup and reconnection scenarios are supported.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"ONE_SIDED_HANDSHAKE","2":{"1":"closure/goog/net/xpc/xpc.js","2":176,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L176"},"3":{"1":[{"2":"<p>Usually both frames using a connection initially send a SETUP message to\neach other, and each responds with a SETUP_ACK.  A frame marks itself\nconnected when it receives that SETUP_ACK.  If this parameter is true\nhowever, the channel it is passed to will not send a SETUP, but rather will\nwait for one from its peer and mark itself connected when that arrives.\nPeer iframes created using such a channel will send SETUP however, and will\nwait for SETUP_ACK before marking themselves connected.  The goal is to\ncope with a situation where the availability of the URL for the peer frame\ncannot be relied on, eg when the application is offline.  Without this\nsetting, the primary frame will attempt to send its SETUP message every\n100ms, forever.  This floods the javascript console with uncatchable\nsecurity warnings, and fruitlessly burns CPU.  There is one scenario this\nmode will not support, and that is reconnection by the outer frame, ie the\ncreation of a new channel object to connect to a peer iframe which was\nalready communicating with a previous channel object of the same name.  If\nthat behavior is needed, this mode should not be used.  Reconnection by\ninner frames is supported in this mode however.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"PEER_HOSTNAME","2":{"1":"closure/goog/net/xpc/xpc.js","2":156,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L156"},"3":{"1":[{"2":"<p>The hostname of the peer window, including protocol, domain, and port\n(if specified). Used for security sensitive applications that make\nuse of NativeMessagingTransport (i.e. most applications).</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"PEER_POLL_URI","2":{"1":"closure/goog/net/xpc/xpc.js","2":150,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L150"},"3":{"1":[{"2":"<p>Local poll URI identifier (IframePollingTransport-specific).\nThe URI (can&#39;t contain a fragment identifier) used to send data\nto the peer.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"PEER_RELAY_URI","2":{"1":"closure/goog/net/xpc/xpc.js","2":138,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L138"},"3":{"1":[{"2":"<p>Peer relay URI identifier (IframeRelayTransport-specific).\nThe URI (can&#39;t contain a fragment identifier) used to relay data\nto the peer.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"PEER_URI","2":{"1":"closure/goog/net/xpc/xpc.js","2":114,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L114"},"3":{"1":[{"2":"<p>The URI of the peer page.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"REMOTE_AUTH_TOKEN","2":{"1":"closure/goog/net/xpc/xpc.js","2":110,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L110"},"3":{"1":[{"2":"<p>Remote party&#39;s authorization token. If set, NIX will validate this\nauthorization token against that sent by the other party.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"ROLE","2":{"1":"closure/goog/net/xpc/xpc.js","2":183,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L183"},"3":{"1":[{"2":"<p>The frame role (inner or outer). Used to explicitly indicate the role for\neach peer whenever the role cannot be reliably determined (e.g. the two\npeer windows are not parent/child frames). If unspecified, the role will\nbe dynamically determined, assuming a parent/child frame setup.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}},{"1":{"1":"TRANSPORT","2":{"1":"closure/goog/net/xpc/xpc.js","2":126,"3":"https://github.com/google/closure-library/blob/master/closure/goog/net/xpc/xpc.js#L126"},"3":{"1":[{"2":"<p>Transport type identifier.\nThe transport type to use. Possible values are entries from\ngoog.net.xpc.TransportTypes. If not present, the transport is\ndetermined automatically based on the useragent&#39;s capabilities.</p>\n"}]}},"2":{"4":{"1":"string","4":true}}}],"21":{"1":{"1":"goog.net.xpc.CfgFields","3":{"1":"goog.net.xpc.CfgFields.html"}},"2":4},"23":"goog.net.xpc.CfgFields.html","24":"goog.net.xpc.CfgFields"}]}}