<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>events.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="local_closure_goog_events_events.js.html">events.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2005 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview An event manager for both native browser event
<a name="line17"></a> * targets and custom JavaScript event targets
<a name="line18"></a> * ({@code goog.events.Listenable}). This provides an abstraction
<a name="line19"></a> * over browsers&#39; event systems.
<a name="line20"></a> *
<a name="line21"></a> * It also provides a simulation of W3C event model&#39;s capture phase in
<a name="line22"></a> * Internet Explorer (IE 8 and below). Caveat: the simulation does not
<a name="line23"></a> * interact well with listeners registered directly on the elements
<a name="line24"></a> * (bypassing goog.events) or even with listeners registered via
<a name="line25"></a> * goog.events in a separate JS binary. In these cases, we provide
<a name="line26"></a> * no ordering guarantees.
<a name="line27"></a> *
<a name="line28"></a> * The listeners will receive a &quot;patched&quot; event object. Such event object
<a name="line29"></a> * contains normalized values for certain event properties that differs in
<a name="line30"></a> * different browsers.
<a name="line31"></a> *
<a name="line32"></a> * Example usage:
<a name="line33"></a> * &lt;pre&gt;
<a name="line34"></a> * goog.events.listen(myNode, &#39;click&#39;, function(e) { alert(&#39;woo&#39;) });
<a name="line35"></a> * goog.events.listen(myNode, &#39;mouseover&#39;, mouseHandler, true);
<a name="line36"></a> * goog.events.unlisten(myNode, &#39;mouseover&#39;, mouseHandler, true);
<a name="line37"></a> * goog.events.removeAll(myNode);
<a name="line38"></a> * &lt;/pre&gt;
<a name="line39"></a> *
<a name="line40"></a> *                                            in IE and event object patching]
<a name="line41"></a> * @author arv@google.com (Erik Arvidsson)
<a name="line42"></a> *
<a name="line43"></a> * @see ../demos/events.html
<a name="line44"></a> * @see ../demos/event-propagation.html
<a name="line45"></a> * @see ../demos/stopevent.html
<a name="line46"></a> */
<a name="line47"></a>
<a name="line48"></a>// IMPLEMENTATION NOTES:
<a name="line49"></a>// goog.events stores an auxiliary data structure on each EventTarget
<a name="line50"></a>// source being listened on. This allows us to take advantage of GC,
<a name="line51"></a>// having the data structure GC&#39;d when the EventTarget is GC&#39;d. This
<a name="line52"></a>// GC behavior is equivalent to using W3C DOM Events directly.
<a name="line53"></a>
<a name="line54"></a>goog.provide(&#39;goog.events&#39;);
<a name="line55"></a>goog.provide(&#39;goog.events.CaptureSimulationMode&#39;);
<a name="line56"></a>goog.provide(&#39;goog.events.Key&#39;);
<a name="line57"></a>goog.provide(&#39;goog.events.ListenableType&#39;);
<a name="line58"></a>
<a name="line59"></a>goog.require(&#39;goog.asserts&#39;);
<a name="line60"></a>goog.require(&#39;goog.debug.entryPointRegistry&#39;);
<a name="line61"></a>goog.require(&#39;goog.events.BrowserEvent&#39;);
<a name="line62"></a>goog.require(&#39;goog.events.BrowserFeature&#39;);
<a name="line63"></a>goog.require(&#39;goog.events.Listenable&#39;);
<a name="line64"></a>goog.require(&#39;goog.events.ListenerMap&#39;);
<a name="line65"></a>
<a name="line66"></a>
<a name="line67"></a>/**
<a name="line68"></a> * @typedef {number|goog.events.ListenableKey}
<a name="line69"></a> */
<a name="line70"></a>goog.events.Key;
<a name="line71"></a>
<a name="line72"></a>
<a name="line73"></a>/**
<a name="line74"></a> * @typedef {EventTarget|goog.events.Listenable}
<a name="line75"></a> */
<a name="line76"></a>goog.events.ListenableType;
<a name="line77"></a>
<a name="line78"></a>
<a name="line79"></a>/**
<a name="line80"></a> * Container for storing event listeners and their proxies
<a name="line81"></a> *
<a name="line82"></a> * TODO(user): Remove this when all external usage is
<a name="line83"></a> * purged. goog.events no longer use goog.events.listeners_ for
<a name="line84"></a> * anything meaningful.
<a name="line85"></a> *
<a name="line86"></a> * @private {!Object.&lt;goog.events.ListenableKey&gt;}
<a name="line87"></a> */
<a name="line88"></a>goog.events.listeners_ = {};
<a name="line89"></a>
<a name="line90"></a>
<a name="line91"></a>/**
<a name="line92"></a> * Property name on a native event target for the listener map
<a name="line93"></a> * associated with the event target.
<a name="line94"></a> * @const
<a name="line95"></a> * @private
<a name="line96"></a> */
<a name="line97"></a>goog.events.LISTENER_MAP_PROP_ = &#39;closure_lm_&#39; + ((Math.random() * 1e6) | 0);
<a name="line98"></a>
<a name="line99"></a>
<a name="line100"></a>/**
<a name="line101"></a> * String used to prepend to IE event types.
<a name="line102"></a> * @const
<a name="line103"></a> * @private
<a name="line104"></a> */
<a name="line105"></a>goog.events.onString_ = &#39;on&#39;;
<a name="line106"></a>
<a name="line107"></a>
<a name="line108"></a>/**
<a name="line109"></a> * Map of computed &quot;on&lt;eventname&gt;&quot; strings for IE event types. Caching
<a name="line110"></a> * this removes an extra object allocation in goog.events.listen which
<a name="line111"></a> * improves IE6 performance.
<a name="line112"></a> * @const
<a name="line113"></a> * @dict
<a name="line114"></a> * @private
<a name="line115"></a> */
<a name="line116"></a>goog.events.onStringMap_ = {};
<a name="line117"></a>
<a name="line118"></a>
<a name="line119"></a>/**
<a name="line120"></a> * @enum {number} Different capture simulation mode for IE8-.
<a name="line121"></a> */
<a name="line122"></a>goog.events.CaptureSimulationMode = {
<a name="line123"></a>  /**
<a name="line124"></a>   * Does not perform capture simulation. Will asserts in IE8- when you
<a name="line125"></a>   * add capture listeners.
<a name="line126"></a>   */
<a name="line127"></a>  OFF_AND_FAIL: 0,
<a name="line128"></a>
<a name="line129"></a>  /**
<a name="line130"></a>   * Does not perform capture simulation, silently ignore capture
<a name="line131"></a>   * listeners.
<a name="line132"></a>   */
<a name="line133"></a>  OFF_AND_SILENT: 1,
<a name="line134"></a>
<a name="line135"></a>  /**
<a name="line136"></a>   * Performs capture simulation.
<a name="line137"></a>   */
<a name="line138"></a>  ON: 2
<a name="line139"></a>};
<a name="line140"></a>
<a name="line141"></a>
<a name="line142"></a>/**
<a name="line143"></a> * @define {number} The capture simulation mode for IE8-. By default,
<a name="line144"></a> *     this is ON.
<a name="line145"></a> */
<a name="line146"></a>goog.define(&#39;goog.events.CAPTURE_SIMULATION_MODE&#39;, 2);
<a name="line147"></a>
<a name="line148"></a>
<a name="line149"></a>/**
<a name="line150"></a> * Estimated count of total native listeners.
<a name="line151"></a> * @private {number}
<a name="line152"></a> */
<a name="line153"></a>goog.events.listenerCountEstimate_ = 0;
<a name="line154"></a>
<a name="line155"></a>
<a name="line156"></a>/**
<a name="line157"></a> * Adds an event listener for a specific event on a native event
<a name="line158"></a> * target (such as a DOM element) or an object that has implemented
<a name="line159"></a> * {@link goog.events.Listenable}. A listener can only be added once
<a name="line160"></a> * to an object and if it is added again the key for the listener is
<a name="line161"></a> * returned. Note that if the existing listener is a one-off listener
<a name="line162"></a> * (registered via listenOnce), it will no longer be a one-off
<a name="line163"></a> * listener after a call to listen().
<a name="line164"></a> *
<a name="line165"></a> * @param {EventTarget|goog.events.Listenable} src The node to listen
<a name="line166"></a> *     to events on.
<a name="line167"></a> * @param {string|Array.&lt;string&gt;|
<a name="line168"></a> *     !goog.events.EventId.&lt;EVENTOBJ&gt;|!Array.&lt;!goog.events.EventId.&lt;EVENTOBJ&gt;&gt;}
<a name="line169"></a> *     type Event type or array of event types.
<a name="line170"></a> * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
<a name="line171"></a> *     listener Callback method, or an object with a handleEvent function.
<a name="line172"></a> *     WARNING: passing an Object is now softly deprecated.
<a name="line173"></a> * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
<a name="line174"></a> *     false).
<a name="line175"></a> * @param {T=} opt_handler Element in whose scope to call the listener.
<a name="line176"></a> * @return {goog.events.Key} Unique key for the listener.
<a name="line177"></a> * @template T,EVENTOBJ
<a name="line178"></a> */
<a name="line179"></a>goog.events.listen = function(src, type, listener, opt_capt, opt_handler) {
<a name="line180"></a>  if (goog.isArray(type)) {
<a name="line181"></a>    for (var i = 0; i &lt; type.length; i++) {
<a name="line182"></a>      goog.events.listen(src, type[i], listener, opt_capt, opt_handler);
<a name="line183"></a>    }
<a name="line184"></a>    return null;
<a name="line185"></a>  }
<a name="line186"></a>
<a name="line187"></a>  listener = goog.events.wrapListener(listener);
<a name="line188"></a>  if (goog.events.Listenable.isImplementedBy(src)) {
<a name="line189"></a>    return src.listen(
<a name="line190"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line191"></a>        listener, opt_capt, opt_handler);
<a name="line192"></a>  } else {
<a name="line193"></a>    return goog.events.listen_(
<a name="line194"></a>        /** @type {EventTarget} */ (src),
<a name="line195"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line196"></a>        listener, /* callOnce */ false, opt_capt, opt_handler);
<a name="line197"></a>  }
<a name="line198"></a>};
<a name="line199"></a>
<a name="line200"></a>
<a name="line201"></a>/**
<a name="line202"></a> * Adds an event listener for a specific event on a native event
<a name="line203"></a> * target. A listener can only be added once to an object and if it
<a name="line204"></a> * is added again the key for the listener is returned.
<a name="line205"></a> *
<a name="line206"></a> * Note that a one-off listener will not change an existing listener,
<a name="line207"></a> * if any. On the other hand a normal listener will change existing
<a name="line208"></a> * one-off listener to become a normal listener.
<a name="line209"></a> *
<a name="line210"></a> * @param {EventTarget} src The node to listen to events on.
<a name="line211"></a> * @param {string|!goog.events.EventId} type Event type.
<a name="line212"></a> * @param {!Function} listener Callback function.
<a name="line213"></a> * @param {boolean} callOnce Whether the listener is a one-off
<a name="line214"></a> *     listener or otherwise.
<a name="line215"></a> * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
<a name="line216"></a> *     false).
<a name="line217"></a> * @param {Object=} opt_handler Element in whose scope to call the listener.
<a name="line218"></a> * @return {goog.events.ListenableKey} Unique key for the listener.
<a name="line219"></a> * @private
<a name="line220"></a> */
<a name="line221"></a>goog.events.listen_ = function(
<a name="line222"></a>    src, type, listener, callOnce, opt_capt, opt_handler) {
<a name="line223"></a>  if (!type) {
<a name="line224"></a>    throw Error(&#39;Invalid event type&#39;);
<a name="line225"></a>  }
<a name="line226"></a>
<a name="line227"></a>  var capture = !!opt_capt;
<a name="line228"></a>  if (capture &amp;&amp; !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
<a name="line229"></a>    if (goog.events.CAPTURE_SIMULATION_MODE ==
<a name="line230"></a>        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
<a name="line231"></a>      goog.asserts.fail(&#39;Can not register capture listener in IE8-.&#39;);
<a name="line232"></a>      return null;
<a name="line233"></a>    } else if (goog.events.CAPTURE_SIMULATION_MODE ==
<a name="line234"></a>        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {
<a name="line235"></a>      return null;
<a name="line236"></a>    }
<a name="line237"></a>  }
<a name="line238"></a>
<a name="line239"></a>  var listenerMap = goog.events.getListenerMap_(src);
<a name="line240"></a>  if (!listenerMap) {
<a name="line241"></a>    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
<a name="line242"></a>        new goog.events.ListenerMap(src);
<a name="line243"></a>  }
<a name="line244"></a>
<a name="line245"></a>  var listenerObj = listenerMap.add(
<a name="line246"></a>      type, listener, callOnce, opt_capt, opt_handler);
<a name="line247"></a>
<a name="line248"></a>  // If the listenerObj already has a proxy, it has been set up
<a name="line249"></a>  // previously. We simply return.
<a name="line250"></a>  if (listenerObj.proxy) {
<a name="line251"></a>    return listenerObj;
<a name="line252"></a>  }
<a name="line253"></a>
<a name="line254"></a>  var proxy = goog.events.getProxy();
<a name="line255"></a>  listenerObj.proxy = proxy;
<a name="line256"></a>
<a name="line257"></a>  proxy.src = src;
<a name="line258"></a>  proxy.listener = listenerObj;
<a name="line259"></a>
<a name="line260"></a>  // Attach the proxy through the browser&#39;s API
<a name="line261"></a>  if (src.addEventListener) {
<a name="line262"></a>    src.addEventListener(type.toString(), proxy, capture);
<a name="line263"></a>  } else {
<a name="line264"></a>    // The else above used to be else if (src.attachEvent) and then there was
<a name="line265"></a>    // another else statement that threw an exception warning the developer
<a name="line266"></a>    // they made a mistake. This resulted in an extra object allocation in IE6
<a name="line267"></a>    // due to a wrapper object that had to be implemented around the element
<a name="line268"></a>    // and so was removed.
<a name="line269"></a>    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);
<a name="line270"></a>  }
<a name="line271"></a>
<a name="line272"></a>  goog.events.listenerCountEstimate_++;
<a name="line273"></a>  return listenerObj;
<a name="line274"></a>};
<a name="line275"></a>
<a name="line276"></a>
<a name="line277"></a>/**
<a name="line278"></a> * Helper function for returning a proxy function.
<a name="line279"></a> * @return {!Function} A new or reused function object.
<a name="line280"></a> */
<a name="line281"></a>goog.events.getProxy = function() {
<a name="line282"></a>  var proxyCallbackFunction = goog.events.handleBrowserEvent_;
<a name="line283"></a>  // Use a local var f to prevent one allocation.
<a name="line284"></a>  var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ?
<a name="line285"></a>      function(eventObject) {
<a name="line286"></a>        return proxyCallbackFunction.call(f.src, f.listener, eventObject);
<a name="line287"></a>      } :
<a name="line288"></a>      function(eventObject) {
<a name="line289"></a>        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
<a name="line290"></a>        // NOTE(user): In IE, we hack in a capture phase. However, if
<a name="line291"></a>        // there is inline event handler which tries to prevent default (for
<a name="line292"></a>        // example &lt;a href=&quot;...&quot; onclick=&quot;return false&quot;&gt;...&lt;/a&gt;) in a
<a name="line293"></a>        // descendant element, the prevent default will be overridden
<a name="line294"></a>        // by this listener if this listener were to return true. Hence, we
<a name="line295"></a>        // return undefined.
<a name="line296"></a>        if (!v) return v;
<a name="line297"></a>      };
<a name="line298"></a>  return f;
<a name="line299"></a>};
<a name="line300"></a>
<a name="line301"></a>
<a name="line302"></a>/**
<a name="line303"></a> * Adds an event listener for a specific event on a native event
<a name="line304"></a> * target (such as a DOM element) or an object that has implemented
<a name="line305"></a> * {@link goog.events.Listenable}. After the event has fired the event
<a name="line306"></a> * listener is removed from the target.
<a name="line307"></a> *
<a name="line308"></a> * If an existing listener already exists, listenOnce will do
<a name="line309"></a> * nothing. In particular, if the listener was previously registered
<a name="line310"></a> * via listen(), listenOnce() will not turn the listener into a
<a name="line311"></a> * one-off listener. Similarly, if there is already an existing
<a name="line312"></a> * one-off listener, listenOnce does not modify the listeners (it is
<a name="line313"></a> * still a once listener).
<a name="line314"></a> *
<a name="line315"></a> * @param {EventTarget|goog.events.Listenable} src The node to listen
<a name="line316"></a> *     to events on.
<a name="line317"></a> * @param {string|Array.&lt;string&gt;|
<a name="line318"></a> *     !goog.events.EventId.&lt;EVENTOBJ&gt;|!Array.&lt;!goog.events.EventId.&lt;EVENTOBJ&gt;&gt;}
<a name="line319"></a> *     type Event type or array of event types.
<a name="line320"></a> * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
<a name="line321"></a> *     listener Callback method.
<a name="line322"></a> * @param {boolean=} opt_capt Fire in capture phase?.
<a name="line323"></a> * @param {T=} opt_handler Element in whose scope to call the listener.
<a name="line324"></a> * @return {goog.events.Key} Unique key for the listener.
<a name="line325"></a> * @template T,EVENTOBJ
<a name="line326"></a> */
<a name="line327"></a>goog.events.listenOnce = function(src, type, listener, opt_capt, opt_handler) {
<a name="line328"></a>  if (goog.isArray(type)) {
<a name="line329"></a>    for (var i = 0; i &lt; type.length; i++) {
<a name="line330"></a>      goog.events.listenOnce(src, type[i], listener, opt_capt, opt_handler);
<a name="line331"></a>    }
<a name="line332"></a>    return null;
<a name="line333"></a>  }
<a name="line334"></a>
<a name="line335"></a>  listener = goog.events.wrapListener(listener);
<a name="line336"></a>  if (goog.events.Listenable.isImplementedBy(src)) {
<a name="line337"></a>    return src.listenOnce(
<a name="line338"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line339"></a>        listener, opt_capt, opt_handler);
<a name="line340"></a>  } else {
<a name="line341"></a>    return goog.events.listen_(
<a name="line342"></a>        /** @type {EventTarget} */ (src),
<a name="line343"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line344"></a>        listener, /* callOnce */ true, opt_capt, opt_handler);
<a name="line345"></a>  }
<a name="line346"></a>};
<a name="line347"></a>
<a name="line348"></a>
<a name="line349"></a>/**
<a name="line350"></a> * Adds an event listener with a specific event wrapper on a DOM Node or an
<a name="line351"></a> * object that has implemented {@link goog.events.Listenable}. A listener can
<a name="line352"></a> * only be added once to an object.
<a name="line353"></a> *
<a name="line354"></a> * @param {EventTarget|goog.events.Listenable} src The target to
<a name="line355"></a> *     listen to events on.
<a name="line356"></a> * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
<a name="line357"></a> * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
<a name="line358"></a> *     Callback method, or an object with a handleEvent function.
<a name="line359"></a> * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
<a name="line360"></a> *     false).
<a name="line361"></a> * @param {T=} opt_handler Element in whose scope to call the listener.
<a name="line362"></a> * @template T
<a name="line363"></a> */
<a name="line364"></a>goog.events.listenWithWrapper = function(src, wrapper, listener, opt_capt,
<a name="line365"></a>    opt_handler) {
<a name="line366"></a>  wrapper.listen(src, listener, opt_capt, opt_handler);
<a name="line367"></a>};
<a name="line368"></a>
<a name="line369"></a>
<a name="line370"></a>/**
<a name="line371"></a> * Removes an event listener which was added with listen().
<a name="line372"></a> *
<a name="line373"></a> * @param {EventTarget|goog.events.Listenable} src The target to stop
<a name="line374"></a> *     listening to events on.
<a name="line375"></a> * @param {string|Array.&lt;string&gt;|
<a name="line376"></a> *     !goog.events.EventId.&lt;EVENTOBJ&gt;|!Array.&lt;!goog.events.EventId.&lt;EVENTOBJ&gt;&gt;}
<a name="line377"></a> *     type Event type or array of event types to unlisten to.
<a name="line378"></a> * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
<a name="line379"></a> *     listener function to remove.
<a name="line380"></a> * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
<a name="line381"></a> *     whether the listener is fired during the capture or bubble phase of the
<a name="line382"></a> *     event.
<a name="line383"></a> * @param {Object=} opt_handler Element in whose scope to call the listener.
<a name="line384"></a> * @return {?boolean} indicating whether the listener was there to remove.
<a name="line385"></a> * @template EVENTOBJ
<a name="line386"></a> */
<a name="line387"></a>goog.events.unlisten = function(src, type, listener, opt_capt, opt_handler) {
<a name="line388"></a>  if (goog.isArray(type)) {
<a name="line389"></a>    for (var i = 0; i &lt; type.length; i++) {
<a name="line390"></a>      goog.events.unlisten(src, type[i], listener, opt_capt, opt_handler);
<a name="line391"></a>    }
<a name="line392"></a>    return null;
<a name="line393"></a>  }
<a name="line394"></a>
<a name="line395"></a>  listener = goog.events.wrapListener(listener);
<a name="line396"></a>  if (goog.events.Listenable.isImplementedBy(src)) {
<a name="line397"></a>    return src.unlisten(
<a name="line398"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line399"></a>        listener, opt_capt, opt_handler);
<a name="line400"></a>  }
<a name="line401"></a>
<a name="line402"></a>  if (!src) {
<a name="line403"></a>    // TODO(user): We should tighten the API to only accept
<a name="line404"></a>    // non-null objects, or add an assertion here.
<a name="line405"></a>    return false;
<a name="line406"></a>  }
<a name="line407"></a>
<a name="line408"></a>  var capture = !!opt_capt;
<a name="line409"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line410"></a>      /** @type {EventTarget} */ (src));
<a name="line411"></a>  if (listenerMap) {
<a name="line412"></a>    var listenerObj = listenerMap.getListener(
<a name="line413"></a>        /** @type {string|!goog.events.EventId} */ (type),
<a name="line414"></a>        listener, capture, opt_handler);
<a name="line415"></a>    if (listenerObj) {
<a name="line416"></a>      return goog.events.unlistenByKey(listenerObj);
<a name="line417"></a>    }
<a name="line418"></a>  }
<a name="line419"></a>
<a name="line420"></a>  return false;
<a name="line421"></a>};
<a name="line422"></a>
<a name="line423"></a>
<a name="line424"></a>/**
<a name="line425"></a> * Removes an event listener which was added with listen() by the key
<a name="line426"></a> * returned by listen().
<a name="line427"></a> *
<a name="line428"></a> * @param {goog.events.Key} key The key returned by listen() for this
<a name="line429"></a> *     event listener.
<a name="line430"></a> * @return {boolean} indicating whether the listener was there to remove.
<a name="line431"></a> */
<a name="line432"></a>goog.events.unlistenByKey = function(key) {
<a name="line433"></a>  // TODO(user): Remove this check when tests that rely on this
<a name="line434"></a>  // are fixed.
<a name="line435"></a>  if (goog.isNumber(key)) {
<a name="line436"></a>    return false;
<a name="line437"></a>  }
<a name="line438"></a>
<a name="line439"></a>  var listener = /** @type {goog.events.ListenableKey} */ (key);
<a name="line440"></a>  if (!listener || listener.removed) {
<a name="line441"></a>    return false;
<a name="line442"></a>  }
<a name="line443"></a>
<a name="line444"></a>  var src = listener.src;
<a name="line445"></a>  if (goog.events.Listenable.isImplementedBy(src)) {
<a name="line446"></a>    return src.unlistenByKey(listener);
<a name="line447"></a>  }
<a name="line448"></a>
<a name="line449"></a>  var type = listener.type;
<a name="line450"></a>  var proxy = listener.proxy;
<a name="line451"></a>  if (src.removeEventListener) {
<a name="line452"></a>    src.removeEventListener(type, proxy, listener.capture);
<a name="line453"></a>  } else if (src.detachEvent) {
<a name="line454"></a>    src.detachEvent(goog.events.getOnString_(type), proxy);
<a name="line455"></a>  }
<a name="line456"></a>  goog.events.listenerCountEstimate_--;
<a name="line457"></a>
<a name="line458"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line459"></a>      /** @type {EventTarget} */ (src));
<a name="line460"></a>  // TODO(user): Try to remove this conditional and execute the
<a name="line461"></a>  // first branch always. This should be safe.
<a name="line462"></a>  if (listenerMap) {
<a name="line463"></a>    listenerMap.removeByKey(listener);
<a name="line464"></a>    if (listenerMap.getTypeCount() == 0) {
<a name="line465"></a>      // Null the src, just because this is simple to do (and useful
<a name="line466"></a>      // for IE &lt;= 7).
<a name="line467"></a>      listenerMap.src = null;
<a name="line468"></a>      // We don&#39;t use delete here because IE does not allow delete
<a name="line469"></a>      // on a window object.
<a name="line470"></a>      src[goog.events.LISTENER_MAP_PROP_] = null;
<a name="line471"></a>    }
<a name="line472"></a>  } else {
<a name="line473"></a>    listener.markAsRemoved();
<a name="line474"></a>  }
<a name="line475"></a>
<a name="line476"></a>  return true;
<a name="line477"></a>};
<a name="line478"></a>
<a name="line479"></a>
<a name="line480"></a>/**
<a name="line481"></a> * Removes an event listener which was added with listenWithWrapper().
<a name="line482"></a> *
<a name="line483"></a> * @param {EventTarget|goog.events.Listenable} src The target to stop
<a name="line484"></a> *     listening to events on.
<a name="line485"></a> * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
<a name="line486"></a> * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
<a name="line487"></a> *     listener function to remove.
<a name="line488"></a> * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
<a name="line489"></a> *     whether the listener is fired during the capture or bubble phase of the
<a name="line490"></a> *     event.
<a name="line491"></a> * @param {Object=} opt_handler Element in whose scope to call the listener.
<a name="line492"></a> */
<a name="line493"></a>goog.events.unlistenWithWrapper = function(src, wrapper, listener, opt_capt,
<a name="line494"></a>    opt_handler) {
<a name="line495"></a>  wrapper.unlisten(src, listener, opt_capt, opt_handler);
<a name="line496"></a>};
<a name="line497"></a>
<a name="line498"></a>
<a name="line499"></a>/**
<a name="line500"></a> * Removes all listeners from an object. You can also optionally
<a name="line501"></a> * remove listeners of a particular type.
<a name="line502"></a> *
<a name="line503"></a> * @param {Object=} opt_obj Object to remove listeners from. Not
<a name="line504"></a> *     specifying opt_obj is now DEPRECATED (it used to remove all
<a name="line505"></a> *     registered listeners).
<a name="line506"></a> * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
<a name="line507"></a> *     Default is all types.
<a name="line508"></a> * @return {number} Number of listeners removed.
<a name="line509"></a> */
<a name="line510"></a>goog.events.removeAll = function(opt_obj, opt_type) {
<a name="line511"></a>  // TODO(user): Change the type of opt_obj from Object= to
<a name="line512"></a>  // !EventTarget|goog.events.Listenable). And replace this with an
<a name="line513"></a>  // assertion.
<a name="line514"></a>  if (!opt_obj) {
<a name="line515"></a>    return 0;
<a name="line516"></a>  }
<a name="line517"></a>
<a name="line518"></a>  if (goog.events.Listenable.isImplementedBy(opt_obj)) {
<a name="line519"></a>    return opt_obj.removeAllListeners(opt_type);
<a name="line520"></a>  }
<a name="line521"></a>
<a name="line522"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line523"></a>      /** @type {EventTarget} */ (opt_obj));
<a name="line524"></a>  if (!listenerMap) {
<a name="line525"></a>    return 0;
<a name="line526"></a>  }
<a name="line527"></a>
<a name="line528"></a>  var count = 0;
<a name="line529"></a>  var typeStr = opt_type &amp;&amp; opt_type.toString();
<a name="line530"></a>  for (var type in listenerMap.listeners) {
<a name="line531"></a>    if (!typeStr || type == typeStr) {
<a name="line532"></a>      // Clone so that we don&#39;t need to worry about unlistenByKey
<a name="line533"></a>      // changing the content of the ListenerMap.
<a name="line534"></a>      var listeners = listenerMap.listeners[type].concat();
<a name="line535"></a>      for (var i = 0; i &lt; listeners.length; ++i) {
<a name="line536"></a>        if (goog.events.unlistenByKey(listeners[i])) {
<a name="line537"></a>          ++count;
<a name="line538"></a>        }
<a name="line539"></a>      }
<a name="line540"></a>    }
<a name="line541"></a>  }
<a name="line542"></a>  return count;
<a name="line543"></a>};
<a name="line544"></a>
<a name="line545"></a>
<a name="line546"></a>/**
<a name="line547"></a> * Removes all native listeners registered via goog.events. Native
<a name="line548"></a> * listeners are listeners on native browser objects (such as DOM
<a name="line549"></a> * elements). In particular, goog.events.Listenable and
<a name="line550"></a> * goog.events.EventTarget listeners will NOT be removed.
<a name="line551"></a> * @return {number} Number of listeners removed.
<a name="line552"></a> * @deprecated This doesn&#39;t do anything, now that Closure no longer
<a name="line553"></a> * stores a central listener registry.
<a name="line554"></a> */
<a name="line555"></a>goog.events.removeAllNativeListeners = function() {
<a name="line556"></a>  goog.events.listenerCountEstimate_ = 0;
<a name="line557"></a>  return 0;
<a name="line558"></a>};
<a name="line559"></a>
<a name="line560"></a>
<a name="line561"></a>/**
<a name="line562"></a> * Gets the listeners for a given object, type and capture phase.
<a name="line563"></a> *
<a name="line564"></a> * @param {Object} obj Object to get listeners for.
<a name="line565"></a> * @param {string|!goog.events.EventId} type Event type.
<a name="line566"></a> * @param {boolean} capture Capture phase?.
<a name="line567"></a> * @return {Array.&lt;goog.events.Listener&gt;} Array of listener objects.
<a name="line568"></a> */
<a name="line569"></a>goog.events.getListeners = function(obj, type, capture) {
<a name="line570"></a>  if (goog.events.Listenable.isImplementedBy(obj)) {
<a name="line571"></a>    return obj.getListeners(type, capture);
<a name="line572"></a>  } else {
<a name="line573"></a>    if (!obj) {
<a name="line574"></a>      // TODO(user): We should tighten the API to accept
<a name="line575"></a>      // !EventTarget|goog.events.Listenable, and add an assertion here.
<a name="line576"></a>      return [];
<a name="line577"></a>    }
<a name="line578"></a>
<a name="line579"></a>    var listenerMap = goog.events.getListenerMap_(
<a name="line580"></a>        /** @type {EventTarget} */ (obj));
<a name="line581"></a>    return listenerMap ? listenerMap.getListeners(type, capture) : [];
<a name="line582"></a>  }
<a name="line583"></a>};
<a name="line584"></a>
<a name="line585"></a>
<a name="line586"></a>/**
<a name="line587"></a> * Gets the goog.events.Listener for the event or null if no such listener is
<a name="line588"></a> * in use.
<a name="line589"></a> *
<a name="line590"></a> * @param {EventTarget|goog.events.Listenable} src The target from
<a name="line591"></a> *     which to get listeners.
<a name="line592"></a> * @param {?string|!goog.events.EventId.&lt;EVENTOBJ&gt;} type The type of the event.
<a name="line593"></a> * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The
<a name="line594"></a> *     listener function to get.
<a name="line595"></a> * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
<a name="line596"></a> *                            whether the listener is fired during the
<a name="line597"></a> *                            capture or bubble phase of the event.
<a name="line598"></a> * @param {Object=} opt_handler Element in whose scope to call the listener.
<a name="line599"></a> * @return {goog.events.ListenableKey} the found listener or null if not found.
<a name="line600"></a> * @template EVENTOBJ
<a name="line601"></a> */
<a name="line602"></a>goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
<a name="line603"></a>  // TODO(user): Change type from ?string to string, or add assertion.
<a name="line604"></a>  type = /** @type {string} */ (type);
<a name="line605"></a>  listener = goog.events.wrapListener(listener);
<a name="line606"></a>  var capture = !!opt_capt;
<a name="line607"></a>  if (goog.events.Listenable.isImplementedBy(src)) {
<a name="line608"></a>    return src.getListener(type, listener, capture, opt_handler);
<a name="line609"></a>  }
<a name="line610"></a>
<a name="line611"></a>  if (!src) {
<a name="line612"></a>    // TODO(user): We should tighten the API to only accept
<a name="line613"></a>    // non-null objects, or add an assertion here.
<a name="line614"></a>    return null;
<a name="line615"></a>  }
<a name="line616"></a>
<a name="line617"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line618"></a>      /** @type {EventTarget} */ (src));
<a name="line619"></a>  if (listenerMap) {
<a name="line620"></a>    return listenerMap.getListener(type, listener, capture, opt_handler);
<a name="line621"></a>  }
<a name="line622"></a>  return null;
<a name="line623"></a>};
<a name="line624"></a>
<a name="line625"></a>
<a name="line626"></a>/**
<a name="line627"></a> * Returns whether an event target has any active listeners matching the
<a name="line628"></a> * specified signature. If either the type or capture parameters are
<a name="line629"></a> * unspecified, the function will match on the remaining criteria.
<a name="line630"></a> *
<a name="line631"></a> * @param {EventTarget|goog.events.Listenable} obj Target to get
<a name="line632"></a> *     listeners for.
<a name="line633"></a> * @param {string|!goog.events.EventId=} opt_type Event type.
<a name="line634"></a> * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
<a name="line635"></a> *     listeners.
<a name="line636"></a> * @return {boolean} Whether an event target has one or more listeners matching
<a name="line637"></a> *     the requested type and/or capture phase.
<a name="line638"></a> */
<a name="line639"></a>goog.events.hasListener = function(obj, opt_type, opt_capture) {
<a name="line640"></a>  if (goog.events.Listenable.isImplementedBy(obj)) {
<a name="line641"></a>    return obj.hasListener(opt_type, opt_capture);
<a name="line642"></a>  }
<a name="line643"></a>
<a name="line644"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line645"></a>      /** @type {EventTarget} */ (obj));
<a name="line646"></a>  return !!listenerMap &amp;&amp; listenerMap.hasListener(opt_type, opt_capture);
<a name="line647"></a>};
<a name="line648"></a>
<a name="line649"></a>
<a name="line650"></a>/**
<a name="line651"></a> * Provides a nice string showing the normalized event objects public members
<a name="line652"></a> * @param {Object} e Event Object.
<a name="line653"></a> * @return {string} String of the public members of the normalized event object.
<a name="line654"></a> */
<a name="line655"></a>goog.events.expose = function(e) {
<a name="line656"></a>  var str = [];
<a name="line657"></a>  for (var key in e) {
<a name="line658"></a>    if (e[key] &amp;&amp; e[key].id) {
<a name="line659"></a>      str.push(key + &#39; = &#39; + e[key] + &#39; (&#39; + e[key].id + &#39;)&#39;);
<a name="line660"></a>    } else {
<a name="line661"></a>      str.push(key + &#39; = &#39; + e[key]);
<a name="line662"></a>    }
<a name="line663"></a>  }
<a name="line664"></a>  return str.join(&#39;\n&#39;);
<a name="line665"></a>};
<a name="line666"></a>
<a name="line667"></a>
<a name="line668"></a>/**
<a name="line669"></a> * Returns a string with on prepended to the specified type. This is used for IE
<a name="line670"></a> * which expects &quot;on&quot; to be prepended. This function caches the string in order
<a name="line671"></a> * to avoid extra allocations in steady state.
<a name="line672"></a> * @param {string} type Event type.
<a name="line673"></a> * @return {string} The type string with &#39;on&#39; prepended.
<a name="line674"></a> * @private
<a name="line675"></a> */
<a name="line676"></a>goog.events.getOnString_ = function(type) {
<a name="line677"></a>  if (type in goog.events.onStringMap_) {
<a name="line678"></a>    return goog.events.onStringMap_[type];
<a name="line679"></a>  }
<a name="line680"></a>  return goog.events.onStringMap_[type] = goog.events.onString_ + type;
<a name="line681"></a>};
<a name="line682"></a>
<a name="line683"></a>
<a name="line684"></a>/**
<a name="line685"></a> * Fires an object&#39;s listeners of a particular type and phase
<a name="line686"></a> *
<a name="line687"></a> * @param {Object} obj Object whose listeners to call.
<a name="line688"></a> * @param {string|!goog.events.EventId} type Event type.
<a name="line689"></a> * @param {boolean} capture Which event phase.
<a name="line690"></a> * @param {Object} eventObject Event object to be passed to listener.
<a name="line691"></a> * @return {boolean} True if all listeners returned true else false.
<a name="line692"></a> */
<a name="line693"></a>goog.events.fireListeners = function(obj, type, capture, eventObject) {
<a name="line694"></a>  if (goog.events.Listenable.isImplementedBy(obj)) {
<a name="line695"></a>    return obj.fireListeners(type, capture, eventObject);
<a name="line696"></a>  }
<a name="line697"></a>
<a name="line698"></a>  return goog.events.fireListeners_(obj, type, capture, eventObject);
<a name="line699"></a>};
<a name="line700"></a>
<a name="line701"></a>
<a name="line702"></a>/**
<a name="line703"></a> * Fires an object&#39;s listeners of a particular type and phase.
<a name="line704"></a> * @param {Object} obj Object whose listeners to call.
<a name="line705"></a> * @param {string|!goog.events.EventId} type Event type.
<a name="line706"></a> * @param {boolean} capture Which event phase.
<a name="line707"></a> * @param {Object} eventObject Event object to be passed to listener.
<a name="line708"></a> * @return {boolean} True if all listeners returned true else false.
<a name="line709"></a> * @private
<a name="line710"></a> */
<a name="line711"></a>goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
<a name="line712"></a>  var retval = 1;
<a name="line713"></a>
<a name="line714"></a>  var listenerMap = goog.events.getListenerMap_(
<a name="line715"></a>      /** @type {EventTarget} */ (obj));
<a name="line716"></a>  if (listenerMap) {
<a name="line717"></a>    // TODO(user): Original code avoids array creation when there
<a name="line718"></a>    // is no listener, so we do the same. If this optimization turns
<a name="line719"></a>    // out to be not required, we can replace this with
<a name="line720"></a>    // listenerMap.getListeners(type, capture) instead, which is simpler.
<a name="line721"></a>    var listenerArray = listenerMap.listeners[type.toString()];
<a name="line722"></a>    if (listenerArray) {
<a name="line723"></a>      listenerArray = listenerArray.concat();
<a name="line724"></a>      for (var i = 0; i &lt; listenerArray.length; i++) {
<a name="line725"></a>        var listener = listenerArray[i];
<a name="line726"></a>        // We might not have a listener if the listener was removed.
<a name="line727"></a>        if (listener &amp;&amp; listener.capture == capture &amp;&amp; !listener.removed) {
<a name="line728"></a>          retval &amp;=
<a name="line729"></a>              goog.events.fireListener(listener, eventObject) !== false;
<a name="line730"></a>        }
<a name="line731"></a>      }
<a name="line732"></a>    }
<a name="line733"></a>  }
<a name="line734"></a>  return Boolean(retval);
<a name="line735"></a>};
<a name="line736"></a>
<a name="line737"></a>
<a name="line738"></a>/**
<a name="line739"></a> * Fires a listener with a set of arguments
<a name="line740"></a> *
<a name="line741"></a> * @param {goog.events.Listener} listener The listener object to call.
<a name="line742"></a> * @param {Object} eventObject The event object to pass to the listener.
<a name="line743"></a> * @return {boolean} Result of listener.
<a name="line744"></a> */
<a name="line745"></a>goog.events.fireListener = function(listener, eventObject) {
<a name="line746"></a>  var listenerFn = listener.listener;
<a name="line747"></a>  var listenerHandler = listener.handler || listener.src;
<a name="line748"></a>
<a name="line749"></a>  if (listener.callOnce) {
<a name="line750"></a>    goog.events.unlistenByKey(listener);
<a name="line751"></a>  }
<a name="line752"></a>  return listenerFn.call(listenerHandler, eventObject);
<a name="line753"></a>};
<a name="line754"></a>
<a name="line755"></a>
<a name="line756"></a>/**
<a name="line757"></a> * Gets the total number of listeners currently in the system.
<a name="line758"></a> * @return {number} Number of listeners.
<a name="line759"></a> * @deprecated This returns estimated count, now that Closure no longer
<a name="line760"></a> * stores a central listener registry. We still return an estimation
<a name="line761"></a> * to keep existing listener-related tests passing. In the near future,
<a name="line762"></a> * this function will be removed.
<a name="line763"></a> */
<a name="line764"></a>goog.events.getTotalListenerCount = function() {
<a name="line765"></a>  return goog.events.listenerCountEstimate_;
<a name="line766"></a>};
<a name="line767"></a>
<a name="line768"></a>
<a name="line769"></a>/**
<a name="line770"></a> * Dispatches an event (or event like object) and calls all listeners
<a name="line771"></a> * listening for events of this type. The type of the event is decided by the
<a name="line772"></a> * type property on the event object.
<a name="line773"></a> *
<a name="line774"></a> * If any of the listeners returns false OR calls preventDefault then this
<a name="line775"></a> * function will return false.  If one of the capture listeners calls
<a name="line776"></a> * stopPropagation, then the bubble listeners won&#39;t fire.
<a name="line777"></a> *
<a name="line778"></a> * @param {goog.events.Listenable} src The event target.
<a name="line779"></a> * @param {goog.events.EventLike} e Event object.
<a name="line780"></a> * @return {boolean} If anyone called preventDefault on the event object (or
<a name="line781"></a> *     if any of the handlers returns false) this will also return false.
<a name="line782"></a> *     If there are no handlers, or if all handlers return true, this returns
<a name="line783"></a> *     true.
<a name="line784"></a> */
<a name="line785"></a>goog.events.dispatchEvent = function(src, e) {
<a name="line786"></a>  goog.asserts.assert(
<a name="line787"></a>      goog.events.Listenable.isImplementedBy(src),
<a name="line788"></a>      &#39;Can not use goog.events.dispatchEvent with &#39; +
<a name="line789"></a>      &#39;non-goog.events.Listenable instance.&#39;);
<a name="line790"></a>  return src.dispatchEvent(e);
<a name="line791"></a>};
<a name="line792"></a>
<a name="line793"></a>
<a name="line794"></a>/**
<a name="line795"></a> * Installs exception protection for the browser event entry point using the
<a name="line796"></a> * given error handler.
<a name="line797"></a> *
<a name="line798"></a> * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
<a name="line799"></a> *     protect the entry point.
<a name="line800"></a> */
<a name="line801"></a>goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
<a name="line802"></a>  goog.events.handleBrowserEvent_ = errorHandler.protectEntryPoint(
<a name="line803"></a>      goog.events.handleBrowserEvent_);
<a name="line804"></a>};
<a name="line805"></a>
<a name="line806"></a>
<a name="line807"></a>/**
<a name="line808"></a> * Handles an event and dispatches it to the correct listeners. This
<a name="line809"></a> * function is a proxy for the real listener the user specified.
<a name="line810"></a> *
<a name="line811"></a> * @param {goog.events.Listener} listener The listener object.
<a name="line812"></a> * @param {Event=} opt_evt Optional event object that gets passed in via the
<a name="line813"></a> *     native event handlers.
<a name="line814"></a> * @return {boolean} Result of the event handler.
<a name="line815"></a> * @this {EventTarget} The object or Element that fired the event.
<a name="line816"></a> * @private
<a name="line817"></a> */
<a name="line818"></a>goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
<a name="line819"></a>  if (listener.removed) {
<a name="line820"></a>    return true;
<a name="line821"></a>  }
<a name="line822"></a>
<a name="line823"></a>  // Synthesize event propagation if the browser does not support W3C
<a name="line824"></a>  // event model.
<a name="line825"></a>  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
<a name="line826"></a>    var ieEvent = opt_evt ||
<a name="line827"></a>        /** @type {Event} */ (goog.getObjectByName(&#39;window.event&#39;));
<a name="line828"></a>    var evt = new goog.events.BrowserEvent(ieEvent, this);
<a name="line829"></a>    var retval = true;
<a name="line830"></a>
<a name="line831"></a>    if (goog.events.CAPTURE_SIMULATION_MODE ==
<a name="line832"></a>            goog.events.CaptureSimulationMode.ON) {
<a name="line833"></a>      // If we have not marked this event yet, we should perform capture
<a name="line834"></a>      // simulation.
<a name="line835"></a>      if (!goog.events.isMarkedIeEvent_(ieEvent)) {
<a name="line836"></a>        goog.events.markIeEvent_(ieEvent);
<a name="line837"></a>
<a name="line838"></a>        var ancestors = [];
<a name="line839"></a>        for (var parent = evt.currentTarget; parent;
<a name="line840"></a>             parent = parent.parentNode) {
<a name="line841"></a>          ancestors.push(parent);
<a name="line842"></a>        }
<a name="line843"></a>
<a name="line844"></a>        // Fire capture listeners.
<a name="line845"></a>        var type = listener.type;
<a name="line846"></a>        for (var i = ancestors.length - 1; !evt.propagationStopped_ &amp;&amp; i &gt;= 0;
<a name="line847"></a>             i--) {
<a name="line848"></a>          evt.currentTarget = ancestors[i];
<a name="line849"></a>          retval &amp;= goog.events.fireListeners_(ancestors[i], type, true, evt);
<a name="line850"></a>        }
<a name="line851"></a>
<a name="line852"></a>        // Fire bubble listeners.
<a name="line853"></a>        //
<a name="line854"></a>        // We can technically rely on IE to perform bubble event
<a name="line855"></a>        // propagation. However, it turns out that IE fires events in
<a name="line856"></a>        // opposite order of attachEvent registration, which broke
<a name="line857"></a>        // some code and tests that rely on the order. (While W3C DOM
<a name="line858"></a>        // Level 2 Events TR leaves the event ordering unspecified,
<a name="line859"></a>        // modern browsers and W3C DOM Level 3 Events Working Draft
<a name="line860"></a>        // actually specify the order as the registration order.)
<a name="line861"></a>        for (var i = 0; !evt.propagationStopped_ &amp;&amp; i &lt; ancestors.length; i++) {
<a name="line862"></a>          evt.currentTarget = ancestors[i];
<a name="line863"></a>          retval &amp;= goog.events.fireListeners_(ancestors[i], type, false, evt);
<a name="line864"></a>        }
<a name="line865"></a>      }
<a name="line866"></a>    } else {
<a name="line867"></a>      retval = goog.events.fireListener(listener, evt);
<a name="line868"></a>    }
<a name="line869"></a>    return retval;
<a name="line870"></a>  }
<a name="line871"></a>
<a name="line872"></a>  // Otherwise, simply fire the listener.
<a name="line873"></a>  return goog.events.fireListener(
<a name="line874"></a>      listener, new goog.events.BrowserEvent(opt_evt, this));
<a name="line875"></a>};
<a name="line876"></a>
<a name="line877"></a>
<a name="line878"></a>/**
<a name="line879"></a> * This is used to mark the IE event object so we do not do the Closure pass
<a name="line880"></a> * twice for a bubbling event.
<a name="line881"></a> * @param {Event} e The IE browser event.
<a name="line882"></a> * @private
<a name="line883"></a> */
<a name="line884"></a>goog.events.markIeEvent_ = function(e) {
<a name="line885"></a>  // Only the keyCode and the returnValue can be changed. We use keyCode for
<a name="line886"></a>  // non keyboard events.
<a name="line887"></a>  // event.returnValue is a bit more tricky. It is undefined by default. A
<a name="line888"></a>  // boolean false prevents the default action. In a window.onbeforeunload and
<a name="line889"></a>  // the returnValue is non undefined it will be alerted. However, we will only
<a name="line890"></a>  // modify the returnValue for keyboard events. We can get a problem if non
<a name="line891"></a>  // closure events sets the keyCode or the returnValue
<a name="line892"></a>
<a name="line893"></a>  var useReturnValue = false;
<a name="line894"></a>
<a name="line895"></a>  if (e.keyCode == 0) {
<a name="line896"></a>    // We cannot change the keyCode in case that srcElement is input[type=file].
<a name="line897"></a>    // We could test that that is the case but that would allocate 3 objects.
<a name="line898"></a>    // If we use try/catch we will only allocate extra objects in the case of a
<a name="line899"></a>    // failure.
<a name="line900"></a>    /** @preserveTry */
<a name="line901"></a>    try {
<a name="line902"></a>      e.keyCode = -1;
<a name="line903"></a>      return;
<a name="line904"></a>    } catch (ex) {
<a name="line905"></a>      useReturnValue = true;
<a name="line906"></a>    }
<a name="line907"></a>  }
<a name="line908"></a>
<a name="line909"></a>  if (useReturnValue ||
<a name="line910"></a>      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
<a name="line911"></a>    e.returnValue = true;
<a name="line912"></a>  }
<a name="line913"></a>};
<a name="line914"></a>
<a name="line915"></a>
<a name="line916"></a>/**
<a name="line917"></a> * This is used to check if an IE event has already been handled by the Closure
<a name="line918"></a> * system so we do not do the Closure pass twice for a bubbling event.
<a name="line919"></a> * @param {Event} e  The IE browser event.
<a name="line920"></a> * @return {boolean} True if the event object has been marked.
<a name="line921"></a> * @private
<a name="line922"></a> */
<a name="line923"></a>goog.events.isMarkedIeEvent_ = function(e) {
<a name="line924"></a>  return e.keyCode &lt; 0 || e.returnValue != undefined;
<a name="line925"></a>};
<a name="line926"></a>
<a name="line927"></a>
<a name="line928"></a>/**
<a name="line929"></a> * Counter to create unique event ids.
<a name="line930"></a> * @private {number}
<a name="line931"></a> */
<a name="line932"></a>goog.events.uniqueIdCounter_ = 0;
<a name="line933"></a>
<a name="line934"></a>
<a name="line935"></a>/**
<a name="line936"></a> * Creates a unique event id.
<a name="line937"></a> *
<a name="line938"></a> * @param {string} identifier The identifier.
<a name="line939"></a> * @return {string} A unique identifier.
<a name="line940"></a> * @idGenerator
<a name="line941"></a> */
<a name="line942"></a>goog.events.getUniqueId = function(identifier) {
<a name="line943"></a>  return identifier + &#39;_&#39; + goog.events.uniqueIdCounter_++;
<a name="line944"></a>};
<a name="line945"></a>
<a name="line946"></a>
<a name="line947"></a>/**
<a name="line948"></a> * @param {EventTarget} src The source object.
<a name="line949"></a> * @return {goog.events.ListenerMap} A listener map for the given
<a name="line950"></a> *     source object, or null if none exists.
<a name="line951"></a> * @private
<a name="line952"></a> */
<a name="line953"></a>goog.events.getListenerMap_ = function(src) {
<a name="line954"></a>  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
<a name="line955"></a>  // IE serializes the property as well (e.g. when serializing outer
<a name="line956"></a>  // HTML). So we must check that the value is of the correct type.
<a name="line957"></a>  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
<a name="line958"></a>};
<a name="line959"></a>
<a name="line960"></a>
<a name="line961"></a>/**
<a name="line962"></a> * Expando property for listener function wrapper for Object with
<a name="line963"></a> * handleEvent.
<a name="line964"></a> * @const
<a name="line965"></a> * @private
<a name="line966"></a> */
<a name="line967"></a>goog.events.LISTENER_WRAPPER_PROP_ = &#39;__closure_events_fn_&#39; +
<a name="line968"></a>    ((Math.random() * 1e9) &gt;&gt;&gt; 0);
<a name="line969"></a>
<a name="line970"></a>
<a name="line971"></a>/**
<a name="line972"></a> * @param {Object|Function} listener The listener function or an
<a name="line973"></a> *     object that contains handleEvent method.
<a name="line974"></a> * @return {!Function} Either the original function or a function that
<a name="line975"></a> *     calls obj.handleEvent. If the same listener is passed to this
<a name="line976"></a> *     function more than once, the same function is guaranteed to be
<a name="line977"></a> *     returned.
<a name="line978"></a> */
<a name="line979"></a>goog.events.wrapListener = function(listener) {
<a name="line980"></a>  goog.asserts.assert(listener, &#39;Listener can not be null.&#39;);
<a name="line981"></a>
<a name="line982"></a>  if (goog.isFunction(listener)) {
<a name="line983"></a>    return listener;
<a name="line984"></a>  }
<a name="line985"></a>
<a name="line986"></a>  goog.asserts.assert(
<a name="line987"></a>      listener.handleEvent, &#39;An object listener must have handleEvent method.&#39;);
<a name="line988"></a>  return listener[goog.events.LISTENER_WRAPPER_PROP_] ||
<a name="line989"></a>      (listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
<a name="line990"></a>        return listener.handleEvent(e);
<a name="line991"></a>      });
<a name="line992"></a>};
<a name="line993"></a>
<a name="line994"></a>
<a name="line995"></a>// Register the browser event handler as an entry point, so that
<a name="line996"></a>// it can be monitored for exception handling, etc.
<a name="line997"></a>goog.debug.entryPointRegistry.register(
<a name="line998"></a>    /**
<a name="line999"></a>     * @param {function(!Function): !Function} transformer The transforming
<a name="line1000"></a>     *     function.
<a name="line1001"></a>     */
<a name="line1002"></a>    function(transformer) {
<a name="line1003"></a>      goog.events.handleBrowserEvent_ = transformer(
<a name="line1004"></a>          goog.events.handleBrowserEvent_);
<a name="line1005"></a>    });
</pre>


</body>
</html>
