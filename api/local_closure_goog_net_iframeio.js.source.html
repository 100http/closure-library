<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>iframeio.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="local_closure_goog_net_iframeio.js.html">iframeio.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2006 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Class for managing requests via iFrames.  Supports a number of
<a name="line17"></a> * methods of transfer.
<a name="line18"></a> *
<a name="line19"></a> * Gets and Posts can be performed and the resultant page read in as text,
<a name="line20"></a> * JSON, or from the HTML DOM.
<a name="line21"></a> *
<a name="line22"></a> * Using an iframe causes the throbber to spin, this is good for providing
<a name="line23"></a> * feedback to the user that an action has occurred.
<a name="line24"></a> *
<a name="line25"></a> * Requests do not affect the history stack, see goog.History if you require
<a name="line26"></a> * this behavior.
<a name="line27"></a> *
<a name="line28"></a> * The responseText and responseJson methods assume the response is plain,
<a name="line29"></a> * text.  You can access the Iframe&#39;s DOM through responseXml if you need
<a name="line30"></a> * access to the raw HTML.
<a name="line31"></a> *
<a name="line32"></a> * Tested:
<a name="line33"></a> *    + FF2.0 (Win Linux)
<a name="line34"></a> *    + IE6, IE7
<a name="line35"></a> *    + Opera 9.1,
<a name="line36"></a> *    + Chrome
<a name="line37"></a> *    - Opera 8.5 fails because of no textContent and buggy innerText support
<a name="line38"></a> *
<a name="line39"></a> * NOTE: Safari doesn&#39;t fire the onload handler when loading plain text files
<a name="line40"></a> *
<a name="line41"></a> * This has been tested with Drip in IE to ensure memory usage is as constant
<a name="line42"></a> * as possible. When making making thousands of requests, memory usage stays
<a name="line43"></a> * constant for a while but then starts increasing (&lt;500k for 2000
<a name="line44"></a> * requests) -- this hasn&#39;t yet been tracked down yet, though it is cleared up
<a name="line45"></a> * after a refresh.
<a name="line46"></a> *
<a name="line47"></a> *
<a name="line48"></a> * BACKGROUND FILE UPLOAD:
<a name="line49"></a> * By posting an arbitrary form through an IframeIo object, it is possible to
<a name="line50"></a> * implement background file uploads.  Here&#39;s how to do it:
<a name="line51"></a> *
<a name="line52"></a> * - Create a form:
<a name="line53"></a> *   &lt;pre&gt;
<a name="line54"></a> *   &amp;lt;form id=&quot;form&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
<a name="line55"></a> *      &amp;lt;input name=&quot;userfile&quot; type=&quot;file&quot; /&amp;gt;
<a name="line56"></a> *   &amp;lt;/form&amp;gt;
<a name="line57"></a> *   &lt;/pre&gt;
<a name="line58"></a> *
<a name="line59"></a> * - Have the user click the file input
<a name="line60"></a> * - Create an IframeIo instance
<a name="line61"></a> *   &lt;pre&gt;
<a name="line62"></a> *   var io = new goog.net.IframeIo;
<a name="line63"></a> *   goog.events.listen(io, goog.net.EventType.COMPLETE,
<a name="line64"></a> *       function() { alert(&#39;Sent&#39;); });
<a name="line65"></a> *   io.sendFromForm(document.getElementById(&#39;form&#39;));
<a name="line66"></a> *   &lt;/pre&gt;
<a name="line67"></a> *
<a name="line68"></a> *
<a name="line69"></a> * INCREMENTAL LOADING:
<a name="line70"></a> * Gmail sends down multiple script blocks which get executed as they are
<a name="line71"></a> * received by the client. This allows incremental rendering of the thread
<a name="line72"></a> * list and conversations.
<a name="line73"></a> *
<a name="line74"></a> * This requires collaboration with the server that is sending the requested
<a name="line75"></a> * page back.  To set incremental loading up, you should:
<a name="line76"></a> *
<a name="line77"></a> * A) In the application code there should be an externed reference to
<a name="line78"></a> * &lt;code&gt;handleIncrementalData()&lt;/code&gt;.  e.g.
<a name="line79"></a> * goog.exportSymbol(&#39;GG_iframeFn&#39;, goog.net.IframeIo.handleIncrementalData);
<a name="line80"></a> *
<a name="line81"></a> * B) The response page should them call this method directly, an example
<a name="line82"></a> * response would look something like this:
<a name="line83"></a> * &lt;pre&gt;
<a name="line84"></a> *   &amp;lt;html&amp;gt;
<a name="line85"></a> *   &amp;lt;head&amp;gt;
<a name="line86"></a> *     &amp;lt;meta content=&quot;text/html;charset=UTF-8&quot; http-equiv=&quot;content-type&quot;&amp;gt;
<a name="line87"></a> *   &amp;lt;/head&amp;gt;
<a name="line88"></a> *   &amp;lt;body&amp;gt;
<a name="line89"></a> *     &amp;lt;script&amp;gt;
<a name="line90"></a> *       D = top.P ? function(d) { top.GG_iframeFn(window, d) } : function() {};
<a name="line91"></a> *     &amp;lt;/script&amp;gt;
<a name="line92"></a> *
<a name="line93"></a> *     &amp;lt;script&amp;gt;D([1, 2, 3, 4, 5]);&amp;lt;/script&amp;gt;
<a name="line94"></a> *     &amp;lt;script&amp;gt;D([6, 7, 8, 9, 10]);&amp;lt;/script&amp;gt;
<a name="line95"></a> *     &amp;lt;script&amp;gt;D([11, 12, 13, 14, 15]);&amp;lt;/script&amp;gt;
<a name="line96"></a> *   &amp;lt;/body&amp;gt;
<a name="line97"></a> *   &amp;lt;/html&amp;gt;
<a name="line98"></a> * &lt;/pre&gt;
<a name="line99"></a> *
<a name="line100"></a> * Your application should then listen, on the IframeIo instance, to the event
<a name="line101"></a> * goog.net.EventType.INCREMENTAL_DATA.  The event object contains a
<a name="line102"></a> * &#39;data&#39; member which is the content from the D() calls above.
<a name="line103"></a> *
<a name="line104"></a> * NOTE: There can be problems if you save a reference to the data object in IE.
<a name="line105"></a> * If you save an array, and the iframe is dispose, then the array looses its
<a name="line106"></a> * prototype and thus array methods like .join().  You can get around this by
<a name="line107"></a> * creating arrays using the parent window&#39;s Array constructor, or you can
<a name="line108"></a> * clone the array.
<a name="line109"></a> *
<a name="line110"></a> *
<a name="line111"></a> * EVENT MODEL:
<a name="line112"></a> * The various send methods work asynchronously. You can be notified about
<a name="line113"></a> * the current status of the request (completed, success or error) by
<a name="line114"></a> * listening for events on the IframeIo object itself. The following events
<a name="line115"></a> * will be sent:
<a name="line116"></a> * - goog.net.EventType.COMPLETE: when the request is completed
<a name="line117"></a> *   (either sucessfully or unsuccessfully). You can find out about the result
<a name="line118"></a> *   using the isSuccess() and getLastError
<a name="line119"></a> *   methods.
<a name="line120"></a> * - goog.net.EventType.SUCCESS&lt;/code&gt;: when the request was completed
<a name="line121"></a> *   successfully
<a name="line122"></a> * - goog.net.EventType.ERROR: when the request failed
<a name="line123"></a> * - goog.net.EventType.ABORT: when the request has been aborted
<a name="line124"></a> *
<a name="line125"></a> * Example:
<a name="line126"></a> * &lt;pre&gt;
<a name="line127"></a> * var io = new goog.net.IframeIo();
<a name="line128"></a> * goog.events.listen(io, goog.net.EventType.COMPLETE,
<a name="line129"></a> *   function() { alert(&#39;request complete&#39;); });
<a name="line130"></a> * io.sendFromForm(...);
<a name="line131"></a> * &lt;/pre&gt;
<a name="line132"></a> *
<a name="line133"></a> */
<a name="line134"></a>
<a name="line135"></a>goog.provide(&#39;goog.net.IframeIo&#39;);
<a name="line136"></a>goog.provide(&#39;goog.net.IframeIo.IncrementalDataEvent&#39;);
<a name="line137"></a>
<a name="line138"></a>goog.require(&#39;goog.Timer&#39;);
<a name="line139"></a>goog.require(&#39;goog.Uri&#39;);
<a name="line140"></a>goog.require(&#39;goog.debug&#39;);
<a name="line141"></a>goog.require(&#39;goog.dom&#39;);
<a name="line142"></a>goog.require(&#39;goog.events&#39;);
<a name="line143"></a>goog.require(&#39;goog.events.Event&#39;);
<a name="line144"></a>goog.require(&#39;goog.events.EventTarget&#39;);
<a name="line145"></a>goog.require(&#39;goog.events.EventType&#39;);
<a name="line146"></a>goog.require(&#39;goog.json&#39;);
<a name="line147"></a>goog.require(&#39;goog.log&#39;);
<a name="line148"></a>goog.require(&#39;goog.net.ErrorCode&#39;);
<a name="line149"></a>goog.require(&#39;goog.net.EventType&#39;);
<a name="line150"></a>goog.require(&#39;goog.reflect&#39;);
<a name="line151"></a>goog.require(&#39;goog.string&#39;);
<a name="line152"></a>goog.require(&#39;goog.structs&#39;);
<a name="line153"></a>goog.require(&#39;goog.userAgent&#39;);
<a name="line154"></a>
<a name="line155"></a>
<a name="line156"></a>
<a name="line157"></a>/**
<a name="line158"></a> * Class for managing requests via iFrames.
<a name="line159"></a> * @constructor
<a name="line160"></a> * @extends {goog.events.EventTarget}
<a name="line161"></a> */
<a name="line162"></a>goog.net.IframeIo = function() {
<a name="line163"></a>  goog.net.IframeIo.base(this, &#39;constructor&#39;);
<a name="line164"></a>
<a name="line165"></a>  /**
<a name="line166"></a>   * Name for this IframeIo and frame
<a name="line167"></a>   * @type {string}
<a name="line168"></a>   * @private
<a name="line169"></a>   */
<a name="line170"></a>  this.name_ = goog.net.IframeIo.getNextName_();
<a name="line171"></a>
<a name="line172"></a>  /**
<a name="line173"></a>   * An array of iframes that have been finished with.  We need them to be
<a name="line174"></a>   * disposed async, so we don&#39;t confuse the browser (see below).
<a name="line175"></a>   * @type {Array.&lt;Element&gt;}
<a name="line176"></a>   * @private
<a name="line177"></a>   */
<a name="line178"></a>  this.iframesForDisposal_ = [];
<a name="line179"></a>
<a name="line180"></a>  // Create a lookup from names to instances of IframeIo.  This is a helper
<a name="line181"></a>  // function to be used in conjunction with goog.net.IframeIo.getInstanceByName
<a name="line182"></a>  // to find the IframeIo object associated with a particular iframe.  Used in
<a name="line183"></a>  // incremental scripts etc.
<a name="line184"></a>  goog.net.IframeIo.instances_[this.name_] = this;
<a name="line185"></a>
<a name="line186"></a>};
<a name="line187"></a>goog.inherits(goog.net.IframeIo, goog.events.EventTarget);
<a name="line188"></a>
<a name="line189"></a>
<a name="line190"></a>/**
<a name="line191"></a> * Object used as a map to lookup instances of IframeIo objects by name.
<a name="line192"></a> * @type {Object}
<a name="line193"></a> * @private
<a name="line194"></a> */
<a name="line195"></a>goog.net.IframeIo.instances_ = {};
<a name="line196"></a>
<a name="line197"></a>
<a name="line198"></a>/**
<a name="line199"></a> * Prefix for frame names
<a name="line200"></a> * @type {string}
<a name="line201"></a> */
<a name="line202"></a>goog.net.IframeIo.FRAME_NAME_PREFIX = &#39;closure_frame&#39;;
<a name="line203"></a>
<a name="line204"></a>
<a name="line205"></a>/**
<a name="line206"></a> * Suffix that is added to inner frames used for sending requests in non-IE
<a name="line207"></a> * browsers
<a name="line208"></a> * @type {string}
<a name="line209"></a> */
<a name="line210"></a>goog.net.IframeIo.INNER_FRAME_SUFFIX = &#39;_inner&#39;;
<a name="line211"></a>
<a name="line212"></a>
<a name="line213"></a>/**
<a name="line214"></a> * The number of milliseconds after a request is completed to dispose the
<a name="line215"></a> * iframes.  This can be done lazily so we wait long enough for any processing
<a name="line216"></a> * that occurred as a result of the response to finish.
<a name="line217"></a> * @type {number}
<a name="line218"></a> */
<a name="line219"></a>goog.net.IframeIo.IFRAME_DISPOSE_DELAY_MS = 2000;
<a name="line220"></a>
<a name="line221"></a>
<a name="line222"></a>/**
<a name="line223"></a> * Counter used when creating iframes
<a name="line224"></a> * @type {number}
<a name="line225"></a> * @private
<a name="line226"></a> */
<a name="line227"></a>goog.net.IframeIo.counter_ = 0;
<a name="line228"></a>
<a name="line229"></a>
<a name="line230"></a>/**
<a name="line231"></a> * Form element to post to.
<a name="line232"></a> * @type {HTMLFormElement}
<a name="line233"></a> * @private
<a name="line234"></a> */
<a name="line235"></a>goog.net.IframeIo.form_;
<a name="line236"></a>
<a name="line237"></a>
<a name="line238"></a>/**
<a name="line239"></a> * Static send that creates a short lived instance of IframeIo to send the
<a name="line240"></a> * request.
<a name="line241"></a> * @param {goog.Uri|string} uri Uri of the request, it is up the caller to
<a name="line242"></a> *     manage query string params.
<a name="line243"></a> * @param {Function=} opt_callback Event handler for when request is completed.
<a name="line244"></a> * @param {string=} opt_method Default is GET, POST uses a form to submit the
<a name="line245"></a> *     request.
<a name="line246"></a> * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
<a name="line247"></a> *     caching.
<a name="line248"></a> * @param {Object|goog.structs.Map=} opt_data Map of key-value pairs that
<a name="line249"></a> *     will be posted to the server via the iframe&#39;s form.
<a name="line250"></a> */
<a name="line251"></a>goog.net.IframeIo.send = function(
<a name="line252"></a>    uri, opt_callback, opt_method, opt_noCache, opt_data) {
<a name="line253"></a>
<a name="line254"></a>  var io = new goog.net.IframeIo();
<a name="line255"></a>  goog.events.listen(io, goog.net.EventType.READY, io.dispose, false, io);
<a name="line256"></a>  if (opt_callback) {
<a name="line257"></a>    goog.events.listen(io, goog.net.EventType.COMPLETE, opt_callback);
<a name="line258"></a>  }
<a name="line259"></a>  io.send(uri, opt_method, opt_noCache, opt_data);
<a name="line260"></a>};
<a name="line261"></a>
<a name="line262"></a>
<a name="line263"></a>/**
<a name="line264"></a> * Find an iframe by name (assumes the context is goog.global since that is
<a name="line265"></a> * where IframeIo&#39;s iframes are kept).
<a name="line266"></a> * @param {string} fname The name to find.
<a name="line267"></a> * @return {HTMLIFrameElement} The iframe element with that name.
<a name="line268"></a> */
<a name="line269"></a>goog.net.IframeIo.getIframeByName = function(fname) {
<a name="line270"></a>  return window.frames[fname];
<a name="line271"></a>};
<a name="line272"></a>
<a name="line273"></a>
<a name="line274"></a>/**
<a name="line275"></a> * Find an instance of the IframeIo object by name.
<a name="line276"></a> * @param {string} fname The name to find.
<a name="line277"></a> * @return {goog.net.IframeIo} The instance of IframeIo.
<a name="line278"></a> */
<a name="line279"></a>goog.net.IframeIo.getInstanceByName = function(fname) {
<a name="line280"></a>  return goog.net.IframeIo.instances_[fname];
<a name="line281"></a>};
<a name="line282"></a>
<a name="line283"></a>
<a name="line284"></a>/**
<a name="line285"></a> * Handles incremental data and routes it to the correct iframeIo instance.
<a name="line286"></a> * The HTML page requested by the IframeIo instance should contain script blocks
<a name="line287"></a> * that call an externed reference to this method.
<a name="line288"></a> * @param {Window} win The window object.
<a name="line289"></a> * @param {Object} data The data object.
<a name="line290"></a> */
<a name="line291"></a>goog.net.IframeIo.handleIncrementalData = function(win, data) {
<a name="line292"></a>  // If this is the inner-frame, then we need to use the parent instead.
<a name="line293"></a>  var iframeName = goog.string.endsWith(win.name,
<a name="line294"></a>      goog.net.IframeIo.INNER_FRAME_SUFFIX) ? win.parent.name : win.name;
<a name="line295"></a>
<a name="line296"></a>  var iframeIoName = iframeName.substring(0, iframeName.lastIndexOf(&#39;_&#39;));
<a name="line297"></a>  var iframeIo = goog.net.IframeIo.getInstanceByName(iframeIoName);
<a name="line298"></a>  if (iframeIo &amp;&amp; iframeName == iframeIo.iframeName_) {
<a name="line299"></a>    iframeIo.handleIncrementalData_(data);
<a name="line300"></a>  } else {
<a name="line301"></a>    var logger = goog.log.getLogger(&#39;goog.net.IframeIo&#39;);
<a name="line302"></a>    goog.log.info(logger,
<a name="line303"></a>        &#39;Incremental iframe data routed for unknown iframe&#39;);
<a name="line304"></a>  }
<a name="line305"></a>};
<a name="line306"></a>
<a name="line307"></a>
<a name="line308"></a>/**
<a name="line309"></a> * @return {string} The next iframe name.
<a name="line310"></a> * @private
<a name="line311"></a> */
<a name="line312"></a>goog.net.IframeIo.getNextName_ = function() {
<a name="line313"></a>  return goog.net.IframeIo.FRAME_NAME_PREFIX + goog.net.IframeIo.counter_++;
<a name="line314"></a>};
<a name="line315"></a>
<a name="line316"></a>
<a name="line317"></a>/**
<a name="line318"></a> * Gets a static form, one for all instances of IframeIo since IE6 leaks form
<a name="line319"></a> * nodes that are created/removed from the document.
<a name="line320"></a> * @return {!HTMLFormElement} The static form.
<a name="line321"></a> * @private
<a name="line322"></a> */
<a name="line323"></a>goog.net.IframeIo.getForm_ = function() {
<a name="line324"></a>  if (!goog.net.IframeIo.form_) {
<a name="line325"></a>    goog.net.IframeIo.form_ =
<a name="line326"></a>        /** @type {HTMLFormElement} */(goog.dom.createDom(&#39;form&#39;));
<a name="line327"></a>    goog.net.IframeIo.form_.acceptCharset = &#39;utf-8&#39;;
<a name="line328"></a>
<a name="line329"></a>    // Hide the form and move it off screen
<a name="line330"></a>    var s = goog.net.IframeIo.form_.style;
<a name="line331"></a>    s.position = &#39;absolute&#39;;
<a name="line332"></a>    s.visibility = &#39;hidden&#39;;
<a name="line333"></a>    s.top = s.left = &#39;-10px&#39;;
<a name="line334"></a>    s.width = s.height = &#39;10px&#39;;
<a name="line335"></a>    s.overflow = &#39;hidden&#39;;
<a name="line336"></a>
<a name="line337"></a>    goog.dom.getDocument().body.appendChild(goog.net.IframeIo.form_);
<a name="line338"></a>  }
<a name="line339"></a>  return goog.net.IframeIo.form_;
<a name="line340"></a>};
<a name="line341"></a>
<a name="line342"></a>
<a name="line343"></a>/**
<a name="line344"></a> * Adds the key value pairs from a map like data structure to a form
<a name="line345"></a> * @param {HTMLFormElement} form The form to add to.
<a name="line346"></a> * @param {Object|goog.structs.Map|goog.Uri.QueryData} data The data to add.
<a name="line347"></a> * @private
<a name="line348"></a> */
<a name="line349"></a>goog.net.IframeIo.addFormInputs_ = function(form, data) {
<a name="line350"></a>  var helper = goog.dom.getDomHelper(form);
<a name="line351"></a>  goog.structs.forEach(data, function(value, key) {
<a name="line352"></a>    var inp = helper.createDom(&#39;input&#39;,
<a name="line353"></a>        {&#39;type&#39;: &#39;hidden&#39;, &#39;name&#39;: key, &#39;value&#39;: value});
<a name="line354"></a>    form.appendChild(inp);
<a name="line355"></a>  });
<a name="line356"></a>};
<a name="line357"></a>
<a name="line358"></a>
<a name="line359"></a>/**
<a name="line360"></a> * @return {boolean} Whether we can use readyState to monitor iframe loading.
<a name="line361"></a> * @private
<a name="line362"></a> */
<a name="line363"></a>goog.net.IframeIo.useIeReadyStateCodePath_ = function() {
<a name="line364"></a>  // ReadyState is only available on iframes up to IE10.
<a name="line365"></a>  return goog.userAgent.IE &amp;&amp; !goog.userAgent.isVersionOrHigher(&#39;11&#39;);
<a name="line366"></a>};
<a name="line367"></a>
<a name="line368"></a>
<a name="line369"></a>/**
<a name="line370"></a> * Reference to a logger for the IframeIo objects
<a name="line371"></a> * @type {goog.log.Logger}
<a name="line372"></a> * @private
<a name="line373"></a> */
<a name="line374"></a>goog.net.IframeIo.prototype.logger_ =
<a name="line375"></a>    goog.log.getLogger(&#39;goog.net.IframeIo&#39;);
<a name="line376"></a>
<a name="line377"></a>
<a name="line378"></a>/**
<a name="line379"></a> * Reference to form element that gets reused for requests to the iframe.
<a name="line380"></a> * @type {HTMLFormElement}
<a name="line381"></a> * @private
<a name="line382"></a> */
<a name="line383"></a>goog.net.IframeIo.prototype.form_ = null;
<a name="line384"></a>
<a name="line385"></a>
<a name="line386"></a>/**
<a name="line387"></a> * Reference to the iframe being used for the current request, or null if no
<a name="line388"></a> * request is currently active.
<a name="line389"></a> * @type {HTMLIFrameElement}
<a name="line390"></a> * @private
<a name="line391"></a> */
<a name="line392"></a>goog.net.IframeIo.prototype.iframe_ = null;
<a name="line393"></a>
<a name="line394"></a>
<a name="line395"></a>/**
<a name="line396"></a> * Name of the iframe being used for the current request, or null if no
<a name="line397"></a> * request is currently active.
<a name="line398"></a> * @type {?string}
<a name="line399"></a> * @private
<a name="line400"></a> */
<a name="line401"></a>goog.net.IframeIo.prototype.iframeName_ = null;
<a name="line402"></a>
<a name="line403"></a>
<a name="line404"></a>/**
<a name="line405"></a> * Next id so that iframe names are unique.
<a name="line406"></a> * @type {number}
<a name="line407"></a> * @private
<a name="line408"></a> */
<a name="line409"></a>goog.net.IframeIo.prototype.nextIframeId_ = 0;
<a name="line410"></a>
<a name="line411"></a>
<a name="line412"></a>/**
<a name="line413"></a> * Whether the object is currently active with a request.
<a name="line414"></a> * @type {boolean}
<a name="line415"></a> * @private
<a name="line416"></a> */
<a name="line417"></a>goog.net.IframeIo.prototype.active_ = false;
<a name="line418"></a>
<a name="line419"></a>
<a name="line420"></a>/**
<a name="line421"></a> * Whether the last request is complete.
<a name="line422"></a> * @type {boolean}
<a name="line423"></a> * @private
<a name="line424"></a> */
<a name="line425"></a>goog.net.IframeIo.prototype.complete_ = false;
<a name="line426"></a>
<a name="line427"></a>
<a name="line428"></a>/**
<a name="line429"></a> * Whether the last request was a success.
<a name="line430"></a> * @type {boolean}
<a name="line431"></a> * @private
<a name="line432"></a> */
<a name="line433"></a>goog.net.IframeIo.prototype.success_ = false;
<a name="line434"></a>
<a name="line435"></a>
<a name="line436"></a>/**
<a name="line437"></a> * The URI for the last request.
<a name="line438"></a> * @type {goog.Uri}
<a name="line439"></a> * @private
<a name="line440"></a> */
<a name="line441"></a>goog.net.IframeIo.prototype.lastUri_ = null;
<a name="line442"></a>
<a name="line443"></a>
<a name="line444"></a>/**
<a name="line445"></a> * The text content of the last request.
<a name="line446"></a> * @type {?string}
<a name="line447"></a> * @private
<a name="line448"></a> */
<a name="line449"></a>goog.net.IframeIo.prototype.lastContent_ = null;
<a name="line450"></a>
<a name="line451"></a>
<a name="line452"></a>/**
<a name="line453"></a> * Last error code
<a name="line454"></a> * @type {goog.net.ErrorCode}
<a name="line455"></a> * @private
<a name="line456"></a> */
<a name="line457"></a>goog.net.IframeIo.prototype.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
<a name="line458"></a>
<a name="line459"></a>
<a name="line460"></a>/**
<a name="line461"></a> * Number of milliseconds after which an incomplete request will be aborted and
<a name="line462"></a> * a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout is set.
<a name="line463"></a> * @type {number}
<a name="line464"></a> * @private
<a name="line465"></a> */
<a name="line466"></a>goog.net.IframeIo.prototype.timeoutInterval_ = 0;
<a name="line467"></a>
<a name="line468"></a>
<a name="line469"></a>/**
<a name="line470"></a> * Window timeout ID used to cancel the timeout event handler if the request
<a name="line471"></a> * completes successfully.
<a name="line472"></a> * @type {?number}
<a name="line473"></a> * @private
<a name="line474"></a> */
<a name="line475"></a>goog.net.IframeIo.prototype.timeoutId_ = null;
<a name="line476"></a>
<a name="line477"></a>
<a name="line478"></a>/**
<a name="line479"></a> * Window timeout ID used to detect when firefox silently fails.
<a name="line480"></a> * @type {?number}
<a name="line481"></a> * @private
<a name="line482"></a> */
<a name="line483"></a>goog.net.IframeIo.prototype.firefoxSilentErrorTimeout_ = null;
<a name="line484"></a>
<a name="line485"></a>
<a name="line486"></a>/**
<a name="line487"></a> * Window timeout ID used by the timer that disposes the iframes.
<a name="line488"></a> * @type {?number}
<a name="line489"></a> * @private
<a name="line490"></a> */
<a name="line491"></a>goog.net.IframeIo.prototype.iframeDisposalTimer_ = null;
<a name="line492"></a>
<a name="line493"></a>
<a name="line494"></a>/**
<a name="line495"></a> * This is used to ensure that we don&#39;t handle errors twice for the same error.
<a name="line496"></a> * We can reach the {@link #handleError_} method twice in IE if the form is
<a name="line497"></a> * submitted while IE is offline and the URL is not available.
<a name="line498"></a> * @type {boolean}
<a name="line499"></a> * @private
<a name="line500"></a> */
<a name="line501"></a>goog.net.IframeIo.prototype.errorHandled_;
<a name="line502"></a>
<a name="line503"></a>
<a name="line504"></a>/**
<a name="line505"></a> * Whether to suppress the listeners that determine when the iframe loads.
<a name="line506"></a> * @type {boolean}
<a name="line507"></a> * @private
<a name="line508"></a> */
<a name="line509"></a>goog.net.IframeIo.prototype.ignoreResponse_ = false;
<a name="line510"></a>
<a name="line511"></a>
<a name="line512"></a>/**
<a name="line513"></a> * Sends a request via an iframe.
<a name="line514"></a> *
<a name="line515"></a> * A HTML form is used and submitted to the iframe, this simplifies the
<a name="line516"></a> * difference between GET and POST requests. The iframe needs to be created and
<a name="line517"></a> * destroyed for each request otherwise the request will contribute to the
<a name="line518"></a> * history stack.
<a name="line519"></a> *
<a name="line520"></a> * sendFromForm does some clever trickery (thanks jlim) in non-IE browsers to
<a name="line521"></a> * stop a history entry being added for POST requests.
<a name="line522"></a> *
<a name="line523"></a> * @param {goog.Uri|string} uri Uri of the request.
<a name="line524"></a> * @param {string=} opt_method Default is GET, POST uses a form to submit the
<a name="line525"></a> *     request.
<a name="line526"></a> * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
<a name="line527"></a> *     caching.
<a name="line528"></a> * @param {Object|goog.structs.Map=} opt_data Map of key-value pairs.
<a name="line529"></a> */
<a name="line530"></a>goog.net.IframeIo.prototype.send = function(
<a name="line531"></a>    uri, opt_method, opt_noCache, opt_data) {
<a name="line532"></a>
<a name="line533"></a>  if (this.active_) {
<a name="line534"></a>    throw Error(&#39;[goog.net.IframeIo] Unable to send, already active.&#39;);
<a name="line535"></a>  }
<a name="line536"></a>
<a name="line537"></a>  var uriObj = new goog.Uri(uri);
<a name="line538"></a>  this.lastUri_ = uriObj;
<a name="line539"></a>  var method = opt_method ? opt_method.toUpperCase() : &#39;GET&#39;;
<a name="line540"></a>
<a name="line541"></a>  if (opt_noCache) {
<a name="line542"></a>    uriObj.makeUnique();
<a name="line543"></a>  }
<a name="line544"></a>
<a name="line545"></a>  goog.log.info(this.logger_,
<a name="line546"></a>      &#39;Sending iframe request: &#39; + uriObj + &#39; [&#39; + method + &#39;]&#39;);
<a name="line547"></a>
<a name="line548"></a>  // Build a form for this request
<a name="line549"></a>  this.form_ = goog.net.IframeIo.getForm_();
<a name="line550"></a>
<a name="line551"></a>  if (method == &#39;GET&#39;) {
<a name="line552"></a>    // For GET requests, we assume that the caller didn&#39;t want the queryparams
<a name="line553"></a>    // already specified in the URI to be clobbered by the form, so we add the
<a name="line554"></a>    // params here.
<a name="line555"></a>    goog.net.IframeIo.addFormInputs_(this.form_, uriObj.getQueryData());
<a name="line556"></a>  }
<a name="line557"></a>
<a name="line558"></a>  if (opt_data) {
<a name="line559"></a>    // Create form fields for each of the data values
<a name="line560"></a>    goog.net.IframeIo.addFormInputs_(this.form_, opt_data);
<a name="line561"></a>  }
<a name="line562"></a>
<a name="line563"></a>  // Set the URI that the form will be posted
<a name="line564"></a>  this.form_.action = uriObj.toString();
<a name="line565"></a>  this.form_.method = method;
<a name="line566"></a>
<a name="line567"></a>  this.sendFormInternal_();
<a name="line568"></a>  this.clearForm_();
<a name="line569"></a>};
<a name="line570"></a>
<a name="line571"></a>
<a name="line572"></a>/**
<a name="line573"></a> * Sends the data stored in an existing form to the server. The HTTP method
<a name="line574"></a> * should be specified on the form, the action can also be specified but can
<a name="line575"></a> * be overridden by the optional URI param.
<a name="line576"></a> *
<a name="line577"></a> * This can be used in conjunction will a file-upload input to upload a file in
<a name="line578"></a> * the background without affecting history.
<a name="line579"></a> *
<a name="line580"></a> * Example form:
<a name="line581"></a> * &lt;pre&gt;
<a name="line582"></a> *   &amp;lt;form action=&quot;/server/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
<a name="line583"></a> *     &amp;lt;input name=&quot;userfile&quot; type=&quot;file&quot;&amp;gt;
<a name="line584"></a> *   &amp;lt;/form&amp;gt;
<a name="line585"></a> * &lt;/pre&gt;
<a name="line586"></a> *
<a name="line587"></a> * @param {HTMLFormElement} form Form element used to send the request to the
<a name="line588"></a> *     server.
<a name="line589"></a> * @param {string=} opt_uri Uri to set for the destination of the request, by
<a name="line590"></a> *     default the uri will come from the form.
<a name="line591"></a> * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
<a name="line592"></a> *     caching.
<a name="line593"></a> */
<a name="line594"></a>goog.net.IframeIo.prototype.sendFromForm = function(form, opt_uri,
<a name="line595"></a>    opt_noCache) {
<a name="line596"></a>  if (this.active_) {
<a name="line597"></a>    throw Error(&#39;[goog.net.IframeIo] Unable to send, already active.&#39;);
<a name="line598"></a>  }
<a name="line599"></a>
<a name="line600"></a>  var uri = new goog.Uri(opt_uri || form.action);
<a name="line601"></a>  if (opt_noCache) {
<a name="line602"></a>    uri.makeUnique();
<a name="line603"></a>  }
<a name="line604"></a>
<a name="line605"></a>  goog.log.info(this.logger_, &#39;Sending iframe request from form: &#39; + uri);
<a name="line606"></a>
<a name="line607"></a>  this.lastUri_ = uri;
<a name="line608"></a>  this.form_ = form;
<a name="line609"></a>  this.form_.action = uri.toString();
<a name="line610"></a>  this.sendFormInternal_();
<a name="line611"></a>};
<a name="line612"></a>
<a name="line613"></a>
<a name="line614"></a>/**
<a name="line615"></a> * Abort the current Iframe request
<a name="line616"></a> * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -
<a name="line617"></a> *     defaults to ABORT.
<a name="line618"></a> */
<a name="line619"></a>goog.net.IframeIo.prototype.abort = function(opt_failureCode) {
<a name="line620"></a>  if (this.active_) {
<a name="line621"></a>    goog.log.info(this.logger_, &#39;Request aborted&#39;);
<a name="line622"></a>    goog.events.removeAll(this.getRequestIframe());
<a name="line623"></a>    this.complete_ = false;
<a name="line624"></a>    this.active_ = false;
<a name="line625"></a>    this.success_ = false;
<a name="line626"></a>    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;
<a name="line627"></a>
<a name="line628"></a>    this.dispatchEvent(goog.net.EventType.ABORT);
<a name="line629"></a>
<a name="line630"></a>    this.makeReady_();
<a name="line631"></a>  }
<a name="line632"></a>};
<a name="line633"></a>
<a name="line634"></a>
<a name="line635"></a>/** @override */
<a name="line636"></a>goog.net.IframeIo.prototype.disposeInternal = function() {
<a name="line637"></a>  goog.log.fine(this.logger_, &#39;Disposing iframeIo instance&#39;);
<a name="line638"></a>
<a name="line639"></a>  // If there is an active request, abort it
<a name="line640"></a>  if (this.active_) {
<a name="line641"></a>    goog.log.fine(this.logger_, &#39;Aborting active request&#39;);
<a name="line642"></a>    this.abort();
<a name="line643"></a>  }
<a name="line644"></a>
<a name="line645"></a>  // Call super-classes implementation (remove listeners)
<a name="line646"></a>  goog.net.IframeIo.superClass_.disposeInternal.call(this);
<a name="line647"></a>
<a name="line648"></a>  // Add the current iframe to the list of iframes for disposal.
<a name="line649"></a>  if (this.iframe_) {
<a name="line650"></a>    this.scheduleIframeDisposal_();
<a name="line651"></a>  }
<a name="line652"></a>
<a name="line653"></a>  // Disposes of the form
<a name="line654"></a>  this.disposeForm_();
<a name="line655"></a>
<a name="line656"></a>  // Nullify anything that might cause problems and clear state
<a name="line657"></a>  delete this.errorChecker_;
<a name="line658"></a>  this.form_ = null;
<a name="line659"></a>  this.lastCustomError_ = this.lastContent_ = this.lastContentHtml_ = null;
<a name="line660"></a>  this.lastUri_ = null;
<a name="line661"></a>  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
<a name="line662"></a>
<a name="line663"></a>  delete goog.net.IframeIo.instances_[this.name_];
<a name="line664"></a>};
<a name="line665"></a>
<a name="line666"></a>
<a name="line667"></a>/**
<a name="line668"></a> * @return {boolean} True if transfer is complete.
<a name="line669"></a> */
<a name="line670"></a>goog.net.IframeIo.prototype.isComplete = function() {
<a name="line671"></a>  return this.complete_;
<a name="line672"></a>};
<a name="line673"></a>
<a name="line674"></a>
<a name="line675"></a>/**
<a name="line676"></a> * @return {boolean} True if transfer was successful.
<a name="line677"></a> */
<a name="line678"></a>goog.net.IframeIo.prototype.isSuccess = function() {
<a name="line679"></a>  return this.success_;
<a name="line680"></a>};
<a name="line681"></a>
<a name="line682"></a>
<a name="line683"></a>/**
<a name="line684"></a> * @return {boolean} True if a transfer is in progress.
<a name="line685"></a> */
<a name="line686"></a>goog.net.IframeIo.prototype.isActive = function() {
<a name="line687"></a>  return this.active_;
<a name="line688"></a>};
<a name="line689"></a>
<a name="line690"></a>
<a name="line691"></a>/**
<a name="line692"></a> * Returns the last response text (i.e. the text content of the iframe).
<a name="line693"></a> * Assumes plain text!
<a name="line694"></a> * @return {?string} Result from the server.
<a name="line695"></a> */
<a name="line696"></a>goog.net.IframeIo.prototype.getResponseText = function() {
<a name="line697"></a>  return this.lastContent_;
<a name="line698"></a>};
<a name="line699"></a>
<a name="line700"></a>
<a name="line701"></a>/**
<a name="line702"></a> * Returns the last response html (i.e. the innerHtml of the iframe).
<a name="line703"></a> * @return {?string} Result from the server.
<a name="line704"></a> */
<a name="line705"></a>goog.net.IframeIo.prototype.getResponseHtml = function() {
<a name="line706"></a>  return this.lastContentHtml_;
<a name="line707"></a>};
<a name="line708"></a>
<a name="line709"></a>
<a name="line710"></a>/**
<a name="line711"></a> * Parses the content as JSON. This is a safe parse and may throw an error
<a name="line712"></a> * if the response is malformed.
<a name="line713"></a> * Use goog.json.unsafeparse(this.getResponseText()) if you are sure of the
<a name="line714"></a> * state of the returned content.
<a name="line715"></a> * @return {Object} The parsed content.
<a name="line716"></a> */
<a name="line717"></a>goog.net.IframeIo.prototype.getResponseJson = function() {
<a name="line718"></a>  return goog.json.parse(this.lastContent_);
<a name="line719"></a>};
<a name="line720"></a>
<a name="line721"></a>
<a name="line722"></a>/**
<a name="line723"></a> * Returns the document object from the last request.  Not truely XML, but
<a name="line724"></a> * used to mirror the XhrIo interface.
<a name="line725"></a> * @return {HTMLDocument} The document object from the last request.
<a name="line726"></a> */
<a name="line727"></a>goog.net.IframeIo.prototype.getResponseXml = function() {
<a name="line728"></a>  if (!this.iframe_) return null;
<a name="line729"></a>
<a name="line730"></a>  return this.getContentDocument_();
<a name="line731"></a>};
<a name="line732"></a>
<a name="line733"></a>
<a name="line734"></a>/**
<a name="line735"></a> * Get the uri of the last request.
<a name="line736"></a> * @return {goog.Uri} Uri of last request.
<a name="line737"></a> */
<a name="line738"></a>goog.net.IframeIo.prototype.getLastUri = function() {
<a name="line739"></a>  return this.lastUri_;
<a name="line740"></a>};
<a name="line741"></a>
<a name="line742"></a>
<a name="line743"></a>/**
<a name="line744"></a> * Gets the last error code.
<a name="line745"></a> * @return {goog.net.ErrorCode} Last error code.
<a name="line746"></a> */
<a name="line747"></a>goog.net.IframeIo.prototype.getLastErrorCode = function() {
<a name="line748"></a>  return this.lastErrorCode_;
<a name="line749"></a>};
<a name="line750"></a>
<a name="line751"></a>
<a name="line752"></a>/**
<a name="line753"></a> * Gets the last error message.
<a name="line754"></a> * @return {string} Last error message.
<a name="line755"></a> */
<a name="line756"></a>goog.net.IframeIo.prototype.getLastError = function() {
<a name="line757"></a>  return goog.net.ErrorCode.getDebugMessage(this.lastErrorCode_);
<a name="line758"></a>};
<a name="line759"></a>
<a name="line760"></a>
<a name="line761"></a>/**
<a name="line762"></a> * Gets the last custom error.
<a name="line763"></a> * @return {Object} Last custom error.
<a name="line764"></a> */
<a name="line765"></a>goog.net.IframeIo.prototype.getLastCustomError = function() {
<a name="line766"></a>  return this.lastCustomError_;
<a name="line767"></a>};
<a name="line768"></a>
<a name="line769"></a>
<a name="line770"></a>/**
<a name="line771"></a> * Sets the callback function used to check if a loaded IFrame is in an error
<a name="line772"></a> * state.
<a name="line773"></a> * @param {Function} fn Callback that expects a document object as it&#39;s single
<a name="line774"></a> *     argument.
<a name="line775"></a> */
<a name="line776"></a>goog.net.IframeIo.prototype.setErrorChecker = function(fn) {
<a name="line777"></a>  this.errorChecker_ = fn;
<a name="line778"></a>};
<a name="line779"></a>
<a name="line780"></a>
<a name="line781"></a>/**
<a name="line782"></a> * Gets the callback function used to check if a loaded IFrame is in an error
<a name="line783"></a> * state.
<a name="line784"></a> * @return {Function} A callback that expects a document object as it&#39;s single
<a name="line785"></a> *     argument.
<a name="line786"></a> */
<a name="line787"></a>goog.net.IframeIo.prototype.getErrorChecker = function() {
<a name="line788"></a>  return this.errorChecker_;
<a name="line789"></a>};
<a name="line790"></a>
<a name="line791"></a>
<a name="line792"></a>/**
<a name="line793"></a> * Returns the number of milliseconds after which an incomplete request will be
<a name="line794"></a> * aborted, or 0 if no timeout is set.
<a name="line795"></a> * @return {number} Timeout interval in milliseconds.
<a name="line796"></a> */
<a name="line797"></a>goog.net.IframeIo.prototype.getTimeoutInterval = function() {
<a name="line798"></a>  return this.timeoutInterval_;
<a name="line799"></a>};
<a name="line800"></a>
<a name="line801"></a>
<a name="line802"></a>/**
<a name="line803"></a> * Sets the number of milliseconds after which an incomplete request will be
<a name="line804"></a> * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no
<a name="line805"></a> * timeout is set.
<a name="line806"></a> * @param {number} ms Timeout interval in milliseconds; 0 means none.
<a name="line807"></a> */
<a name="line808"></a>goog.net.IframeIo.prototype.setTimeoutInterval = function(ms) {
<a name="line809"></a>  // TODO (pupius) - never used - doesn&#39;t look like timeouts were implemented
<a name="line810"></a>  this.timeoutInterval_ = Math.max(0, ms);
<a name="line811"></a>};
<a name="line812"></a>
<a name="line813"></a>
<a name="line814"></a>/**
<a name="line815"></a> * @return {boolean} Whether the server response is being ignored.
<a name="line816"></a> */
<a name="line817"></a>goog.net.IframeIo.prototype.isIgnoringResponse = function() {
<a name="line818"></a>  return this.ignoreResponse_;
<a name="line819"></a>};
<a name="line820"></a>
<a name="line821"></a>
<a name="line822"></a>/**
<a name="line823"></a> * Sets whether to ignore the response from the server by not adding any event
<a name="line824"></a> * handlers to fire when the iframe loads. This is necessary when using IframeIo
<a name="line825"></a> * to submit to a server on another domain, to avoid same-origin violations when
<a name="line826"></a> * trying to access the response. If this is set to true, the IframeIo instance
<a name="line827"></a> * will be a single-use instance that is only usable for one request.  It will
<a name="line828"></a> * only clean up its resources (iframes and forms) when it is disposed.
<a name="line829"></a> * @param {boolean} ignore Whether to ignore the server response.
<a name="line830"></a> */
<a name="line831"></a>goog.net.IframeIo.prototype.setIgnoreResponse = function(ignore) {
<a name="line832"></a>  this.ignoreResponse_ = ignore;
<a name="line833"></a>};
<a name="line834"></a>
<a name="line835"></a>
<a name="line836"></a>/**
<a name="line837"></a> * Submits the internal form to the iframe.
<a name="line838"></a> * @private
<a name="line839"></a> */
<a name="line840"></a>goog.net.IframeIo.prototype.sendFormInternal_ = function() {
<a name="line841"></a>  this.active_ = true;
<a name="line842"></a>  this.complete_ = false;
<a name="line843"></a>  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
<a name="line844"></a>
<a name="line845"></a>  // Make Iframe
<a name="line846"></a>  this.createIframe_();
<a name="line847"></a>
<a name="line848"></a>  if (goog.net.IframeIo.useIeReadyStateCodePath_()) {
<a name="line849"></a>    // In IE&lt;11 we simply create the frame, wait until it is ready, then post
<a name="line850"></a>    // the form to the iframe and wait for the readystate to change to
<a name="line851"></a>    // &#39;complete&#39;
<a name="line852"></a>
<a name="line853"></a>    // Set the target to the iframe&#39;s name
<a name="line854"></a>    this.form_.target = this.iframeName_ || &#39;&#39;;
<a name="line855"></a>    this.appendIframe_();
<a name="line856"></a>    if (!this.ignoreResponse_) {
<a name="line857"></a>      goog.events.listen(this.iframe_, goog.events.EventType.READYSTATECHANGE,
<a name="line858"></a>          this.onIeReadyStateChange_, false, this);
<a name="line859"></a>    }
<a name="line860"></a>
<a name="line861"></a>    /** @preserveTry */
<a name="line862"></a>    try {
<a name="line863"></a>      this.errorHandled_ = false;
<a name="line864"></a>      this.form_.submit();
<a name="line865"></a>    } catch (e) {
<a name="line866"></a>      // If submit threw an exception then it probably means the page that the
<a name="line867"></a>      // code is running on the local file system and the form&#39;s action was
<a name="line868"></a>      // pointing to a file that doesn&#39;t exist, causing the browser to fire an
<a name="line869"></a>      // exception.  IE also throws an exception when it is working offline and
<a name="line870"></a>      // the URL is not available.
<a name="line871"></a>
<a name="line872"></a>      if (!this.ignoreResponse_) {
<a name="line873"></a>        goog.events.unlisten(
<a name="line874"></a>            this.iframe_,
<a name="line875"></a>            goog.events.EventType.READYSTATECHANGE,
<a name="line876"></a>            this.onIeReadyStateChange_,
<a name="line877"></a>            false,
<a name="line878"></a>            this);
<a name="line879"></a>      }
<a name="line880"></a>
<a name="line881"></a>      this.handleError_(goog.net.ErrorCode.ACCESS_DENIED);
<a name="line882"></a>    }
<a name="line883"></a>
<a name="line884"></a>  } else {
<a name="line885"></a>    // For all other browsers we do some trickery to ensure that there is no
<a name="line886"></a>    // entry on the history stack. Thanks go to jlim for the prototype for this
<a name="line887"></a>
<a name="line888"></a>    goog.log.fine(this.logger_, &#39;Setting up iframes and cloning form&#39;);
<a name="line889"></a>
<a name="line890"></a>    this.appendIframe_();
<a name="line891"></a>
<a name="line892"></a>    var innerFrameName = this.iframeName_ +
<a name="line893"></a>                         goog.net.IframeIo.INNER_FRAME_SUFFIX;
<a name="line894"></a>
<a name="line895"></a>    // Open and document.write another iframe into the iframe
<a name="line896"></a>    var doc = goog.dom.getFrameContentDocument(this.iframe_);
<a name="line897"></a>    var html = &#39;&lt;body&gt;&lt;iframe id=&#39; + innerFrameName +
<a name="line898"></a>               &#39; name=&#39; + innerFrameName + &#39;&gt;&lt;/iframe&gt;&#39;;
<a name="line899"></a>    if (document.baseURI) {
<a name="line900"></a>      // On Safari 4 and 5 the new iframe doesn&#39;t inherit the current baseURI.
<a name="line901"></a>      html = &#39;&lt;head&gt;&lt;base href=&quot;&#39; + goog.string.htmlEscape(document.baseURI) +
<a name="line902"></a>             &#39;&quot;&gt;&lt;/head&gt;&#39; + html;
<a name="line903"></a>    }
<a name="line904"></a>    if (goog.userAgent.OPERA) {
<a name="line905"></a>      // Opera adds a history entry when document.write is used.
<a name="line906"></a>      // Change the innerHTML of the page instead.
<a name="line907"></a>      doc.documentElement.innerHTML = html;
<a name="line908"></a>    } else {
<a name="line909"></a>      doc.write(html);
<a name="line910"></a>    }
<a name="line911"></a>
<a name="line912"></a>    // Listen for the iframe&#39;s load
<a name="line913"></a>    if (!this.ignoreResponse_) {
<a name="line914"></a>      goog.events.listen(doc.getElementById(innerFrameName),
<a name="line915"></a>          goog.events.EventType.LOAD, this.onIframeLoaded_, false, this);
<a name="line916"></a>    }
<a name="line917"></a>
<a name="line918"></a>    // Fix text areas, since importNode won&#39;t clone changes to the value
<a name="line919"></a>    var textareas = this.form_.getElementsByTagName(&#39;textarea&#39;);
<a name="line920"></a>    for (var i = 0, n = textareas.length; i &lt; n; i++) {
<a name="line921"></a>      // The childnodes represent the initial child nodes for the text area
<a name="line922"></a>      // appending a text node essentially resets the initial value ready for
<a name="line923"></a>      // it to be clones - while maintaining HTML escaping.
<a name="line924"></a>      var value = textareas[i].value;
<a name="line925"></a>      if (goog.dom.getRawTextContent(textareas[i]) != value) {
<a name="line926"></a>        goog.dom.setTextContent(textareas[i], value);
<a name="line927"></a>        textareas[i].value = value;
<a name="line928"></a>      }
<a name="line929"></a>    }
<a name="line930"></a>
<a name="line931"></a>    // Append a cloned form to the iframe
<a name="line932"></a>    var clone = doc.importNode(this.form_, true);
<a name="line933"></a>    clone.target = innerFrameName;
<a name="line934"></a>    // Work around crbug.com/66987
<a name="line935"></a>    clone.action = this.form_.action;
<a name="line936"></a>    doc.body.appendChild(clone);
<a name="line937"></a>
<a name="line938"></a>    // Fix select boxes, importNode won&#39;t override the default value
<a name="line939"></a>    var selects = this.form_.getElementsByTagName(&#39;select&#39;);
<a name="line940"></a>    var clones = clone.getElementsByTagName(&#39;select&#39;);
<a name="line941"></a>    for (var i = 0, n = selects.length; i &lt; n; i++) {
<a name="line942"></a>      var selectsOptions = selects[i].getElementsByTagName(&#39;option&#39;);
<a name="line943"></a>      var clonesOptions = clones[i].getElementsByTagName(&#39;option&#39;);
<a name="line944"></a>      for (var j = 0, m = selectsOptions.length; j &lt; m; j++) {
<a name="line945"></a>        clonesOptions[j].selected = selectsOptions[j].selected;
<a name="line946"></a>      }
<a name="line947"></a>    }
<a name="line948"></a>
<a name="line949"></a>    // IE and some versions of Firefox (1.5 - 1.5.07?) fail to clone the value
<a name="line950"></a>    // attribute for &lt;input type=&quot;file&quot;&gt; nodes, which results in an empty
<a name="line951"></a>    // upload if the clone is submitted.  Check, and if the clone failed, submit
<a name="line952"></a>    // using the original form instead.
<a name="line953"></a>    var inputs = this.form_.getElementsByTagName(&#39;input&#39;);
<a name="line954"></a>    var inputClones = clone.getElementsByTagName(&#39;input&#39;);
<a name="line955"></a>    for (var i = 0, n = inputs.length; i &lt; n; i++) {
<a name="line956"></a>      if (inputs[i].type == &#39;file&#39;) {
<a name="line957"></a>        if (inputs[i].value != inputClones[i].value) {
<a name="line958"></a>          goog.log.fine(this.logger_,
<a name="line959"></a>              &#39;File input value not cloned properly.  Will &#39; +
<a name="line960"></a>              &#39;submit using original form.&#39;);
<a name="line961"></a>          this.form_.target = innerFrameName;
<a name="line962"></a>          clone = this.form_;
<a name="line963"></a>          break;
<a name="line964"></a>        }
<a name="line965"></a>      }
<a name="line966"></a>    }
<a name="line967"></a>
<a name="line968"></a>    goog.log.fine(this.logger_, &#39;Submitting form&#39;);
<a name="line969"></a>
<a name="line970"></a>    /** @preserveTry */
<a name="line971"></a>    try {
<a name="line972"></a>      this.errorHandled_ = false;
<a name="line973"></a>      clone.submit();
<a name="line974"></a>      doc.close();
<a name="line975"></a>
<a name="line976"></a>      if (goog.userAgent.GECKO) {
<a name="line977"></a>        // This tests if firefox silently fails, this can happen, for example,
<a name="line978"></a>        // when the server resets the connection because of a large file upload
<a name="line979"></a>        this.firefoxSilentErrorTimeout_ =
<a name="line980"></a>            goog.Timer.callOnce(this.testForFirefoxSilentError_, 250, this);
<a name="line981"></a>      }
<a name="line982"></a>
<a name="line983"></a>    } catch (e) {
<a name="line984"></a>      // If submit threw an exception then it probably means the page that the
<a name="line985"></a>      // code is running on the local file system and the form&#39;s action was
<a name="line986"></a>      // pointing to a file that doesn&#39;t exist, causing the browser to fire an
<a name="line987"></a>      // exception.
<a name="line988"></a>
<a name="line989"></a>      goog.log.error(this.logger_,
<a name="line990"></a>          &#39;Error when submitting form: &#39; + goog.debug.exposeException(e));
<a name="line991"></a>
<a name="line992"></a>      if (!this.ignoreResponse_) {
<a name="line993"></a>        goog.events.unlisten(doc.getElementById(innerFrameName),
<a name="line994"></a>            goog.events.EventType.LOAD, this.onIframeLoaded_, false, this);
<a name="line995"></a>      }
<a name="line996"></a>
<a name="line997"></a>      doc.close();
<a name="line998"></a>
<a name="line999"></a>      this.handleError_(goog.net.ErrorCode.FILE_NOT_FOUND);
<a name="line1000"></a>    }
<a name="line1001"></a>  }
<a name="line1002"></a>};
<a name="line1003"></a>
<a name="line1004"></a>
<a name="line1005"></a>/**
<a name="line1006"></a> * Handles the load event of the iframe for IE, determines if the request was
<a name="line1007"></a> * successful or not, handles clean up and dispatching of appropriate events.
<a name="line1008"></a> * @param {goog.events.BrowserEvent} e The browser event.
<a name="line1009"></a> * @private
<a name="line1010"></a> */
<a name="line1011"></a>goog.net.IframeIo.prototype.onIeReadyStateChange_ = function(e) {
<a name="line1012"></a>  if (this.iframe_.readyState == &#39;complete&#39;) {
<a name="line1013"></a>    goog.events.unlisten(this.iframe_, goog.events.EventType.READYSTATECHANGE,
<a name="line1014"></a>        this.onIeReadyStateChange_, false, this);
<a name="line1015"></a>    var doc;
<a name="line1016"></a>    /** @preserveTry */
<a name="line1017"></a>    try {
<a name="line1018"></a>      doc = goog.dom.getFrameContentDocument(this.iframe_);
<a name="line1019"></a>
<a name="line1020"></a>      // IE serves about:blank when it cannot load the resource while offline.
<a name="line1021"></a>      if (goog.userAgent.IE &amp;&amp; doc.location == &#39;about:blank&#39; &amp;&amp;
<a name="line1022"></a>          !navigator.onLine) {
<a name="line1023"></a>        this.handleError_(goog.net.ErrorCode.OFFLINE);
<a name="line1024"></a>        return;
<a name="line1025"></a>      }
<a name="line1026"></a>    } catch (ex) {
<a name="line1027"></a>      this.handleError_(goog.net.ErrorCode.ACCESS_DENIED);
<a name="line1028"></a>      return;
<a name="line1029"></a>    }
<a name="line1030"></a>    this.handleLoad_(/** @type {HTMLDocument} */(doc));
<a name="line1031"></a>  }
<a name="line1032"></a>};
<a name="line1033"></a>
<a name="line1034"></a>
<a name="line1035"></a>/**
<a name="line1036"></a> * Handles the load event of the iframe for non-IE browsers.
<a name="line1037"></a> * @param {goog.events.BrowserEvent} e The browser event.
<a name="line1038"></a> * @private
<a name="line1039"></a> */
<a name="line1040"></a>goog.net.IframeIo.prototype.onIframeLoaded_ = function(e) {
<a name="line1041"></a>  // In Opera, the default &quot;about:blank&quot; page of iframes fires an onload
<a name="line1042"></a>  // event that we&#39;d like to ignore.
<a name="line1043"></a>  if (goog.userAgent.OPERA &amp;&amp;
<a name="line1044"></a>      this.getContentDocument_().location == &#39;about:blank&#39;) {
<a name="line1045"></a>    return;
<a name="line1046"></a>  }
<a name="line1047"></a>  goog.events.unlisten(this.getRequestIframe(),
<a name="line1048"></a>      goog.events.EventType.LOAD, this.onIframeLoaded_, false, this);
<a name="line1049"></a>  try {
<a name="line1050"></a>    this.handleLoad_(this.getContentDocument_());
<a name="line1051"></a>  } catch (ex) {
<a name="line1052"></a>    this.handleError_(goog.net.ErrorCode.ACCESS_DENIED);
<a name="line1053"></a>  }
<a name="line1054"></a>};
<a name="line1055"></a>
<a name="line1056"></a>
<a name="line1057"></a>/**
<a name="line1058"></a> * Handles generic post-load
<a name="line1059"></a> * @param {HTMLDocument} contentDocument The frame&#39;s document.
<a name="line1060"></a> * @private
<a name="line1061"></a> */
<a name="line1062"></a>goog.net.IframeIo.prototype.handleLoad_ = function(contentDocument) {
<a name="line1063"></a>  goog.log.fine(this.logger_, &#39;Iframe loaded&#39;);
<a name="line1064"></a>
<a name="line1065"></a>  this.complete_ = true;
<a name="line1066"></a>  this.active_ = false;
<a name="line1067"></a>
<a name="line1068"></a>  var errorCode;
<a name="line1069"></a>
<a name="line1070"></a>  // Try to get the innerHTML.  If this fails then it can be an access denied
<a name="line1071"></a>  // error or the document may just not have a body, typical case is if there
<a name="line1072"></a>  // is an IE&#39;s default 404.
<a name="line1073"></a>  /** @preserveTry */
<a name="line1074"></a>  try {
<a name="line1075"></a>    var body = contentDocument.body;
<a name="line1076"></a>    this.lastContent_ = body.textContent || body.innerText;
<a name="line1077"></a>    this.lastContentHtml_ = body.innerHTML;
<a name="line1078"></a>  } catch (ex) {
<a name="line1079"></a>    errorCode = goog.net.ErrorCode.ACCESS_DENIED;
<a name="line1080"></a>  }
<a name="line1081"></a>
<a name="line1082"></a>  // Use a callback function, defined by the application, to analyse the
<a name="line1083"></a>  // contentDocument and determine if it is an error page.  Applications
<a name="line1084"></a>  // may send down markers in the document, define JS vars, or some other test.
<a name="line1085"></a>  var customError;
<a name="line1086"></a>  if (!errorCode &amp;&amp; typeof this.errorChecker_ == &#39;function&#39;) {
<a name="line1087"></a>    customError = this.errorChecker_(contentDocument);
<a name="line1088"></a>    if (customError) {
<a name="line1089"></a>      errorCode = goog.net.ErrorCode.CUSTOM_ERROR;
<a name="line1090"></a>    }
<a name="line1091"></a>  }
<a name="line1092"></a>
<a name="line1093"></a>  goog.log.log(this.logger_, goog.log.Level.FINER,
<a name="line1094"></a>      &#39;Last content: &#39; + this.lastContent_);
<a name="line1095"></a>  goog.log.log(this.logger_, goog.log.Level.FINER,
<a name="line1096"></a>      &#39;Last uri: &#39; + this.lastUri_);
<a name="line1097"></a>
<a name="line1098"></a>  if (errorCode) {
<a name="line1099"></a>    goog.log.fine(this.logger_, &#39;Load event occurred but failed&#39;);
<a name="line1100"></a>    this.handleError_(errorCode, customError);
<a name="line1101"></a>
<a name="line1102"></a>  } else {
<a name="line1103"></a>    goog.log.fine(this.logger_, &#39;Load succeeded&#39;);
<a name="line1104"></a>    this.success_ = true;
<a name="line1105"></a>    this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
<a name="line1106"></a>    this.dispatchEvent(goog.net.EventType.COMPLETE);
<a name="line1107"></a>    this.dispatchEvent(goog.net.EventType.SUCCESS);
<a name="line1108"></a>
<a name="line1109"></a>    this.makeReady_();
<a name="line1110"></a>  }
<a name="line1111"></a>};
<a name="line1112"></a>
<a name="line1113"></a>
<a name="line1114"></a>/**
<a name="line1115"></a> * Handles errors.
<a name="line1116"></a> * @param {goog.net.ErrorCode} errorCode Error code.
<a name="line1117"></a> * @param {Object=} opt_customError If error is CUSTOM_ERROR, this is the
<a name="line1118"></a> *     client-provided custom error.
<a name="line1119"></a> * @private
<a name="line1120"></a> */
<a name="line1121"></a>goog.net.IframeIo.prototype.handleError_ = function(errorCode,
<a name="line1122"></a>                                                    opt_customError) {
<a name="line1123"></a>  if (!this.errorHandled_) {
<a name="line1124"></a>    this.success_ = false;
<a name="line1125"></a>    this.active_ = false;
<a name="line1126"></a>    this.complete_ = true;
<a name="line1127"></a>    this.lastErrorCode_ = errorCode;
<a name="line1128"></a>    if (errorCode == goog.net.ErrorCode.CUSTOM_ERROR) {
<a name="line1129"></a>      this.lastCustomError_ = opt_customError;
<a name="line1130"></a>    }
<a name="line1131"></a>    this.dispatchEvent(goog.net.EventType.COMPLETE);
<a name="line1132"></a>    this.dispatchEvent(goog.net.EventType.ERROR);
<a name="line1133"></a>
<a name="line1134"></a>    this.makeReady_();
<a name="line1135"></a>
<a name="line1136"></a>    this.errorHandled_ = true;
<a name="line1137"></a>  }
<a name="line1138"></a>};
<a name="line1139"></a>
<a name="line1140"></a>
<a name="line1141"></a>/**
<a name="line1142"></a> * Dispatches an event indicating that the IframeIo instance has received a data
<a name="line1143"></a> * packet via incremental loading.  The event object has a &#39;data&#39; member.
<a name="line1144"></a> * @param {Object} data Data.
<a name="line1145"></a> * @private
<a name="line1146"></a> */
<a name="line1147"></a>goog.net.IframeIo.prototype.handleIncrementalData_ = function(data) {
<a name="line1148"></a>  this.dispatchEvent(new goog.net.IframeIo.IncrementalDataEvent(data));
<a name="line1149"></a>};
<a name="line1150"></a>
<a name="line1151"></a>
<a name="line1152"></a>/**
<a name="line1153"></a> * Finalizes the request, schedules the iframe for disposal, and maybe disposes
<a name="line1154"></a> * the form.
<a name="line1155"></a> * @private
<a name="line1156"></a> */
<a name="line1157"></a>goog.net.IframeIo.prototype.makeReady_ = function() {
<a name="line1158"></a>  goog.log.info(this.logger_, &#39;Ready for new requests&#39;);
<a name="line1159"></a>  var iframe = this.iframe_;
<a name="line1160"></a>  this.scheduleIframeDisposal_();
<a name="line1161"></a>  this.disposeForm_();
<a name="line1162"></a>  this.dispatchEvent(goog.net.EventType.READY);
<a name="line1163"></a>};
<a name="line1164"></a>
<a name="line1165"></a>
<a name="line1166"></a>/**
<a name="line1167"></a> * Creates an iframe to be used with a request.  We use a new iframe for each
<a name="line1168"></a> * request so that requests don&#39;t create history entries.
<a name="line1169"></a> * @private
<a name="line1170"></a> */
<a name="line1171"></a>goog.net.IframeIo.prototype.createIframe_ = function() {
<a name="line1172"></a>  goog.log.fine(this.logger_, &#39;Creating iframe&#39;);
<a name="line1173"></a>
<a name="line1174"></a>  this.iframeName_ = this.name_ + &#39;_&#39; + (this.nextIframeId_++).toString(36);
<a name="line1175"></a>
<a name="line1176"></a>  var iframeAttributes = {&#39;name&#39;: this.iframeName_, &#39;id&#39;: this.iframeName_};
<a name="line1177"></a>  // Setting the source to javascript:&quot;&quot; is a fix to remove IE6 mixed content
<a name="line1178"></a>  // warnings when being used in an https page.
<a name="line1179"></a>  if (goog.userAgent.IE &amp;&amp; goog.userAgent.VERSION &lt; 7) {
<a name="line1180"></a>    iframeAttributes.src = &#39;javascript:&quot;&quot;&#39;;
<a name="line1181"></a>  }
<a name="line1182"></a>
<a name="line1183"></a>  this.iframe_ = /** @type {HTMLIFrameElement} */(
<a name="line1184"></a>      goog.dom.getDomHelper(this.form_).createDom(&#39;iframe&#39;, iframeAttributes));
<a name="line1185"></a>
<a name="line1186"></a>  var s = this.iframe_.style;
<a name="line1187"></a>  s.visibility = &#39;hidden&#39;;
<a name="line1188"></a>  s.width = s.height = &#39;10px&#39;;
<a name="line1189"></a>  // Chrome sometimes shows scrollbars when visibility is hidden, but not when
<a name="line1190"></a>  // display is none.
<a name="line1191"></a>  s.display = &#39;none&#39;;
<a name="line1192"></a>
<a name="line1193"></a>  // There are reports that safari 2.0.3 has a bug where absolutely positioned
<a name="line1194"></a>  // iframes can&#39;t have their src set.
<a name="line1195"></a>  if (!goog.userAgent.WEBKIT) {
<a name="line1196"></a>    s.position = &#39;absolute&#39;;
<a name="line1197"></a>    s.top = s.left = &#39;-10px&#39;;
<a name="line1198"></a>  } else {
<a name="line1199"></a>    s.marginTop = s.marginLeft = &#39;-10px&#39;;
<a name="line1200"></a>  }
<a name="line1201"></a>};
<a name="line1202"></a>
<a name="line1203"></a>
<a name="line1204"></a>/**
<a name="line1205"></a> * Appends the Iframe to the document body.
<a name="line1206"></a> * @private
<a name="line1207"></a> */
<a name="line1208"></a>goog.net.IframeIo.prototype.appendIframe_ = function() {
<a name="line1209"></a>  goog.dom.getDomHelper(this.form_).getDocument().body.appendChild(
<a name="line1210"></a>      this.iframe_);
<a name="line1211"></a>};
<a name="line1212"></a>
<a name="line1213"></a>
<a name="line1214"></a>/**
<a name="line1215"></a> * Schedules an iframe for disposal, async.  We can&#39;t remove the iframes in the
<a name="line1216"></a> * same execution context as the response, otherwise some versions of Firefox
<a name="line1217"></a> * will not detect that the response has correctly finished and the loading bar
<a name="line1218"></a> * will stay active forever.
<a name="line1219"></a> * @private
<a name="line1220"></a> */
<a name="line1221"></a>goog.net.IframeIo.prototype.scheduleIframeDisposal_ = function() {
<a name="line1222"></a>  var iframe = this.iframe_;
<a name="line1223"></a>
<a name="line1224"></a>  // There shouldn&#39;t be a case where the iframe is null and we get to this
<a name="line1225"></a>  // stage, but the error reports in http://b/909448 indicate it is possible.
<a name="line1226"></a>  if (iframe) {
<a name="line1227"></a>    // NOTE(user): Stops Internet Explorer leaking the iframe object. This
<a name="line1228"></a>    // shouldn&#39;t be needed, since the events have all been removed, which
<a name="line1229"></a>    // should in theory clean up references.  Oh well...
<a name="line1230"></a>    iframe.onreadystatechange = null;
<a name="line1231"></a>    iframe.onload = null;
<a name="line1232"></a>    iframe.onerror = null;
<a name="line1233"></a>
<a name="line1234"></a>    this.iframesForDisposal_.push(iframe);
<a name="line1235"></a>  }
<a name="line1236"></a>
<a name="line1237"></a>  if (this.iframeDisposalTimer_) {
<a name="line1238"></a>    goog.Timer.clear(this.iframeDisposalTimer_);
<a name="line1239"></a>    this.iframeDisposalTimer_ = null;
<a name="line1240"></a>  }
<a name="line1241"></a>
<a name="line1242"></a>  if (goog.userAgent.GECKO || goog.userAgent.OPERA) {
<a name="line1243"></a>    // For FF and Opera, we must dispose the iframe async,
<a name="line1244"></a>    // but it doesn&#39;t need to be done as soon as possible.
<a name="line1245"></a>    // We therefore schedule it for 2s out, so as not to
<a name="line1246"></a>    // affect any other actions that may have been triggered by the request.
<a name="line1247"></a>    this.iframeDisposalTimer_ = goog.Timer.callOnce(
<a name="line1248"></a>        this.disposeIframes_, goog.net.IframeIo.IFRAME_DISPOSE_DELAY_MS, this);
<a name="line1249"></a>
<a name="line1250"></a>  } else {
<a name="line1251"></a>    // For non-Gecko browsers we dispose straight away.
<a name="line1252"></a>    this.disposeIframes_();
<a name="line1253"></a>  }
<a name="line1254"></a>
<a name="line1255"></a>  // Nullify reference
<a name="line1256"></a>  this.iframe_ = null;
<a name="line1257"></a>  this.iframeName_ = null;
<a name="line1258"></a>};
<a name="line1259"></a>
<a name="line1260"></a>
<a name="line1261"></a>/**
<a name="line1262"></a> * Disposes any iframes.
<a name="line1263"></a> * @private
<a name="line1264"></a> */
<a name="line1265"></a>goog.net.IframeIo.prototype.disposeIframes_ = function() {
<a name="line1266"></a>  if (this.iframeDisposalTimer_) {
<a name="line1267"></a>    // Clear the timer
<a name="line1268"></a>    goog.Timer.clear(this.iframeDisposalTimer_);
<a name="line1269"></a>    this.iframeDisposalTimer_ = null;
<a name="line1270"></a>  }
<a name="line1271"></a>
<a name="line1272"></a>  while (this.iframesForDisposal_.length != 0) {
<a name="line1273"></a>    var iframe = this.iframesForDisposal_.pop();
<a name="line1274"></a>    goog.log.info(this.logger_, &#39;Disposing iframe&#39;);
<a name="line1275"></a>    goog.dom.removeNode(iframe);
<a name="line1276"></a>  }
<a name="line1277"></a>};
<a name="line1278"></a>
<a name="line1279"></a>
<a name="line1280"></a>/**
<a name="line1281"></a> * Removes all the child nodes from the static form so it can be reused again.
<a name="line1282"></a> * This should happen right after sending a request. Otherwise, there can be
<a name="line1283"></a> * issues when another iframe uses this form right after the first iframe.
<a name="line1284"></a> * @private
<a name="line1285"></a> */
<a name="line1286"></a>goog.net.IframeIo.prototype.clearForm_ = function() {
<a name="line1287"></a>  if (this.form_ &amp;&amp; this.form_ == goog.net.IframeIo.form_) {
<a name="line1288"></a>    goog.dom.removeChildren(this.form_);
<a name="line1289"></a>  }
<a name="line1290"></a>};
<a name="line1291"></a>
<a name="line1292"></a>
<a name="line1293"></a>/**
<a name="line1294"></a> * Disposes of the Form.  Since IE6 leaks form nodes, this just cleans up the
<a name="line1295"></a> * DOM and nullifies the instances reference so the form can be used for another
<a name="line1296"></a> * request.
<a name="line1297"></a> * @private
<a name="line1298"></a> */
<a name="line1299"></a>goog.net.IframeIo.prototype.disposeForm_ = function() {
<a name="line1300"></a>  this.clearForm_();
<a name="line1301"></a>  this.form_ = null;
<a name="line1302"></a>};
<a name="line1303"></a>
<a name="line1304"></a>
<a name="line1305"></a>/**
<a name="line1306"></a> * @return {HTMLDocument} The appropriate content document.
<a name="line1307"></a> * @private
<a name="line1308"></a> */
<a name="line1309"></a>goog.net.IframeIo.prototype.getContentDocument_ = function() {
<a name="line1310"></a>  if (this.iframe_) {
<a name="line1311"></a>    return /** @type {HTMLDocument} */(goog.dom.getFrameContentDocument(
<a name="line1312"></a>        this.getRequestIframe()));
<a name="line1313"></a>  }
<a name="line1314"></a>  return null;
<a name="line1315"></a>};
<a name="line1316"></a>
<a name="line1317"></a>
<a name="line1318"></a>/**
<a name="line1319"></a> * @return {HTMLIFrameElement} The appropriate iframe to use for requests
<a name="line1320"></a> *     (created in sendForm_).
<a name="line1321"></a> */
<a name="line1322"></a>goog.net.IframeIo.prototype.getRequestIframe = function() {
<a name="line1323"></a>  if (this.iframe_) {
<a name="line1324"></a>    return /** @type {HTMLIFrameElement} */(
<a name="line1325"></a>        goog.net.IframeIo.useIeReadyStateCodePath_() ?
<a name="line1326"></a>            this.iframe_ :
<a name="line1327"></a>            goog.dom.getFrameContentDocument(this.iframe_).getElementById(
<a name="line1328"></a>                this.iframeName_ + goog.net.IframeIo.INNER_FRAME_SUFFIX));
<a name="line1329"></a>  }
<a name="line1330"></a>  return null;
<a name="line1331"></a>};
<a name="line1332"></a>
<a name="line1333"></a>
<a name="line1334"></a>/**
<a name="line1335"></a> * Tests for a silent failure by firefox that can occur when the connection is
<a name="line1336"></a> * reset by the server or is made to an illegal URL.
<a name="line1337"></a> * @private
<a name="line1338"></a> */
<a name="line1339"></a>goog.net.IframeIo.prototype.testForFirefoxSilentError_ = function() {
<a name="line1340"></a>  if (this.active_) {
<a name="line1341"></a>    var doc = this.getContentDocument_();
<a name="line1342"></a>
<a name="line1343"></a>    // This is a hack to test of the document has loaded with a page that
<a name="line1344"></a>    // we can&#39;t access, such as a network error, that won&#39;t report onload
<a name="line1345"></a>    // or onerror events.
<a name="line1346"></a>    if (doc &amp;&amp; !goog.reflect.canAccessProperty(doc, &#39;documentUri&#39;)) {
<a name="line1347"></a>      if (!this.ignoreResponse_) {
<a name="line1348"></a>        goog.events.unlisten(this.getRequestIframe(),
<a name="line1349"></a>            goog.events.EventType.LOAD, this.onIframeLoaded_, false, this);
<a name="line1350"></a>      }
<a name="line1351"></a>
<a name="line1352"></a>      if (navigator.onLine) {
<a name="line1353"></a>        goog.log.warning(this.logger_, &#39;Silent Firefox error detected&#39;);
<a name="line1354"></a>        this.handleError_(goog.net.ErrorCode.FF_SILENT_ERROR);
<a name="line1355"></a>      } else {
<a name="line1356"></a>        goog.log.warning(this.logger_,
<a name="line1357"></a>            &#39;Firefox is offline so report offline error &#39; +
<a name="line1358"></a>            &#39;instead of silent error&#39;);
<a name="line1359"></a>        this.handleError_(goog.net.ErrorCode.OFFLINE);
<a name="line1360"></a>      }
<a name="line1361"></a>      return;
<a name="line1362"></a>    }
<a name="line1363"></a>    this.firefoxSilentErrorTimeout_ =
<a name="line1364"></a>        goog.Timer.callOnce(this.testForFirefoxSilentError_, 250, this);
<a name="line1365"></a>  }
<a name="line1366"></a>};
<a name="line1367"></a>
<a name="line1368"></a>
<a name="line1369"></a>
<a name="line1370"></a>/**
<a name="line1371"></a> * Class for representing incremental data events.
<a name="line1372"></a> * @param {Object} data The data associated with the event.
<a name="line1373"></a> * @extends {goog.events.Event}
<a name="line1374"></a> * @constructor
<a name="line1375"></a> * @final
<a name="line1376"></a> */
<a name="line1377"></a>goog.net.IframeIo.IncrementalDataEvent = function(data) {
<a name="line1378"></a>  goog.events.Event.call(this, goog.net.EventType.INCREMENTAL_DATA);
<a name="line1379"></a>
<a name="line1380"></a>  /**
<a name="line1381"></a>   * The data associated with the event.
<a name="line1382"></a>   * @type {Object}
<a name="line1383"></a>   */
<a name="line1384"></a>  this.data = data;
<a name="line1385"></a>};
<a name="line1386"></a>goog.inherits(goog.net.IframeIo.IncrementalDataEvent, goog.events.Event);
</pre>


</body>
</html>
