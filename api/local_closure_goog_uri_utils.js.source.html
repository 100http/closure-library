<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>utils.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="local_closure_goog_uri_utils.js.html">utils.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2008 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Simple utilities for dealing with URI strings.
<a name="line17"></a> *
<a name="line18"></a> * This is intended to be a lightweight alternative to constructing goog.Uri
<a name="line19"></a> * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
<a name="line20"></a> * of how much of its functionality you use, this is designed to be a set of
<a name="line21"></a> * mostly-independent utilities so that the compiler includes only what is
<a name="line22"></a> * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
<a name="line23"></a> * 1.5k post-gzip.  To ensure the savings remain, future developers should
<a name="line24"></a> * avoid adding new functionality to existing functions, but instead create
<a name="line25"></a> * new ones and factor out shared code.
<a name="line26"></a> *
<a name="line27"></a> * Many of these utilities have limited functionality, tailored to common
<a name="line28"></a> * cases.  The query parameter utilities assume that the parameter keys are
<a name="line29"></a> * already encoded, since most keys are compile-time alphanumeric strings.  The
<a name="line30"></a> * query parameter mutation utilities also do not tolerate fragment identifiers.
<a name="line31"></a> *
<a name="line32"></a> * By design, these functions can be slower than goog.Uri equivalents.
<a name="line33"></a> * Repeated calls to some of functions may be quadratic in behavior for IE,
<a name="line34"></a> * although the effect is somewhat limited given the 2kb limit.
<a name="line35"></a> *
<a name="line36"></a> * One advantage of the limited functionality here is that this approach is
<a name="line37"></a> * less sensitive to differences in URI encodings than goog.Uri, since these
<a name="line38"></a> * functions modify the strings in place, rather than decoding and
<a name="line39"></a> * re-encoding.
<a name="line40"></a> *
<a name="line41"></a> * Uses features of RFC 3986 for parsing/formatting URIs:
<a name="line42"></a> *   http://www.ietf.org/rfc/rfc3986.txt
<a name="line43"></a> *
<a name="line44"></a> * @author gboyer@google.com (Garrett Boyer) - The &quot;lightened&quot; design.
<a name="line45"></a> */
<a name="line46"></a>
<a name="line47"></a>goog.provide(&#39;goog.uri.utils&#39;);
<a name="line48"></a>goog.provide(&#39;goog.uri.utils.ComponentIndex&#39;);
<a name="line49"></a>goog.provide(&#39;goog.uri.utils.QueryArray&#39;);
<a name="line50"></a>goog.provide(&#39;goog.uri.utils.QueryValue&#39;);
<a name="line51"></a>goog.provide(&#39;goog.uri.utils.StandardQueryParam&#39;);
<a name="line52"></a>
<a name="line53"></a>goog.require(&#39;goog.asserts&#39;);
<a name="line54"></a>goog.require(&#39;goog.string&#39;);
<a name="line55"></a>goog.require(&#39;goog.userAgent&#39;);
<a name="line56"></a>
<a name="line57"></a>
<a name="line58"></a>/**
<a name="line59"></a> * Character codes inlined to avoid object allocations due to charCode.
<a name="line60"></a> * @enum {number}
<a name="line61"></a> * @private
<a name="line62"></a> */
<a name="line63"></a>goog.uri.utils.CharCode_ = {
<a name="line64"></a>  AMPERSAND: 38,
<a name="line65"></a>  EQUAL: 61,
<a name="line66"></a>  HASH: 35,
<a name="line67"></a>  QUESTION: 63
<a name="line68"></a>};
<a name="line69"></a>
<a name="line70"></a>
<a name="line71"></a>/**
<a name="line72"></a> * Builds a URI string from already-encoded parts.
<a name="line73"></a> *
<a name="line74"></a> * No encoding is performed.  Any component may be omitted as either null or
<a name="line75"></a> * undefined.
<a name="line76"></a> *
<a name="line77"></a> * @param {?string=} opt_scheme The scheme such as &#39;http&#39;.
<a name="line78"></a> * @param {?string=} opt_userInfo The user name before the &#39;@&#39;.
<a name="line79"></a> * @param {?string=} opt_domain The domain such as &#39;www.google.com&#39;, already
<a name="line80"></a> *     URI-encoded.
<a name="line81"></a> * @param {(string|number|null)=} opt_port The port number.
<a name="line82"></a> * @param {?string=} opt_path The path, already URI-encoded.  If it is not
<a name="line83"></a> *     empty, it must begin with a slash.
<a name="line84"></a> * @param {?string=} opt_queryData The URI-encoded query data.
<a name="line85"></a> * @param {?string=} opt_fragment The URI-encoded fragment identifier.
<a name="line86"></a> * @return {string} The fully combined URI.
<a name="line87"></a> */
<a name="line88"></a>goog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo,
<a name="line89"></a>    opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
<a name="line90"></a>  var out = &#39;&#39;;
<a name="line91"></a>
<a name="line92"></a>  if (opt_scheme) {
<a name="line93"></a>    out += opt_scheme + &#39;:&#39;;
<a name="line94"></a>  }
<a name="line95"></a>
<a name="line96"></a>  if (opt_domain) {
<a name="line97"></a>    out += &#39;//&#39;;
<a name="line98"></a>
<a name="line99"></a>    if (opt_userInfo) {
<a name="line100"></a>      out += opt_userInfo + &#39;@&#39;;
<a name="line101"></a>    }
<a name="line102"></a>
<a name="line103"></a>    out += opt_domain;
<a name="line104"></a>
<a name="line105"></a>    if (opt_port) {
<a name="line106"></a>      out += &#39;:&#39; + opt_port;
<a name="line107"></a>    }
<a name="line108"></a>  }
<a name="line109"></a>
<a name="line110"></a>  if (opt_path) {
<a name="line111"></a>    out += opt_path;
<a name="line112"></a>  }
<a name="line113"></a>
<a name="line114"></a>  if (opt_queryData) {
<a name="line115"></a>    out += &#39;?&#39; + opt_queryData;
<a name="line116"></a>  }
<a name="line117"></a>
<a name="line118"></a>  if (opt_fragment) {
<a name="line119"></a>    out += &#39;#&#39; + opt_fragment;
<a name="line120"></a>  }
<a name="line121"></a>
<a name="line122"></a>  return out;
<a name="line123"></a>};
<a name="line124"></a>
<a name="line125"></a>
<a name="line126"></a>/**
<a name="line127"></a> * A regular expression for breaking a URI into its component parts.
<a name="line128"></a> *
<a name="line129"></a> * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B
<a name="line130"></a> * As the &quot;first-match-wins&quot; algorithm is identical to the &quot;greedy&quot;
<a name="line131"></a> * disambiguation method used by POSIX regular expressions, it is natural and
<a name="line132"></a> * commonplace to use a regular expression for parsing the potential five
<a name="line133"></a> * components of a URI reference.
<a name="line134"></a> *
<a name="line135"></a> * The following line is the regular expression for breaking-down a
<a name="line136"></a> * well-formed URI reference into its components.
<a name="line137"></a> *
<a name="line138"></a> * &lt;pre&gt;
<a name="line139"></a> * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
<a name="line140"></a> *  12            3  4          5       6  7        8 9
<a name="line141"></a> * &lt;/pre&gt;
<a name="line142"></a> *
<a name="line143"></a> * The numbers in the second line above are only to assist readability; they
<a name="line144"></a> * indicate the reference points for each subexpression (i.e., each paired
<a name="line145"></a> * parenthesis). We refer to the value matched for subexpression &lt;n&gt; as $&lt;n&gt;.
<a name="line146"></a> * For example, matching the above expression to
<a name="line147"></a> * &lt;pre&gt;
<a name="line148"></a> *     http://www.ics.uci.edu/pub/ietf/uri/#Related
<a name="line149"></a> * &lt;/pre&gt;
<a name="line150"></a> * results in the following subexpression matches:
<a name="line151"></a> * &lt;pre&gt;
<a name="line152"></a> *    $1 = http:
<a name="line153"></a> *    $2 = http
<a name="line154"></a> *    $3 = //www.ics.uci.edu
<a name="line155"></a> *    $4 = www.ics.uci.edu
<a name="line156"></a> *    $5 = /pub/ietf/uri/
<a name="line157"></a> *    $6 = &lt;undefined&gt;
<a name="line158"></a> *    $7 = &lt;undefined&gt;
<a name="line159"></a> *    $8 = #Related
<a name="line160"></a> *    $9 = Related
<a name="line161"></a> * &lt;/pre&gt;
<a name="line162"></a> * where &lt;undefined&gt; indicates that the component is not present, as is the
<a name="line163"></a> * case for the query component in the above example. Therefore, we can
<a name="line164"></a> * determine the value of the five components as
<a name="line165"></a> * &lt;pre&gt;
<a name="line166"></a> *    scheme    = $2
<a name="line167"></a> *    authority = $4
<a name="line168"></a> *    path      = $5
<a name="line169"></a> *    query     = $7
<a name="line170"></a> *    fragment  = $9
<a name="line171"></a> * &lt;/pre&gt;
<a name="line172"></a> *
<a name="line173"></a> * The regular expression has been modified slightly to expose the
<a name="line174"></a> * userInfo, domain, and port separately from the authority.
<a name="line175"></a> * The modified version yields
<a name="line176"></a> * &lt;pre&gt;
<a name="line177"></a> *    $1 = http              scheme
<a name="line178"></a> *    $2 = &lt;undefined&gt;       userInfo -\
<a name="line179"></a> *    $3 = www.ics.uci.edu   domain     | authority
<a name="line180"></a> *    $4 = &lt;undefined&gt;       port     -/
<a name="line181"></a> *    $5 = /pub/ietf/uri/    path
<a name="line182"></a> *    $6 = &lt;undefined&gt;       query without ?
<a name="line183"></a> *    $7 = Related           fragment without #
<a name="line184"></a> * &lt;/pre&gt;
<a name="line185"></a> * @type {!RegExp}
<a name="line186"></a> * @private
<a name="line187"></a> */
<a name="line188"></a>goog.uri.utils.splitRe_ = new RegExp(
<a name="line189"></a>    &#39;^&#39; +
<a name="line190"></a>    &#39;(?:&#39; +
<a name="line191"></a>        &#39;([^:/?#.]+)&#39; +                  // scheme - ignore special characters
<a name="line192"></a>                                         // used by other URL parts such as :,
<a name="line193"></a>                                         // ?, /, #, and .
<a name="line194"></a>    &#39;:)?&#39; +
<a name="line195"></a>    &#39;(?://&#39; +
<a name="line196"></a>        &#39;(?:([^/?#]*)@)?&#39; +              // userInfo
<a name="line197"></a>        &#39;([^/#?]*?)&#39; +                   // domain
<a name="line198"></a>        &#39;(?::([0-9]+))?&#39; +               // port
<a name="line199"></a>        &#39;(?=[/#?]|$)&#39; +                  // authority-terminating character
<a name="line200"></a>    &#39;)?&#39; +
<a name="line201"></a>    &#39;([^?#]+)?&#39; +                        // path
<a name="line202"></a>    &#39;(?:\\?([^#]*))?&#39; +                  // query
<a name="line203"></a>    &#39;(?:#(.*))?&#39; +                       // fragment
<a name="line204"></a>    &#39;$&#39;);
<a name="line205"></a>
<a name="line206"></a>
<a name="line207"></a>/**
<a name="line208"></a> * The index of each URI component in the return value of goog.uri.utils.split.
<a name="line209"></a> * @enum {number}
<a name="line210"></a> */
<a name="line211"></a>goog.uri.utils.ComponentIndex = {
<a name="line212"></a>  SCHEME: 1,
<a name="line213"></a>  USER_INFO: 2,
<a name="line214"></a>  DOMAIN: 3,
<a name="line215"></a>  PORT: 4,
<a name="line216"></a>  PATH: 5,
<a name="line217"></a>  QUERY_DATA: 6,
<a name="line218"></a>  FRAGMENT: 7
<a name="line219"></a>};
<a name="line220"></a>
<a name="line221"></a>
<a name="line222"></a>/**
<a name="line223"></a> * Splits a URI into its component parts.
<a name="line224"></a> *
<a name="line225"></a> * Each component can be accessed via the component indices; for example:
<a name="line226"></a> * &lt;pre&gt;
<a name="line227"></a> * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
<a name="line228"></a> * &lt;/pre&gt;
<a name="line229"></a> *
<a name="line230"></a> * @param {string} uri The URI string to examine.
<a name="line231"></a> * @return {!Array.&lt;string|undefined&gt;} Each component still URI-encoded.
<a name="line232"></a> *     Each component that is present will contain the encoded value, whereas
<a name="line233"></a> *     components that are not present will be undefined or empty, depending
<a name="line234"></a> *     on the browser&#39;s regular expression implementation.  Never null, since
<a name="line235"></a> *     arbitrary strings may still look like path names.
<a name="line236"></a> */
<a name="line237"></a>goog.uri.utils.split = function(uri) {
<a name="line238"></a>  goog.uri.utils.phishingProtection_();
<a name="line239"></a>
<a name="line240"></a>  // See @return comment -- never null.
<a name="line241"></a>  return /** @type {!Array.&lt;string|undefined&gt;} */ (
<a name="line242"></a>      uri.match(goog.uri.utils.splitRe_));
<a name="line243"></a>};
<a name="line244"></a>
<a name="line245"></a>
<a name="line246"></a>/**
<a name="line247"></a> * Safari has a nasty bug where if you have an http URL with a username, e.g.,
<a name="line248"></a> * http://evil.com%2F@google.com/
<a name="line249"></a> * Safari will report that window.location.href is
<a name="line250"></a> * http://evil.com/google.com/
<a name="line251"></a> * so that anyone who tries to parse the domain of that URL will get
<a name="line252"></a> * the wrong domain. We&#39;ve seen exploits where people use this to trick
<a name="line253"></a> * Safari into loading resources from evil domains.
<a name="line254"></a> *
<a name="line255"></a> * To work around this, we run a little &quot;Safari phishing check&quot;, and throw
<a name="line256"></a> * an exception if we see this happening.
<a name="line257"></a> *
<a name="line258"></a> * There is no convenient place to put this check. We apply it to
<a name="line259"></a> * anyone doing URI parsing on Webkit. We&#39;re not happy about this, but
<a name="line260"></a> * it fixes the problem.
<a name="line261"></a> *
<a name="line262"></a> * This should be removed once Safari fixes their bug.
<a name="line263"></a> *
<a name="line264"></a> * Exploit reported by Masato Kinugawa.
<a name="line265"></a> *
<a name="line266"></a> * @type {boolean}
<a name="line267"></a> * @private
<a name="line268"></a> */
<a name="line269"></a>goog.uri.utils.needsPhishingProtection_ = goog.userAgent.WEBKIT;
<a name="line270"></a>
<a name="line271"></a>
<a name="line272"></a>/**
<a name="line273"></a> * Check to see if the user is being phished.
<a name="line274"></a> * @private
<a name="line275"></a> */
<a name="line276"></a>goog.uri.utils.phishingProtection_ = function() {
<a name="line277"></a>  if (goog.uri.utils.needsPhishingProtection_) {
<a name="line278"></a>    // Turn protection off, so that we don&#39;t recurse.
<a name="line279"></a>    goog.uri.utils.needsPhishingProtection_ = false;
<a name="line280"></a>
<a name="line281"></a>    // Use quoted access, just in case the user isn&#39;t using location externs.
<a name="line282"></a>    var location = goog.global[&#39;location&#39;];
<a name="line283"></a>    if (location) {
<a name="line284"></a>      var href = location[&#39;href&#39;];
<a name="line285"></a>      if (href) {
<a name="line286"></a>        var domain = goog.uri.utils.getDomain(href);
<a name="line287"></a>        if (domain &amp;&amp; domain != location[&#39;hostname&#39;]) {
<a name="line288"></a>          // Phishing attack
<a name="line289"></a>          goog.uri.utils.needsPhishingProtection_ = true;
<a name="line290"></a>          throw Error();
<a name="line291"></a>        }
<a name="line292"></a>      }
<a name="line293"></a>    }
<a name="line294"></a>  }
<a name="line295"></a>};
<a name="line296"></a>
<a name="line297"></a>
<a name="line298"></a>/**
<a name="line299"></a> * @param {?string} uri A possibly null string.
<a name="line300"></a> * @return {?string} The string URI-decoded, or null if uri is null.
<a name="line301"></a> * @private
<a name="line302"></a> */
<a name="line303"></a>goog.uri.utils.decodeIfPossible_ = function(uri) {
<a name="line304"></a>  return uri &amp;&amp; decodeURIComponent(uri);
<a name="line305"></a>};
<a name="line306"></a>
<a name="line307"></a>
<a name="line308"></a>/**
<a name="line309"></a> * Gets a URI component by index.
<a name="line310"></a> *
<a name="line311"></a> * It is preferred to use the getPathEncoded() variety of functions ahead,
<a name="line312"></a> * since they are more readable.
<a name="line313"></a> *
<a name="line314"></a> * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
<a name="line315"></a> * @param {string} uri The URI to examine.
<a name="line316"></a> * @return {?string} The still-encoded component, or null if the component
<a name="line317"></a> *     is not present.
<a name="line318"></a> * @private
<a name="line319"></a> */
<a name="line320"></a>goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
<a name="line321"></a>  // Convert undefined, null, and empty string into null.
<a name="line322"></a>  return goog.uri.utils.split(uri)[componentIndex] || null;
<a name="line323"></a>};
<a name="line324"></a>
<a name="line325"></a>
<a name="line326"></a>/**
<a name="line327"></a> * @param {string} uri The URI to examine.
<a name="line328"></a> * @return {?string} The protocol or scheme, or null if none.  Does not
<a name="line329"></a> *     include trailing colons or slashes.
<a name="line330"></a> */
<a name="line331"></a>goog.uri.utils.getScheme = function(uri) {
<a name="line332"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line333"></a>      goog.uri.utils.ComponentIndex.SCHEME, uri);
<a name="line334"></a>};
<a name="line335"></a>
<a name="line336"></a>
<a name="line337"></a>/**
<a name="line338"></a> * Gets the effective scheme for the URL.  If the URL is relative then the
<a name="line339"></a> * scheme is derived from the page&#39;s location.
<a name="line340"></a> * @param {string} uri The URI to examine.
<a name="line341"></a> * @return {string} The protocol or scheme, always lower case.
<a name="line342"></a> */
<a name="line343"></a>goog.uri.utils.getEffectiveScheme = function(uri) {
<a name="line344"></a>  var scheme = goog.uri.utils.getScheme(uri);
<a name="line345"></a>  if (!scheme &amp;&amp; self.location) {
<a name="line346"></a>    var protocol = self.location.protocol;
<a name="line347"></a>    scheme = protocol.substr(0, protocol.length - 1);
<a name="line348"></a>  }
<a name="line349"></a>  // NOTE: When called from a web worker in Firefox 3.5, location maybe null.
<a name="line350"></a>  // All other browsers with web workers support self.location from the worker.
<a name="line351"></a>  return scheme ? scheme.toLowerCase() : &#39;&#39;;
<a name="line352"></a>};
<a name="line353"></a>
<a name="line354"></a>
<a name="line355"></a>/**
<a name="line356"></a> * @param {string} uri The URI to examine.
<a name="line357"></a> * @return {?string} The user name still encoded, or null if none.
<a name="line358"></a> */
<a name="line359"></a>goog.uri.utils.getUserInfoEncoded = function(uri) {
<a name="line360"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line361"></a>      goog.uri.utils.ComponentIndex.USER_INFO, uri);
<a name="line362"></a>};
<a name="line363"></a>
<a name="line364"></a>
<a name="line365"></a>/**
<a name="line366"></a> * @param {string} uri The URI to examine.
<a name="line367"></a> * @return {?string} The decoded user info, or null if none.
<a name="line368"></a> */
<a name="line369"></a>goog.uri.utils.getUserInfo = function(uri) {
<a name="line370"></a>  return goog.uri.utils.decodeIfPossible_(
<a name="line371"></a>      goog.uri.utils.getUserInfoEncoded(uri));
<a name="line372"></a>};
<a name="line373"></a>
<a name="line374"></a>
<a name="line375"></a>/**
<a name="line376"></a> * @param {string} uri The URI to examine.
<a name="line377"></a> * @return {?string} The domain name still encoded, or null if none.
<a name="line378"></a> */
<a name="line379"></a>goog.uri.utils.getDomainEncoded = function(uri) {
<a name="line380"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line381"></a>      goog.uri.utils.ComponentIndex.DOMAIN, uri);
<a name="line382"></a>};
<a name="line383"></a>
<a name="line384"></a>
<a name="line385"></a>/**
<a name="line386"></a> * @param {string} uri The URI to examine.
<a name="line387"></a> * @return {?string} The decoded domain, or null if none.
<a name="line388"></a> */
<a name="line389"></a>goog.uri.utils.getDomain = function(uri) {
<a name="line390"></a>  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri));
<a name="line391"></a>};
<a name="line392"></a>
<a name="line393"></a>
<a name="line394"></a>/**
<a name="line395"></a> * @param {string} uri The URI to examine.
<a name="line396"></a> * @return {?number} The port number, or null if none.
<a name="line397"></a> */
<a name="line398"></a>goog.uri.utils.getPort = function(uri) {
<a name="line399"></a>  // Coerce to a number.  If the result of getComponentByIndex_ is null or
<a name="line400"></a>  // non-numeric, the number coersion yields NaN.  This will then return
<a name="line401"></a>  // null for all non-numeric cases (though also zero, which isn&#39;t a relevant
<a name="line402"></a>  // port number).
<a name="line403"></a>  return Number(goog.uri.utils.getComponentByIndex_(
<a name="line404"></a>      goog.uri.utils.ComponentIndex.PORT, uri)) || null;
<a name="line405"></a>};
<a name="line406"></a>
<a name="line407"></a>
<a name="line408"></a>/**
<a name="line409"></a> * @param {string} uri The URI to examine.
<a name="line410"></a> * @return {?string} The path still encoded, or null if none. Includes the
<a name="line411"></a> *     leading slash, if any.
<a name="line412"></a> */
<a name="line413"></a>goog.uri.utils.getPathEncoded = function(uri) {
<a name="line414"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line415"></a>      goog.uri.utils.ComponentIndex.PATH, uri);
<a name="line416"></a>};
<a name="line417"></a>
<a name="line418"></a>
<a name="line419"></a>/**
<a name="line420"></a> * @param {string} uri The URI to examine.
<a name="line421"></a> * @return {?string} The decoded path, or null if none.  Includes the leading
<a name="line422"></a> *     slash, if any.
<a name="line423"></a> */
<a name="line424"></a>goog.uri.utils.getPath = function(uri) {
<a name="line425"></a>  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri));
<a name="line426"></a>};
<a name="line427"></a>
<a name="line428"></a>
<a name="line429"></a>/**
<a name="line430"></a> * @param {string} uri The URI to examine.
<a name="line431"></a> * @return {?string} The query data still encoded, or null if none.  Does not
<a name="line432"></a> *     include the question mark itself.
<a name="line433"></a> */
<a name="line434"></a>goog.uri.utils.getQueryData = function(uri) {
<a name="line435"></a>  return goog.uri.utils.getComponentByIndex_(
<a name="line436"></a>      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
<a name="line437"></a>};
<a name="line438"></a>
<a name="line439"></a>
<a name="line440"></a>/**
<a name="line441"></a> * @param {string} uri The URI to examine.
<a name="line442"></a> * @return {?string} The fragment identifier, or null if none.  Does not
<a name="line443"></a> *     include the hash mark itself.
<a name="line444"></a> */
<a name="line445"></a>goog.uri.utils.getFragmentEncoded = function(uri) {
<a name="line446"></a>  // The hash mark may not appear in any other part of the URL.
<a name="line447"></a>  var hashIndex = uri.indexOf(&#39;#&#39;);
<a name="line448"></a>  return hashIndex &lt; 0 ? null : uri.substr(hashIndex + 1);
<a name="line449"></a>};
<a name="line450"></a>
<a name="line451"></a>
<a name="line452"></a>/**
<a name="line453"></a> * @param {string} uri The URI to examine.
<a name="line454"></a> * @param {?string} fragment The encoded fragment identifier, or null if none.
<a name="line455"></a> *     Does not include the hash mark itself.
<a name="line456"></a> * @return {string} The URI with the fragment set.
<a name="line457"></a> */
<a name="line458"></a>goog.uri.utils.setFragmentEncoded = function(uri, fragment) {
<a name="line459"></a>  return goog.uri.utils.removeFragment(uri) + (fragment ? &#39;#&#39; + fragment : &#39;&#39;);
<a name="line460"></a>};
<a name="line461"></a>
<a name="line462"></a>
<a name="line463"></a>/**
<a name="line464"></a> * @param {string} uri The URI to examine.
<a name="line465"></a> * @return {?string} The decoded fragment identifier, or null if none.  Does
<a name="line466"></a> *     not include the hash mark.
<a name="line467"></a> */
<a name="line468"></a>goog.uri.utils.getFragment = function(uri) {
<a name="line469"></a>  return goog.uri.utils.decodeIfPossible_(
<a name="line470"></a>      goog.uri.utils.getFragmentEncoded(uri));
<a name="line471"></a>};
<a name="line472"></a>
<a name="line473"></a>
<a name="line474"></a>/**
<a name="line475"></a> * Extracts everything up to the port of the URI.
<a name="line476"></a> * @param {string} uri The URI string.
<a name="line477"></a> * @return {string} Everything up to and including the port.
<a name="line478"></a> */
<a name="line479"></a>goog.uri.utils.getHost = function(uri) {
<a name="line480"></a>  var pieces = goog.uri.utils.split(uri);
<a name="line481"></a>  return goog.uri.utils.buildFromEncodedParts(
<a name="line482"></a>      pieces[goog.uri.utils.ComponentIndex.SCHEME],
<a name="line483"></a>      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
<a name="line484"></a>      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
<a name="line485"></a>      pieces[goog.uri.utils.ComponentIndex.PORT]);
<a name="line486"></a>};
<a name="line487"></a>
<a name="line488"></a>
<a name="line489"></a>/**
<a name="line490"></a> * Extracts the path of the URL and everything after.
<a name="line491"></a> * @param {string} uri The URI string.
<a name="line492"></a> * @return {string} The URI, starting at the path and including the query
<a name="line493"></a> *     parameters and fragment identifier.
<a name="line494"></a> */
<a name="line495"></a>goog.uri.utils.getPathAndAfter = function(uri) {
<a name="line496"></a>  var pieces = goog.uri.utils.split(uri);
<a name="line497"></a>  return goog.uri.utils.buildFromEncodedParts(null, null, null, null,
<a name="line498"></a>      pieces[goog.uri.utils.ComponentIndex.PATH],
<a name="line499"></a>      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
<a name="line500"></a>      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
<a name="line501"></a>};
<a name="line502"></a>
<a name="line503"></a>
<a name="line504"></a>/**
<a name="line505"></a> * Gets the URI with the fragment identifier removed.
<a name="line506"></a> * @param {string} uri The URI to examine.
<a name="line507"></a> * @return {string} Everything preceding the hash mark.
<a name="line508"></a> */
<a name="line509"></a>goog.uri.utils.removeFragment = function(uri) {
<a name="line510"></a>  // The hash mark may not appear in any other part of the URL.
<a name="line511"></a>  var hashIndex = uri.indexOf(&#39;#&#39;);
<a name="line512"></a>  return hashIndex &lt; 0 ? uri : uri.substr(0, hashIndex);
<a name="line513"></a>};
<a name="line514"></a>
<a name="line515"></a>
<a name="line516"></a>/**
<a name="line517"></a> * Ensures that two URI&#39;s have the exact same domain, scheme, and port.
<a name="line518"></a> *
<a name="line519"></a> * Unlike the version in goog.Uri, this checks protocol, and therefore is
<a name="line520"></a> * suitable for checking against the browser&#39;s same-origin policy.
<a name="line521"></a> *
<a name="line522"></a> * @param {string} uri1 The first URI.
<a name="line523"></a> * @param {string} uri2 The second URI.
<a name="line524"></a> * @return {boolean} Whether they have the same domain and port.
<a name="line525"></a> */
<a name="line526"></a>goog.uri.utils.haveSameDomain = function(uri1, uri2) {
<a name="line527"></a>  var pieces1 = goog.uri.utils.split(uri1);
<a name="line528"></a>  var pieces2 = goog.uri.utils.split(uri2);
<a name="line529"></a>  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
<a name="line530"></a>             pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &amp;&amp;
<a name="line531"></a>         pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
<a name="line532"></a>             pieces2[goog.uri.utils.ComponentIndex.SCHEME] &amp;&amp;
<a name="line533"></a>         pieces1[goog.uri.utils.ComponentIndex.PORT] ==
<a name="line534"></a>             pieces2[goog.uri.utils.ComponentIndex.PORT];
<a name="line535"></a>};
<a name="line536"></a>
<a name="line537"></a>
<a name="line538"></a>/**
<a name="line539"></a> * Asserts that there are no fragment or query identifiers, only in uncompiled
<a name="line540"></a> * mode.
<a name="line541"></a> * @param {string} uri The URI to examine.
<a name="line542"></a> * @private
<a name="line543"></a> */
<a name="line544"></a>goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
<a name="line545"></a>  // NOTE: would use goog.asserts here, but jscompiler doesn&#39;t know that
<a name="line546"></a>  // indexOf has no side effects.
<a name="line547"></a>  if (goog.DEBUG &amp;&amp; (uri.indexOf(&#39;#&#39;) &gt;= 0 || uri.indexOf(&#39;?&#39;) &gt;= 0)) {
<a name="line548"></a>    throw Error(&#39;goog.uri.utils: Fragment or query identifiers are not &#39; +
<a name="line549"></a>        &#39;supported: [&#39; + uri + &#39;]&#39;);
<a name="line550"></a>  }
<a name="line551"></a>};
<a name="line552"></a>
<a name="line553"></a>
<a name="line554"></a>/**
<a name="line555"></a> * Supported query parameter values by the parameter serializing utilities.
<a name="line556"></a> *
<a name="line557"></a> * If a value is null or undefined, the key-value pair is skipped, as an easy
<a name="line558"></a> * way to omit parameters conditionally.  Non-array parameters are converted
<a name="line559"></a> * to a string and URI encoded.  Array values are expanded into multiple
<a name="line560"></a> * &amp;key=value pairs, with each element stringized and URI-encoded.
<a name="line561"></a> *
<a name="line562"></a> * @typedef {*}
<a name="line563"></a> */
<a name="line564"></a>goog.uri.utils.QueryValue;
<a name="line565"></a>
<a name="line566"></a>
<a name="line567"></a>/**
<a name="line568"></a> * An array representing a set of query parameters with alternating keys
<a name="line569"></a> * and values.
<a name="line570"></a> *
<a name="line571"></a> * Keys are assumed to be URI encoded already and live at even indices.  See
<a name="line572"></a> * goog.uri.utils.QueryValue for details on how parameter values are encoded.
<a name="line573"></a> *
<a name="line574"></a> * Example:
<a name="line575"></a> * &lt;pre&gt;
<a name="line576"></a> * var data = [
<a name="line577"></a> *   // Simple param: ?name=BobBarker
<a name="line578"></a> *   &#39;name&#39;, &#39;BobBarker&#39;,
<a name="line579"></a> *   // Conditional param -- may be omitted entirely.
<a name="line580"></a> *   &#39;specialDietaryNeeds&#39;, hasDietaryNeeds() ? getDietaryNeeds() : null,
<a name="line581"></a> *   // Multi-valued param: &amp;house=LosAngeles&amp;house=NewYork&amp;house=null
<a name="line582"></a> *   &#39;house&#39;, [&#39;LosAngeles&#39;, &#39;NewYork&#39;, null]
<a name="line583"></a> * ];
<a name="line584"></a> * &lt;/pre&gt;
<a name="line585"></a> *
<a name="line586"></a> * @typedef {!Array.&lt;string|goog.uri.utils.QueryValue&gt;}
<a name="line587"></a> */
<a name="line588"></a>goog.uri.utils.QueryArray;
<a name="line589"></a>
<a name="line590"></a>
<a name="line591"></a>/**
<a name="line592"></a> * Appends a URI and query data in a string buffer with special preconditions.
<a name="line593"></a> *
<a name="line594"></a> * Internal implementation utility, performing very few object allocations.
<a name="line595"></a> *
<a name="line596"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer.  The first element
<a name="line597"></a> *     must be the base URI, and may have a fragment identifier.  If the array
<a name="line598"></a> *     contains more than one element, the second element must be an ampersand,
<a name="line599"></a> *     and may be overwritten, depending on the base URI.  Undefined elements
<a name="line600"></a> *     are treated as empty-string.
<a name="line601"></a> * @return {string} The concatenated URI and query data.
<a name="line602"></a> * @private
<a name="line603"></a> */
<a name="line604"></a>goog.uri.utils.appendQueryData_ = function(buffer) {
<a name="line605"></a>  if (buffer[1]) {
<a name="line606"></a>    // At least one query parameter was added.  We need to check the
<a name="line607"></a>    // punctuation mark, which is currently an ampersand, and also make sure
<a name="line608"></a>    // there aren&#39;t any interfering fragment identifiers.
<a name="line609"></a>    var baseUri = /** @type {string} */ (buffer[0]);
<a name="line610"></a>    var hashIndex = baseUri.indexOf(&#39;#&#39;);
<a name="line611"></a>    if (hashIndex &gt;= 0) {
<a name="line612"></a>      // Move the fragment off the base part of the URI into the end.
<a name="line613"></a>      buffer.push(baseUri.substr(hashIndex));
<a name="line614"></a>      buffer[0] = baseUri = baseUri.substr(0, hashIndex);
<a name="line615"></a>    }
<a name="line616"></a>    var questionIndex = baseUri.indexOf(&#39;?&#39;);
<a name="line617"></a>    if (questionIndex &lt; 0) {
<a name="line618"></a>      // No question mark, so we need a question mark instead of an ampersand.
<a name="line619"></a>      buffer[1] = &#39;?&#39;;
<a name="line620"></a>    } else if (questionIndex == baseUri.length - 1) {
<a name="line621"></a>      // Question mark is the very last character of the existing URI, so don&#39;t
<a name="line622"></a>      // append an additional delimiter.
<a name="line623"></a>      buffer[1] = undefined;
<a name="line624"></a>    }
<a name="line625"></a>  }
<a name="line626"></a>
<a name="line627"></a>  return buffer.join(&#39;&#39;);
<a name="line628"></a>};
<a name="line629"></a>
<a name="line630"></a>
<a name="line631"></a>/**
<a name="line632"></a> * Appends key=value pairs to an array, supporting multi-valued objects.
<a name="line633"></a> * @param {string} key The key prefix.
<a name="line634"></a> * @param {goog.uri.utils.QueryValue} value The value to serialize.
<a name="line635"></a> * @param {!Array.&lt;string&gt;} pairs The array to which the &#39;key=value&#39; strings
<a name="line636"></a> *     should be appended.
<a name="line637"></a> * @private
<a name="line638"></a> */
<a name="line639"></a>goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
<a name="line640"></a>  if (goog.isArray(value)) {
<a name="line641"></a>    // Convince the compiler it&#39;s an array.
<a name="line642"></a>    goog.asserts.assertArray(value);
<a name="line643"></a>    for (var j = 0; j &lt; value.length; j++) {
<a name="line644"></a>      // Convert to string explicitly, to short circuit the null and array
<a name="line645"></a>      // logic in this function -- this ensures that null and undefined get
<a name="line646"></a>      // written as literal &#39;null&#39; and &#39;undefined&#39;, and arrays don&#39;t get
<a name="line647"></a>      // expanded out but instead encoded in the default way.
<a name="line648"></a>      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);
<a name="line649"></a>    }
<a name="line650"></a>  } else if (value != null) {
<a name="line651"></a>    // Skip a top-level null or undefined entirely.
<a name="line652"></a>    pairs.push(&#39;&amp;&#39;, key,
<a name="line653"></a>        // Check for empty string. Zero gets encoded into the url as literal
<a name="line654"></a>        // strings.  For empty string, skip the equal sign, to be consistent
<a name="line655"></a>        // with UriBuilder.java.
<a name="line656"></a>        value === &#39;&#39; ? &#39;&#39; : &#39;=&#39;,
<a name="line657"></a>        goog.string.urlEncode(value));
<a name="line658"></a>  }
<a name="line659"></a>};
<a name="line660"></a>
<a name="line661"></a>
<a name="line662"></a>/**
<a name="line663"></a> * Builds a buffer of query data from a sequence of alternating keys and values.
<a name="line664"></a> *
<a name="line665"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer to append to.  The
<a name="line666"></a> *     first element appended will be an &#39;&amp;&#39;, and may be replaced by the caller.
<a name="line667"></a> * @param {goog.uri.utils.QueryArray|Arguments} keysAndValues An array with
<a name="line668"></a> *     alternating keys and values -- see the typedef.
<a name="line669"></a> * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
<a name="line670"></a> * @return {!Array.&lt;string|undefined&gt;} The buffer argument.
<a name="line671"></a> * @private
<a name="line672"></a> */
<a name="line673"></a>goog.uri.utils.buildQueryDataBuffer_ = function(
<a name="line674"></a>    buffer, keysAndValues, opt_startIndex) {
<a name="line675"></a>  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0),
<a name="line676"></a>      0) % 2 == 0, &#39;goog.uri.utils: Key/value lists must be even in length.&#39;);
<a name="line677"></a>
<a name="line678"></a>  for (var i = opt_startIndex || 0; i &lt; keysAndValues.length; i += 2) {
<a name="line679"></a>    goog.uri.utils.appendKeyValuePairs_(
<a name="line680"></a>        keysAndValues[i], keysAndValues[i + 1], buffer);
<a name="line681"></a>  }
<a name="line682"></a>
<a name="line683"></a>  return buffer;
<a name="line684"></a>};
<a name="line685"></a>
<a name="line686"></a>
<a name="line687"></a>/**
<a name="line688"></a> * Builds a query data string from a sequence of alternating keys and values.
<a name="line689"></a> * Currently generates &quot;&amp;key&amp;&quot; for empty args.
<a name="line690"></a> *
<a name="line691"></a> * @param {goog.uri.utils.QueryArray} keysAndValues Alternating keys and
<a name="line692"></a> *     values.  See the typedef.
<a name="line693"></a> * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
<a name="line694"></a> * @return {string} The encoded query string, in the form &#39;a=1&amp;b=2&#39;.
<a name="line695"></a> */
<a name="line696"></a>goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
<a name="line697"></a>  var buffer = goog.uri.utils.buildQueryDataBuffer_(
<a name="line698"></a>      [], keysAndValues, opt_startIndex);
<a name="line699"></a>  buffer[0] = &#39;&#39;; // Remove the leading ampersand.
<a name="line700"></a>  return buffer.join(&#39;&#39;);
<a name="line701"></a>};
<a name="line702"></a>
<a name="line703"></a>
<a name="line704"></a>/**
<a name="line705"></a> * Builds a buffer of query data from a map.
<a name="line706"></a> *
<a name="line707"></a> * @param {!Array.&lt;string|undefined&gt;} buffer A string buffer to append to.  The
<a name="line708"></a> *     first element appended will be an &#39;&amp;&#39;, and may be replaced by the caller.
<a name="line709"></a> * @param {Object.&lt;goog.uri.utils.QueryValue&gt;} map An object where keys are
<a name="line710"></a> *     URI-encoded parameter keys, and the values conform to the contract
<a name="line711"></a> *     specified in the goog.uri.utils.QueryValue typedef.
<a name="line712"></a> * @return {!Array.&lt;string|undefined&gt;} The buffer argument.
<a name="line713"></a> * @private
<a name="line714"></a> */
<a name="line715"></a>goog.uri.utils.buildQueryDataBufferFromMap_ = function(buffer, map) {
<a name="line716"></a>  for (var key in map) {
<a name="line717"></a>    goog.uri.utils.appendKeyValuePairs_(key, map[key], buffer);
<a name="line718"></a>  }
<a name="line719"></a>
<a name="line720"></a>  return buffer;
<a name="line721"></a>};
<a name="line722"></a>
<a name="line723"></a>
<a name="line724"></a>/**
<a name="line725"></a> * Builds a query data string from a map.
<a name="line726"></a> * Currently generates &quot;&amp;key&amp;&quot; for empty args.
<a name="line727"></a> *
<a name="line728"></a> * @param {Object} map An object where keys are URI-encoded parameter keys,
<a name="line729"></a> *     and the values are arbitrary types or arrays.  Keys with a null value
<a name="line730"></a> *     are dropped.
<a name="line731"></a> * @return {string} The encoded query string, in the form &#39;a=1&amp;b=2&#39;.
<a name="line732"></a> */
<a name="line733"></a>goog.uri.utils.buildQueryDataFromMap = function(map) {
<a name="line734"></a>  var buffer = goog.uri.utils.buildQueryDataBufferFromMap_([], map);
<a name="line735"></a>  buffer[0] = &#39;&#39;;
<a name="line736"></a>  return buffer.join(&#39;&#39;);
<a name="line737"></a>};
<a name="line738"></a>
<a name="line739"></a>
<a name="line740"></a>/**
<a name="line741"></a> * Appends URI parameters to an existing URI.
<a name="line742"></a> *
<a name="line743"></a> * The variable arguments may contain alternating keys and values.  Keys are
<a name="line744"></a> * assumed to be already URI encoded.  The values should not be URI-encoded,
<a name="line745"></a> * and will instead be encoded by this function.
<a name="line746"></a> * &lt;pre&gt;
<a name="line747"></a> * appendParams(&#39;http://www.foo.com?existing=true&#39;,
<a name="line748"></a> *     &#39;key1&#39;, &#39;value1&#39;,
<a name="line749"></a> *     &#39;key2&#39;, &#39;value?willBeEncoded&#39;,
<a name="line750"></a> *     &#39;key3&#39;, [&#39;valueA&#39;, &#39;valueB&#39;, &#39;valueC&#39;],
<a name="line751"></a> *     &#39;key4&#39;, null);
<a name="line752"></a> * result: &#39;http://www.foo.com?existing=true&amp;&#39; +
<a name="line753"></a> *     &#39;key1=value1&amp;&#39; +
<a name="line754"></a> *     &#39;key2=value%3FwillBeEncoded&amp;&#39; +
<a name="line755"></a> *     &#39;key3=valueA&amp;key3=valueB&amp;key3=valueC&#39;
<a name="line756"></a> * &lt;/pre&gt;
<a name="line757"></a> *
<a name="line758"></a> * A single call to this function will not exhibit quadratic behavior in IE,
<a name="line759"></a> * whereas multiple repeated calls may, although the effect is limited by
<a name="line760"></a> * fact that URL&#39;s generally can&#39;t exceed 2kb.
<a name="line761"></a> *
<a name="line762"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line763"></a> * @param {...(goog.uri.utils.QueryArray|string|goog.uri.utils.QueryValue)} var_args
<a name="line764"></a> *     An array or argument list conforming to goog.uri.utils.QueryArray.
<a name="line765"></a> * @return {string} The URI with all query parameters added.
<a name="line766"></a> */
<a name="line767"></a>goog.uri.utils.appendParams = function(uri, var_args) {
<a name="line768"></a>  return goog.uri.utils.appendQueryData_(
<a name="line769"></a>      arguments.length == 2 ?
<a name="line770"></a>      goog.uri.utils.buildQueryDataBuffer_([uri], arguments[1], 0) :
<a name="line771"></a>      goog.uri.utils.buildQueryDataBuffer_([uri], arguments, 1));
<a name="line772"></a>};
<a name="line773"></a>
<a name="line774"></a>
<a name="line775"></a>/**
<a name="line776"></a> * Appends query parameters from a map.
<a name="line777"></a> *
<a name="line778"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line779"></a> * @param {Object} map An object where keys are URI-encoded parameter keys,
<a name="line780"></a> *     and the values are arbitrary types or arrays.  Keys with a null value
<a name="line781"></a> *     are dropped.
<a name="line782"></a> * @return {string} The new parameters.
<a name="line783"></a> */
<a name="line784"></a>goog.uri.utils.appendParamsFromMap = function(uri, map) {
<a name="line785"></a>  return goog.uri.utils.appendQueryData_(
<a name="line786"></a>      goog.uri.utils.buildQueryDataBufferFromMap_([uri], map));
<a name="line787"></a>};
<a name="line788"></a>
<a name="line789"></a>
<a name="line790"></a>/**
<a name="line791"></a> * Appends a single URI parameter.
<a name="line792"></a> *
<a name="line793"></a> * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
<a name="line794"></a> * way string append works, though it should be limited given the 2kb limit.
<a name="line795"></a> *
<a name="line796"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line797"></a> * @param {string} key The key, which must already be URI encoded.
<a name="line798"></a> * @param {*=} opt_value The value, which will be stringized and encoded
<a name="line799"></a> *     (assumed not already to be encoded).  If omitted, undefined, or null, the
<a name="line800"></a> *     key will be added as a valueless parameter.
<a name="line801"></a> * @return {string} The URI with the query parameter added.
<a name="line802"></a> */
<a name="line803"></a>goog.uri.utils.appendParam = function(uri, key, opt_value) {
<a name="line804"></a>  var paramArr = [uri, &#39;&amp;&#39;, key];
<a name="line805"></a>  if (goog.isDefAndNotNull(opt_value)) {
<a name="line806"></a>    paramArr.push(&#39;=&#39;, goog.string.urlEncode(opt_value));
<a name="line807"></a>  }
<a name="line808"></a>  return goog.uri.utils.appendQueryData_(paramArr);
<a name="line809"></a>};
<a name="line810"></a>
<a name="line811"></a>
<a name="line812"></a>/**
<a name="line813"></a> * Finds the next instance of a query parameter with the specified name.
<a name="line814"></a> *
<a name="line815"></a> * Does not instantiate any objects.
<a name="line816"></a> *
<a name="line817"></a> * @param {string} uri The URI to search.  May contain a fragment identifier
<a name="line818"></a> *     if opt_hashIndex is specified.
<a name="line819"></a> * @param {number} startIndex The index to begin searching for the key at.  A
<a name="line820"></a> *     match may be found even if this is one character after the ampersand.
<a name="line821"></a> * @param {string} keyEncoded The URI-encoded key.
<a name="line822"></a> * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
<a name="line823"></a> *     mark is present, it should be its index, otherwise it should be the
<a name="line824"></a> *     length of the string.
<a name="line825"></a> * @return {number} The position of the first character in the key&#39;s name,
<a name="line826"></a> *     immediately after either a question mark or a dot.
<a name="line827"></a> * @private
<a name="line828"></a> */
<a name="line829"></a>goog.uri.utils.findParam_ = function(
<a name="line830"></a>    uri, startIndex, keyEncoded, hashOrEndIndex) {
<a name="line831"></a>  var index = startIndex;
<a name="line832"></a>  var keyLength = keyEncoded.length;
<a name="line833"></a>
<a name="line834"></a>  // Search for the key itself and post-filter for surronuding punctuation,
<a name="line835"></a>  // rather than expensively building a regexp.
<a name="line836"></a>  while ((index = uri.indexOf(keyEncoded, index)) &gt;= 0 &amp;&amp;
<a name="line837"></a>      index &lt; hashOrEndIndex) {
<a name="line838"></a>    var precedingChar = uri.charCodeAt(index - 1);
<a name="line839"></a>    // Ensure that the preceding character is &#39;&amp;&#39; or &#39;?&#39;.
<a name="line840"></a>    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
<a name="line841"></a>        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
<a name="line842"></a>      // Ensure the following character is &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, or NaN
<a name="line843"></a>      // (end of string).
<a name="line844"></a>      var followingChar = uri.charCodeAt(index + keyLength);
<a name="line845"></a>      if (!followingChar ||
<a name="line846"></a>          followingChar == goog.uri.utils.CharCode_.EQUAL ||
<a name="line847"></a>          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
<a name="line848"></a>          followingChar == goog.uri.utils.CharCode_.HASH) {
<a name="line849"></a>        return index;
<a name="line850"></a>      }
<a name="line851"></a>    }
<a name="line852"></a>    index += keyLength + 1;
<a name="line853"></a>  }
<a name="line854"></a>
<a name="line855"></a>  return -1;
<a name="line856"></a>};
<a name="line857"></a>
<a name="line858"></a>
<a name="line859"></a>/**
<a name="line860"></a> * Regular expression for finding a hash mark or end of string.
<a name="line861"></a> * @type {RegExp}
<a name="line862"></a> * @private
<a name="line863"></a> */
<a name="line864"></a>goog.uri.utils.hashOrEndRe_ = /#|$/;
<a name="line865"></a>
<a name="line866"></a>
<a name="line867"></a>/**
<a name="line868"></a> * Determines if the URI contains a specific key.
<a name="line869"></a> *
<a name="line870"></a> * Performs no object instantiations.
<a name="line871"></a> *
<a name="line872"></a> * @param {string} uri The URI to process.  May contain a fragment
<a name="line873"></a> *     identifier.
<a name="line874"></a> * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
<a name="line875"></a> * @return {boolean} Whether the key is present.
<a name="line876"></a> */
<a name="line877"></a>goog.uri.utils.hasParam = function(uri, keyEncoded) {
<a name="line878"></a>  return goog.uri.utils.findParam_(uri, 0, keyEncoded,
<a name="line879"></a>      uri.search(goog.uri.utils.hashOrEndRe_)) &gt;= 0;
<a name="line880"></a>};
<a name="line881"></a>
<a name="line882"></a>
<a name="line883"></a>/**
<a name="line884"></a> * Gets the first value of a query parameter.
<a name="line885"></a> * @param {string} uri The URI to process.  May contain a fragment.
<a name="line886"></a> * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
<a name="line887"></a> * @return {?string} The first value of the parameter (URI-decoded), or null
<a name="line888"></a> *     if the parameter is not found.
<a name="line889"></a> */
<a name="line890"></a>goog.uri.utils.getParamValue = function(uri, keyEncoded) {
<a name="line891"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line892"></a>  var foundIndex = goog.uri.utils.findParam_(
<a name="line893"></a>      uri, 0, keyEncoded, hashOrEndIndex);
<a name="line894"></a>
<a name="line895"></a>  if (foundIndex &lt; 0) {
<a name="line896"></a>    return null;
<a name="line897"></a>  } else {
<a name="line898"></a>    var endPosition = uri.indexOf(&#39;&amp;&#39;, foundIndex);
<a name="line899"></a>    if (endPosition &lt; 0 || endPosition &gt; hashOrEndIndex) {
<a name="line900"></a>      endPosition = hashOrEndIndex;
<a name="line901"></a>    }
<a name="line902"></a>    // Progress forth to the end of the &quot;key=&quot; or &quot;key&amp;&quot; substring.
<a name="line903"></a>    foundIndex += keyEncoded.length + 1;
<a name="line904"></a>    // Use substr, because it (unlike substring) will return empty string
<a name="line905"></a>    // if foundIndex &gt; endPosition.
<a name="line906"></a>    return goog.string.urlDecode(
<a name="line907"></a>        uri.substr(foundIndex, endPosition - foundIndex));
<a name="line908"></a>  }
<a name="line909"></a>};
<a name="line910"></a>
<a name="line911"></a>
<a name="line912"></a>/**
<a name="line913"></a> * Gets all values of a query parameter.
<a name="line914"></a> * @param {string} uri The URI to process.  May contain a framgnet.
<a name="line915"></a> * @param {string} keyEncoded The URI-encoded key.  Case-snsitive.
<a name="line916"></a> * @return {!Array.&lt;string&gt;} All URI-decoded values with the given key.
<a name="line917"></a> *     If the key is not found, this will have length 0, but never be null.
<a name="line918"></a> */
<a name="line919"></a>goog.uri.utils.getParamValues = function(uri, keyEncoded) {
<a name="line920"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line921"></a>  var position = 0;
<a name="line922"></a>  var foundIndex;
<a name="line923"></a>  var result = [];
<a name="line924"></a>
<a name="line925"></a>  while ((foundIndex = goog.uri.utils.findParam_(
<a name="line926"></a>      uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {
<a name="line927"></a>    // Find where this parameter ends, either the &#39;&amp;&#39; or the end of the
<a name="line928"></a>    // query parameters.
<a name="line929"></a>    position = uri.indexOf(&#39;&amp;&#39;, foundIndex);
<a name="line930"></a>    if (position &lt; 0 || position &gt; hashOrEndIndex) {
<a name="line931"></a>      position = hashOrEndIndex;
<a name="line932"></a>    }
<a name="line933"></a>
<a name="line934"></a>    // Progress forth to the end of the &quot;key=&quot; or &quot;key&amp;&quot; substring.
<a name="line935"></a>    foundIndex += keyEncoded.length + 1;
<a name="line936"></a>    // Use substr, because it (unlike substring) will return empty string
<a name="line937"></a>    // if foundIndex &gt; position.
<a name="line938"></a>    result.push(goog.string.urlDecode(uri.substr(
<a name="line939"></a>        foundIndex, position - foundIndex)));
<a name="line940"></a>  }
<a name="line941"></a>
<a name="line942"></a>  return result;
<a name="line943"></a>};
<a name="line944"></a>
<a name="line945"></a>
<a name="line946"></a>/**
<a name="line947"></a> * Regexp to find trailing question marks and ampersands.
<a name="line948"></a> * @type {RegExp}
<a name="line949"></a> * @private
<a name="line950"></a> */
<a name="line951"></a>goog.uri.utils.trailingQueryPunctuationRe_ = /[?&amp;]($|#)/;
<a name="line952"></a>
<a name="line953"></a>
<a name="line954"></a>/**
<a name="line955"></a> * Removes all instances of a query parameter.
<a name="line956"></a> * @param {string} uri The URI to process.  Must not contain a fragment.
<a name="line957"></a> * @param {string} keyEncoded The URI-encoded key.
<a name="line958"></a> * @return {string} The URI with all instances of the parameter removed.
<a name="line959"></a> */
<a name="line960"></a>goog.uri.utils.removeParam = function(uri, keyEncoded) {
<a name="line961"></a>  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
<a name="line962"></a>  var position = 0;
<a name="line963"></a>  var foundIndex;
<a name="line964"></a>  var buffer = [];
<a name="line965"></a>
<a name="line966"></a>  // Look for a query parameter.
<a name="line967"></a>  while ((foundIndex = goog.uri.utils.findParam_(
<a name="line968"></a>      uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {
<a name="line969"></a>    // Get the portion of the query string up to, but not including, the ?
<a name="line970"></a>    // or &amp; starting the parameter.
<a name="line971"></a>    buffer.push(uri.substring(position, foundIndex));
<a name="line972"></a>    // Progress to immediately after the &#39;&amp;&#39;.  If not found, go to the end.
<a name="line973"></a>    // Avoid including the hash mark.
<a name="line974"></a>    position = Math.min((uri.indexOf(&#39;&amp;&#39;, foundIndex) + 1) || hashOrEndIndex,
<a name="line975"></a>        hashOrEndIndex);
<a name="line976"></a>  }
<a name="line977"></a>
<a name="line978"></a>  // Append everything that is remaining.
<a name="line979"></a>  buffer.push(uri.substr(position));
<a name="line980"></a>
<a name="line981"></a>  // Join the buffer, and remove trailing punctuation that remains.
<a name="line982"></a>  return buffer.join(&#39;&#39;).replace(
<a name="line983"></a>      goog.uri.utils.trailingQueryPunctuationRe_, &#39;$1&#39;);
<a name="line984"></a>};
<a name="line985"></a>
<a name="line986"></a>
<a name="line987"></a>/**
<a name="line988"></a> * Replaces all existing definitions of a parameter with a single definition.
<a name="line989"></a> *
<a name="line990"></a> * Repeated calls to this can exhibit quadratic behavior due to the need to
<a name="line991"></a> * find existing instances and reconstruct the string, though it should be
<a name="line992"></a> * limited given the 2kb limit.  Consider using appendParams to append multiple
<a name="line993"></a> * parameters in bulk.
<a name="line994"></a> *
<a name="line995"></a> * @param {string} uri The original URI, which may already have query data.
<a name="line996"></a> * @param {string} keyEncoded The key, which must already be URI encoded.
<a name="line997"></a> * @param {*} value The value, which will be stringized and encoded (assumed
<a name="line998"></a> *     not already to be encoded).
<a name="line999"></a> * @return {string} The URI with the query parameter added.
<a name="line1000"></a> */
<a name="line1001"></a>goog.uri.utils.setParam = function(uri, keyEncoded, value) {
<a name="line1002"></a>  return goog.uri.utils.appendParam(
<a name="line1003"></a>      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
<a name="line1004"></a>};
<a name="line1005"></a>
<a name="line1006"></a>
<a name="line1007"></a>/**
<a name="line1008"></a> * Generates a URI path using a given URI and a path with checks to
<a name="line1009"></a> * prevent consecutive &quot;//&quot;. The baseUri passed in must not contain
<a name="line1010"></a> * query or fragment identifiers. The path to append may not contain query or
<a name="line1011"></a> * fragment identifiers.
<a name="line1012"></a> *
<a name="line1013"></a> * @param {string} baseUri URI to use as the base.
<a name="line1014"></a> * @param {string} path Path to append.
<a name="line1015"></a> * @return {string} Updated URI.
<a name="line1016"></a> */
<a name="line1017"></a>goog.uri.utils.appendPath = function(baseUri, path) {
<a name="line1018"></a>  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);
<a name="line1019"></a>
<a name="line1020"></a>  // Remove any trailing &#39;/&#39;
<a name="line1021"></a>  if (goog.string.endsWith(baseUri, &#39;/&#39;)) {
<a name="line1022"></a>    baseUri = baseUri.substr(0, baseUri.length - 1);
<a name="line1023"></a>  }
<a name="line1024"></a>  // Remove any leading &#39;/&#39;
<a name="line1025"></a>  if (goog.string.startsWith(path, &#39;/&#39;)) {
<a name="line1026"></a>    path = path.substr(1);
<a name="line1027"></a>  }
<a name="line1028"></a>  return goog.string.buildString(baseUri, &#39;/&#39;, path);
<a name="line1029"></a>};
<a name="line1030"></a>
<a name="line1031"></a>
<a name="line1032"></a>/**
<a name="line1033"></a> * Replaces the path.
<a name="line1034"></a> * @param {string} uri URI to use as the base.
<a name="line1035"></a> * @param {string} path New path.
<a name="line1036"></a> * @return {string} Updated URI.
<a name="line1037"></a> */
<a name="line1038"></a>goog.uri.utils.setPath = function(uri, path) {
<a name="line1039"></a>  // Add any missing &#39;/&#39;.
<a name="line1040"></a>  if (!goog.string.startsWith(path, &#39;/&#39;)) {
<a name="line1041"></a>    path = &#39;/&#39; + path;
<a name="line1042"></a>  }
<a name="line1043"></a>  var parts = goog.uri.utils.split(uri);
<a name="line1044"></a>  return goog.uri.utils.buildFromEncodedParts(
<a name="line1045"></a>      parts[goog.uri.utils.ComponentIndex.SCHEME],
<a name="line1046"></a>      parts[goog.uri.utils.ComponentIndex.USER_INFO],
<a name="line1047"></a>      parts[goog.uri.utils.ComponentIndex.DOMAIN],
<a name="line1048"></a>      parts[goog.uri.utils.ComponentIndex.PORT],
<a name="line1049"></a>      path,
<a name="line1050"></a>      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],
<a name="line1051"></a>      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);
<a name="line1052"></a>};
<a name="line1053"></a>
<a name="line1054"></a>
<a name="line1055"></a>/**
<a name="line1056"></a> * Standard supported query parameters.
<a name="line1057"></a> * @enum {string}
<a name="line1058"></a> */
<a name="line1059"></a>goog.uri.utils.StandardQueryParam = {
<a name="line1060"></a>
<a name="line1061"></a>  /** Unused parameter for unique-ifying. */
<a name="line1062"></a>  RANDOM: &#39;zx&#39;
<a name="line1063"></a>};
<a name="line1064"></a>
<a name="line1065"></a>
<a name="line1066"></a>/**
<a name="line1067"></a> * Sets the zx parameter of a URI to a random value.
<a name="line1068"></a> * @param {string} uri Any URI.
<a name="line1069"></a> * @return {string} That URI with the &quot;zx&quot; parameter added or replaced to
<a name="line1070"></a> *     contain a random string.
<a name="line1071"></a> */
<a name="line1072"></a>goog.uri.utils.makeUnique = function(uri) {
<a name="line1073"></a>  return goog.uri.utils.setParam(uri,
<a name="line1074"></a>      goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());
<a name="line1075"></a>};
</pre>


</body>
</html>
