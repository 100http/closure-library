<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>string.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="local_closure_goog_string_string.js.html">string.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2006 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Utilities for string manipulation.
<a name="line17"></a> * @author arv@google.com (Erik Arvidsson)
<a name="line18"></a> */
<a name="line19"></a>
<a name="line20"></a>
<a name="line21"></a>/**
<a name="line22"></a> * Namespace for string utilities
<a name="line23"></a> */
<a name="line24"></a>goog.provide(&#39;goog.string&#39;);
<a name="line25"></a>goog.provide(&#39;goog.string.Unicode&#39;);
<a name="line26"></a>
<a name="line27"></a>
<a name="line28"></a>/**
<a name="line29"></a> * @define {boolean} Enables HTML escaping of lowercase letter &quot;e&quot; which helps
<a name="line30"></a> * with detection of double-escaping as this letter is frequently used.
<a name="line31"></a> */
<a name="line32"></a>goog.define(&#39;goog.string.DETECT_DOUBLE_ESCAPING&#39;, false);
<a name="line33"></a>
<a name="line34"></a>
<a name="line35"></a>/**
<a name="line36"></a> * Common Unicode string characters.
<a name="line37"></a> * @enum {string}
<a name="line38"></a> */
<a name="line39"></a>goog.string.Unicode = {
<a name="line40"></a>  NBSP: &#39;\xa0&#39;
<a name="line41"></a>};
<a name="line42"></a>
<a name="line43"></a>
<a name="line44"></a>/**
<a name="line45"></a> * Fast prefix-checker.
<a name="line46"></a> * @param {string} str The string to check.
<a name="line47"></a> * @param {string} prefix A string to look for at the start of {@code str}.
<a name="line48"></a> * @return {boolean} True if {@code str} begins with {@code prefix}.
<a name="line49"></a> */
<a name="line50"></a>goog.string.startsWith = function(str, prefix) {
<a name="line51"></a>  return str.lastIndexOf(prefix, 0) == 0;
<a name="line52"></a>};
<a name="line53"></a>
<a name="line54"></a>
<a name="line55"></a>/**
<a name="line56"></a> * Fast suffix-checker.
<a name="line57"></a> * @param {string} str The string to check.
<a name="line58"></a> * @param {string} suffix A string to look for at the end of {@code str}.
<a name="line59"></a> * @return {boolean} True if {@code str} ends with {@code suffix}.
<a name="line60"></a> */
<a name="line61"></a>goog.string.endsWith = function(str, suffix) {
<a name="line62"></a>  var l = str.length - suffix.length;
<a name="line63"></a>  return l &gt;= 0 &amp;&amp; str.indexOf(suffix, l) == l;
<a name="line64"></a>};
<a name="line65"></a>
<a name="line66"></a>
<a name="line67"></a>/**
<a name="line68"></a> * Case-insensitive prefix-checker.
<a name="line69"></a> * @param {string} str The string to check.
<a name="line70"></a> * @param {string} prefix  A string to look for at the end of {@code str}.
<a name="line71"></a> * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
<a name="line72"></a> *     case).
<a name="line73"></a> */
<a name="line74"></a>goog.string.caseInsensitiveStartsWith = function(str, prefix) {
<a name="line75"></a>  return goog.string.caseInsensitiveCompare(
<a name="line76"></a>      prefix, str.substr(0, prefix.length)) == 0;
<a name="line77"></a>};
<a name="line78"></a>
<a name="line79"></a>
<a name="line80"></a>/**
<a name="line81"></a> * Case-insensitive suffix-checker.
<a name="line82"></a> * @param {string} str The string to check.
<a name="line83"></a> * @param {string} suffix A string to look for at the end of {@code str}.
<a name="line84"></a> * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
<a name="line85"></a> *     case).
<a name="line86"></a> */
<a name="line87"></a>goog.string.caseInsensitiveEndsWith = function(str, suffix) {
<a name="line88"></a>  return goog.string.caseInsensitiveCompare(
<a name="line89"></a>      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
<a name="line90"></a>};
<a name="line91"></a>
<a name="line92"></a>
<a name="line93"></a>/**
<a name="line94"></a> * Case-insensitive equality checker.
<a name="line95"></a> * @param {string} str1 First string to check.
<a name="line96"></a> * @param {string} str2 Second string to check.
<a name="line97"></a> * @return {boolean} True if {@code str1} and {@code str2} are the same string,
<a name="line98"></a> *     ignoring case.
<a name="line99"></a> */
<a name="line100"></a>goog.string.caseInsensitiveEquals = function(str1, str2) {
<a name="line101"></a>  return str1.toLowerCase() == str2.toLowerCase();
<a name="line102"></a>};
<a name="line103"></a>
<a name="line104"></a>
<a name="line105"></a>/**
<a name="line106"></a> * Does simple python-style string substitution.
<a name="line107"></a> * subs(&quot;foo%s hot%s&quot;, &quot;bar&quot;, &quot;dog&quot;) becomes &quot;foobar hotdog&quot;.
<a name="line108"></a> * @param {string} str The string containing the pattern.
<a name="line109"></a> * @param {...*} var_args The items to substitute into the pattern.
<a name="line110"></a> * @return {string} A copy of {@code str} in which each occurrence of
<a name="line111"></a> *     {@code %s} has been replaced an argument from {@code var_args}.
<a name="line112"></a> */
<a name="line113"></a>goog.string.subs = function(str, var_args) {
<a name="line114"></a>  var splitParts = str.split(&#39;%s&#39;);
<a name="line115"></a>  var returnString = &#39;&#39;;
<a name="line116"></a>
<a name="line117"></a>  var subsArguments = Array.prototype.slice.call(arguments, 1);
<a name="line118"></a>  while (subsArguments.length &amp;&amp;
<a name="line119"></a>         // Replace up to the last split part. We are inserting in the
<a name="line120"></a>         // positions between split parts.
<a name="line121"></a>         splitParts.length &gt; 1) {
<a name="line122"></a>    returnString += splitParts.shift() + subsArguments.shift();
<a name="line123"></a>  }
<a name="line124"></a>
<a name="line125"></a>  return returnString + splitParts.join(&#39;%s&#39;); // Join unused &#39;%s&#39;
<a name="line126"></a>};
<a name="line127"></a>
<a name="line128"></a>
<a name="line129"></a>/**
<a name="line130"></a> * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
<a name="line131"></a> * and tabs) to a single space, and strips leading and trailing whitespace.
<a name="line132"></a> * @param {string} str Input string.
<a name="line133"></a> * @return {string} A copy of {@code str} with collapsed whitespace.
<a name="line134"></a> */
<a name="line135"></a>goog.string.collapseWhitespace = function(str) {
<a name="line136"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line137"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line138"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line139"></a>  return str.replace(/[\s\xa0]+/g, &#39; &#39;).replace(/^\s+|\s+$/g, &#39;&#39;);
<a name="line140"></a>};
<a name="line141"></a>
<a name="line142"></a>
<a name="line143"></a>/**
<a name="line144"></a> * Checks if a string is empty or contains only whitespaces.
<a name="line145"></a> * @param {string} str The string to check.
<a name="line146"></a> * @return {boolean} True if {@code str} is empty or whitespace only.
<a name="line147"></a> */
<a name="line148"></a>goog.string.isEmpty = function(str) {
<a name="line149"></a>  // testing length == 0 first is actually slower in all browsers (about the
<a name="line150"></a>  // same in Opera).
<a name="line151"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line152"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line153"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line154"></a>  return /^[\s\xa0]*$/.test(str);
<a name="line155"></a>};
<a name="line156"></a>
<a name="line157"></a>
<a name="line158"></a>/**
<a name="line159"></a> * Checks if a string is null, undefined, empty or contains only whitespaces.
<a name="line160"></a> * @param {*} str The string to check.
<a name="line161"></a> * @return {boolean} True if{@code str} is null, undefined, empty, or
<a name="line162"></a> *     whitespace only.
<a name="line163"></a> */
<a name="line164"></a>goog.string.isEmptySafe = function(str) {
<a name="line165"></a>  return goog.string.isEmpty(goog.string.makeSafe(str));
<a name="line166"></a>};
<a name="line167"></a>
<a name="line168"></a>
<a name="line169"></a>/**
<a name="line170"></a> * Checks if a string is all breaking whitespace.
<a name="line171"></a> * @param {string} str The string to check.
<a name="line172"></a> * @return {boolean} Whether the string is all breaking whitespace.
<a name="line173"></a> */
<a name="line174"></a>goog.string.isBreakingWhitespace = function(str) {
<a name="line175"></a>  return !/[^\t\n\r ]/.test(str);
<a name="line176"></a>};
<a name="line177"></a>
<a name="line178"></a>
<a name="line179"></a>/**
<a name="line180"></a> * Checks if a string contains all letters.
<a name="line181"></a> * @param {string} str string to check.
<a name="line182"></a> * @return {boolean} True if {@code str} consists entirely of letters.
<a name="line183"></a> */
<a name="line184"></a>goog.string.isAlpha = function(str) {
<a name="line185"></a>  return !/[^a-zA-Z]/.test(str);
<a name="line186"></a>};
<a name="line187"></a>
<a name="line188"></a>
<a name="line189"></a>/**
<a name="line190"></a> * Checks if a string contains only numbers.
<a name="line191"></a> * @param {*} str string to check. If not a string, it will be
<a name="line192"></a> *     casted to one.
<a name="line193"></a> * @return {boolean} True if {@code str} is numeric.
<a name="line194"></a> */
<a name="line195"></a>goog.string.isNumeric = function(str) {
<a name="line196"></a>  return !/[^0-9]/.test(str);
<a name="line197"></a>};
<a name="line198"></a>
<a name="line199"></a>
<a name="line200"></a>/**
<a name="line201"></a> * Checks if a string contains only numbers or letters.
<a name="line202"></a> * @param {string} str string to check.
<a name="line203"></a> * @return {boolean} True if {@code str} is alphanumeric.
<a name="line204"></a> */
<a name="line205"></a>goog.string.isAlphaNumeric = function(str) {
<a name="line206"></a>  return !/[^a-zA-Z0-9]/.test(str);
<a name="line207"></a>};
<a name="line208"></a>
<a name="line209"></a>
<a name="line210"></a>/**
<a name="line211"></a> * Checks if a character is a space character.
<a name="line212"></a> * @param {string} ch Character to check.
<a name="line213"></a> * @return {boolean} True if {code ch} is a space.
<a name="line214"></a> */
<a name="line215"></a>goog.string.isSpace = function(ch) {
<a name="line216"></a>  return ch == &#39; &#39;;
<a name="line217"></a>};
<a name="line218"></a>
<a name="line219"></a>
<a name="line220"></a>/**
<a name="line221"></a> * Checks if a character is a valid unicode character.
<a name="line222"></a> * @param {string} ch Character to check.
<a name="line223"></a> * @return {boolean} True if {code ch} is a valid unicode character.
<a name="line224"></a> */
<a name="line225"></a>goog.string.isUnicodeChar = function(ch) {
<a name="line226"></a>  return ch.length == 1 &amp;&amp; ch &gt;= &#39; &#39; &amp;&amp; ch &lt;= &#39;~&#39; ||
<a name="line227"></a>         ch &gt;= &#39;\u0080&#39; &amp;&amp; ch &lt;= &#39;\uFFFD&#39;;
<a name="line228"></a>};
<a name="line229"></a>
<a name="line230"></a>
<a name="line231"></a>/**
<a name="line232"></a> * Takes a string and replaces newlines with a space. Multiple lines are
<a name="line233"></a> * replaced with a single space.
<a name="line234"></a> * @param {string} str The string from which to strip newlines.
<a name="line235"></a> * @return {string} A copy of {@code str} stripped of newlines.
<a name="line236"></a> */
<a name="line237"></a>goog.string.stripNewlines = function(str) {
<a name="line238"></a>  return str.replace(/(\r\n|\r|\n)+/g, &#39; &#39;);
<a name="line239"></a>};
<a name="line240"></a>
<a name="line241"></a>
<a name="line242"></a>/**
<a name="line243"></a> * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
<a name="line244"></a> * @param {string} str The string to in which to canonicalize newlines.
<a name="line245"></a> * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
<a name="line246"></a> */
<a name="line247"></a>goog.string.canonicalizeNewlines = function(str) {
<a name="line248"></a>  return str.replace(/(\r\n|\r|\n)/g, &#39;\n&#39;);
<a name="line249"></a>};
<a name="line250"></a>
<a name="line251"></a>
<a name="line252"></a>/**
<a name="line253"></a> * Normalizes whitespace in a string, replacing all whitespace chars with
<a name="line254"></a> * a space.
<a name="line255"></a> * @param {string} str The string in which to normalize whitespace.
<a name="line256"></a> * @return {string} A copy of {@code str} with all whitespace normalized.
<a name="line257"></a> */
<a name="line258"></a>goog.string.normalizeWhitespace = function(str) {
<a name="line259"></a>  return str.replace(/\xa0|\s/g, &#39; &#39;);
<a name="line260"></a>};
<a name="line261"></a>
<a name="line262"></a>
<a name="line263"></a>/**
<a name="line264"></a> * Normalizes spaces in a string, replacing all consecutive spaces and tabs
<a name="line265"></a> * with a single space. Replaces non-breaking space with a space.
<a name="line266"></a> * @param {string} str The string in which to normalize spaces.
<a name="line267"></a> * @return {string} A copy of {@code str} with all consecutive spaces and tabs
<a name="line268"></a> *    replaced with a single space.
<a name="line269"></a> */
<a name="line270"></a>goog.string.normalizeSpaces = function(str) {
<a name="line271"></a>  return str.replace(/\xa0|[ \t]+/g, &#39; &#39;);
<a name="line272"></a>};
<a name="line273"></a>
<a name="line274"></a>
<a name="line275"></a>/**
<a name="line276"></a> * Removes the breaking spaces from the left and right of the string and
<a name="line277"></a> * collapses the sequences of breaking spaces in the middle into single spaces.
<a name="line278"></a> * The original and the result strings render the same way in HTML.
<a name="line279"></a> * @param {string} str A string in which to collapse spaces.
<a name="line280"></a> * @return {string} Copy of the string with normalized breaking spaces.
<a name="line281"></a> */
<a name="line282"></a>goog.string.collapseBreakingSpaces = function(str) {
<a name="line283"></a>  return str.replace(/[\t\r\n ]+/g, &#39; &#39;).replace(
<a name="line284"></a>      /^[\t\r\n ]+|[\t\r\n ]+$/g, &#39;&#39;);
<a name="line285"></a>};
<a name="line286"></a>
<a name="line287"></a>
<a name="line288"></a>/**
<a name="line289"></a> * Trims white spaces to the left and right of a string.
<a name="line290"></a> * @param {string} str The string to trim.
<a name="line291"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line292"></a> */
<a name="line293"></a>goog.string.trim = function(str) {
<a name="line294"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line295"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line296"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line297"></a>  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, &#39;&#39;);
<a name="line298"></a>};
<a name="line299"></a>
<a name="line300"></a>
<a name="line301"></a>/**
<a name="line302"></a> * Trims whitespaces at the left end of a string.
<a name="line303"></a> * @param {string} str The string to left trim.
<a name="line304"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line305"></a> */
<a name="line306"></a>goog.string.trimLeft = function(str) {
<a name="line307"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line308"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line309"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line310"></a>  return str.replace(/^[\s\xa0]+/, &#39;&#39;);
<a name="line311"></a>};
<a name="line312"></a>
<a name="line313"></a>
<a name="line314"></a>/**
<a name="line315"></a> * Trims whitespaces at the right end of a string.
<a name="line316"></a> * @param {string} str The string to right trim.
<a name="line317"></a> * @return {string} A trimmed copy of {@code str}.
<a name="line318"></a> */
<a name="line319"></a>goog.string.trimRight = function(str) {
<a name="line320"></a>  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \s character
<a name="line321"></a>  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
<a name="line322"></a>  // include it in the regexp to enforce consistent cross-browser behavior.
<a name="line323"></a>  return str.replace(/[\s\xa0]+$/, &#39;&#39;);
<a name="line324"></a>};
<a name="line325"></a>
<a name="line326"></a>
<a name="line327"></a>/**
<a name="line328"></a> * A string comparator that ignores case.
<a name="line329"></a> * -1 = str1 less than str2
<a name="line330"></a> *  0 = str1 equals str2
<a name="line331"></a> *  1 = str1 greater than str2
<a name="line332"></a> *
<a name="line333"></a> * @param {string} str1 The string to compare.
<a name="line334"></a> * @param {string} str2 The string to compare {@code str1} to.
<a name="line335"></a> * @return {number} The comparator result, as described above.
<a name="line336"></a> */
<a name="line337"></a>goog.string.caseInsensitiveCompare = function(str1, str2) {
<a name="line338"></a>  var test1 = String(str1).toLowerCase();
<a name="line339"></a>  var test2 = String(str2).toLowerCase();
<a name="line340"></a>
<a name="line341"></a>  if (test1 &lt; test2) {
<a name="line342"></a>    return -1;
<a name="line343"></a>  } else if (test1 == test2) {
<a name="line344"></a>    return 0;
<a name="line345"></a>  } else {
<a name="line346"></a>    return 1;
<a name="line347"></a>  }
<a name="line348"></a>};
<a name="line349"></a>
<a name="line350"></a>
<a name="line351"></a>/**
<a name="line352"></a> * Regular expression used for splitting a string into substrings of fractional
<a name="line353"></a> * numbers, integers, and non-numeric characters.
<a name="line354"></a> * @type {RegExp}
<a name="line355"></a> * @private
<a name="line356"></a> */
<a name="line357"></a>goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
<a name="line358"></a>
<a name="line359"></a>
<a name="line360"></a>/**
<a name="line361"></a> * String comparison function that handles numbers in a way humans might expect.
<a name="line362"></a> * Using this function, the string &quot;File 2.jpg&quot; sorts before &quot;File 10.jpg&quot;. The
<a name="line363"></a> * comparison is mostly case-insensitive, though strings that are identical
<a name="line364"></a> * except for case are sorted with the upper-case strings before lower-case.
<a name="line365"></a> *
<a name="line366"></a> * This comparison function is significantly slower (about 500x) than either
<a name="line367"></a> * the default or the case-insensitive compare. It should not be used in
<a name="line368"></a> * time-critical code, but should be fast enough to sort several hundred short
<a name="line369"></a> * strings (like filenames) with a reasonable delay.
<a name="line370"></a> *
<a name="line371"></a> * @param {string} str1 The string to compare in a numerically sensitive way.
<a name="line372"></a> * @param {string} str2 The string to compare {@code str1} to.
<a name="line373"></a> * @return {number} less than 0 if str1 &lt; str2, 0 if str1 == str2, greater than
<a name="line374"></a> *     0 if str1 &gt; str2.
<a name="line375"></a> */
<a name="line376"></a>goog.string.numerateCompare = function(str1, str2) {
<a name="line377"></a>  if (str1 == str2) {
<a name="line378"></a>    return 0;
<a name="line379"></a>  }
<a name="line380"></a>  if (!str1) {
<a name="line381"></a>    return -1;
<a name="line382"></a>  }
<a name="line383"></a>  if (!str2) {
<a name="line384"></a>    return 1;
<a name="line385"></a>  }
<a name="line386"></a>
<a name="line387"></a>  // Using match to split the entire string ahead of time turns out to be faster
<a name="line388"></a>  // for most inputs than using RegExp.exec or iterating over each character.
<a name="line389"></a>  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
<a name="line390"></a>  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);
<a name="line391"></a>
<a name="line392"></a>  var count = Math.min(tokens1.length, tokens2.length);
<a name="line393"></a>
<a name="line394"></a>  for (var i = 0; i &lt; count; i++) {
<a name="line395"></a>    var a = tokens1[i];
<a name="line396"></a>    var b = tokens2[i];
<a name="line397"></a>
<a name="line398"></a>    // Compare pairs of tokens, returning if one token sorts before the other.
<a name="line399"></a>    if (a != b) {
<a name="line400"></a>
<a name="line401"></a>      // Only if both tokens are integers is a special comparison required.
<a name="line402"></a>      // Decimal numbers are sorted as strings (e.g., &#39;.09&#39; &lt; &#39;.1&#39;).
<a name="line403"></a>      var num1 = parseInt(a, 10);
<a name="line404"></a>      if (!isNaN(num1)) {
<a name="line405"></a>        var num2 = parseInt(b, 10);
<a name="line406"></a>        if (!isNaN(num2) &amp;&amp; num1 - num2) {
<a name="line407"></a>          return num1 - num2;
<a name="line408"></a>        }
<a name="line409"></a>      }
<a name="line410"></a>      return a &lt; b ? -1 : 1;
<a name="line411"></a>    }
<a name="line412"></a>  }
<a name="line413"></a>
<a name="line414"></a>  // If one string is a substring of the other, the shorter string sorts first.
<a name="line415"></a>  if (tokens1.length != tokens2.length) {
<a name="line416"></a>    return tokens1.length - tokens2.length;
<a name="line417"></a>  }
<a name="line418"></a>
<a name="line419"></a>  // The two strings must be equivalent except for case (perfect equality is
<a name="line420"></a>  // tested at the head of the function.) Revert to default ASCII-betical string
<a name="line421"></a>  // comparison to stablize the sort.
<a name="line422"></a>  return str1 &lt; str2 ? -1 : 1;
<a name="line423"></a>};
<a name="line424"></a>
<a name="line425"></a>
<a name="line426"></a>/**
<a name="line427"></a> * URL-encodes a string
<a name="line428"></a> * @param {*} str The string to url-encode.
<a name="line429"></a> * @return {string} An encoded copy of {@code str} that is safe for urls.
<a name="line430"></a> *     Note that &#39;#&#39;, &#39;:&#39;, and other characters used to delimit portions
<a name="line431"></a> *     of URLs *will* be encoded.
<a name="line432"></a> */
<a name="line433"></a>goog.string.urlEncode = function(str) {
<a name="line434"></a>  return encodeURIComponent(String(str));
<a name="line435"></a>};
<a name="line436"></a>
<a name="line437"></a>
<a name="line438"></a>/**
<a name="line439"></a> * URL-decodes the string. We need to specially handle &#39;+&#39;s because
<a name="line440"></a> * the javascript library doesn&#39;t convert them to spaces.
<a name="line441"></a> * @param {string} str The string to url decode.
<a name="line442"></a> * @return {string} The decoded {@code str}.
<a name="line443"></a> */
<a name="line444"></a>goog.string.urlDecode = function(str) {
<a name="line445"></a>  return decodeURIComponent(str.replace(/\+/g, &#39; &#39;));
<a name="line446"></a>};
<a name="line447"></a>
<a name="line448"></a>
<a name="line449"></a>/**
<a name="line450"></a> * Converts \n to &lt;br&gt;s or &lt;br /&gt;s.
<a name="line451"></a> * @param {string} str The string in which to convert newlines.
<a name="line452"></a> * @param {boolean=} opt_xml Whether to use XML compatible tags.
<a name="line453"></a> * @return {string} A copy of {@code str} with converted newlines.
<a name="line454"></a> */
<a name="line455"></a>goog.string.newLineToBr = function(str, opt_xml) {
<a name="line456"></a>  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? &#39;&lt;br /&gt;&#39; : &#39;&lt;br&gt;&#39;);
<a name="line457"></a>};
<a name="line458"></a>
<a name="line459"></a>
<a name="line460"></a>/**
<a name="line461"></a> * Escapes double quote &#39;&quot;&#39; and single quote &#39;\&#39;&#39; characters in addition to
<a name="line462"></a> * &#39;&amp;&#39;, &#39;&lt;&#39;, and &#39;&gt;&#39; so that a string can be included in an HTML tag attribute
<a name="line463"></a> * value within double or single quotes.
<a name="line464"></a> *
<a name="line465"></a> * It should be noted that &gt; doesn&#39;t need to be escaped for the HTML or XML to
<a name="line466"></a> * be valid, but it has been decided to escape it for consistency with other
<a name="line467"></a> * implementations.
<a name="line468"></a> *
<a name="line469"></a> * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
<a name="line470"></a> * lowercase letter &quot;e&quot;.
<a name="line471"></a> *
<a name="line472"></a> * NOTE(user):
<a name="line473"></a> * HtmlEscape is often called during the generation of large blocks of HTML.
<a name="line474"></a> * Using statics for the regular expressions and strings is an optimization
<a name="line475"></a> * that can more than half the amount of time IE spends in this function for
<a name="line476"></a> * large apps, since strings and regexes both contribute to GC allocations.
<a name="line477"></a> *
<a name="line478"></a> * Testing for the presence of a character before escaping increases the number
<a name="line479"></a> * of function calls, but actually provides a speed increase for the average
<a name="line480"></a> * case -- since the average case often doesn&#39;t require the escaping of all 4
<a name="line481"></a> * characters and indexOf() is much cheaper than replace().
<a name="line482"></a> * The worst case does suffer slightly from the additional calls, therefore the
<a name="line483"></a> * opt_isLikelyToContainHtmlChars option has been included for situations
<a name="line484"></a> * where all 4 HTML entities are very likely to be present and need escaping.
<a name="line485"></a> *
<a name="line486"></a> * Some benchmarks (times tended to fluctuate +-0.05ms):
<a name="line487"></a> *                                     FireFox                     IE6
<a name="line488"></a> * (no chars / average (mix of cases) / all 4 chars)
<a name="line489"></a> * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
<a name="line490"></a> * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
<a name="line491"></a> * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
<a name="line492"></a> *
<a name="line493"></a> * An additional advantage of checking if replace actually needs to be called
<a name="line494"></a> * is a reduction in the number of object allocations, so as the size of the
<a name="line495"></a> * application grows the difference between the various methods would increase.
<a name="line496"></a> *
<a name="line497"></a> * @param {string} str string to be escaped.
<a name="line498"></a> * @param {boolean=} opt_isLikelyToContainHtmlChars Don&#39;t perform a check to see
<a name="line499"></a> *     if the character needs replacing - use this option if you expect each of
<a name="line500"></a> *     the characters to appear often. Leave false if you expect few html
<a name="line501"></a> *     characters to occur in your strings, such as if you are escaping HTML.
<a name="line502"></a> * @return {string} An escaped copy of {@code str}.
<a name="line503"></a> */
<a name="line504"></a>goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {
<a name="line505"></a>
<a name="line506"></a>  if (opt_isLikelyToContainHtmlChars) {
<a name="line507"></a>    str = str.replace(goog.string.AMP_RE_, &#39;&amp;amp;&#39;)
<a name="line508"></a>          .replace(goog.string.LT_RE_, &#39;&amp;lt;&#39;)
<a name="line509"></a>          .replace(goog.string.GT_RE_, &#39;&amp;gt;&#39;)
<a name="line510"></a>          .replace(goog.string.QUOT_RE_, &#39;&amp;quot;&#39;)
<a name="line511"></a>          .replace(goog.string.SINGLE_QUOTE_RE_, &#39;&amp;#39;&#39;)
<a name="line512"></a>          .replace(goog.string.NULL_RE_, &#39;&amp;#0;&#39;);
<a name="line513"></a>    if (goog.string.DETECT_DOUBLE_ESCAPING) {
<a name="line514"></a>      str = str.replace(goog.string.E_RE_, &#39;&amp;#101;&#39;);
<a name="line515"></a>    }
<a name="line516"></a>    return str;
<a name="line517"></a>
<a name="line518"></a>  } else {
<a name="line519"></a>    // quick test helps in the case when there are no chars to replace, in
<a name="line520"></a>    // worst case this makes barely a difference to the time taken
<a name="line521"></a>    if (!goog.string.ALL_RE_.test(str)) return str;
<a name="line522"></a>
<a name="line523"></a>    // str.indexOf is faster than regex.test in this case
<a name="line524"></a>    if (str.indexOf(&#39;&amp;&#39;) != -1) {
<a name="line525"></a>      str = str.replace(goog.string.AMP_RE_, &#39;&amp;amp;&#39;);
<a name="line526"></a>    }
<a name="line527"></a>    if (str.indexOf(&#39;&lt;&#39;) != -1) {
<a name="line528"></a>      str = str.replace(goog.string.LT_RE_, &#39;&amp;lt;&#39;);
<a name="line529"></a>    }
<a name="line530"></a>    if (str.indexOf(&#39;&gt;&#39;) != -1) {
<a name="line531"></a>      str = str.replace(goog.string.GT_RE_, &#39;&amp;gt;&#39;);
<a name="line532"></a>    }
<a name="line533"></a>    if (str.indexOf(&#39;&quot;&#39;) != -1) {
<a name="line534"></a>      str = str.replace(goog.string.QUOT_RE_, &#39;&amp;quot;&#39;);
<a name="line535"></a>    }
<a name="line536"></a>    if (str.indexOf(&#39;\&#39;&#39;) != -1) {
<a name="line537"></a>      str = str.replace(goog.string.SINGLE_QUOTE_RE_, &#39;&amp;#39;&#39;);
<a name="line538"></a>    }
<a name="line539"></a>    if (str.indexOf(&#39;\x00&#39;) != -1) {
<a name="line540"></a>      str = str.replace(goog.string.NULL_RE_, &#39;&amp;#0;&#39;);
<a name="line541"></a>    }
<a name="line542"></a>    if (goog.string.DETECT_DOUBLE_ESCAPING &amp;&amp; str.indexOf(&#39;e&#39;) != -1) {
<a name="line543"></a>      str = str.replace(goog.string.E_RE_, &#39;&amp;#101;&#39;);
<a name="line544"></a>    }
<a name="line545"></a>    return str;
<a name="line546"></a>  }
<a name="line547"></a>};
<a name="line548"></a>
<a name="line549"></a>
<a name="line550"></a>/**
<a name="line551"></a> * Regular expression that matches an ampersand, for use in escaping.
<a name="line552"></a> * @const {!RegExp}
<a name="line553"></a> * @private
<a name="line554"></a> */
<a name="line555"></a>goog.string.AMP_RE_ = /&amp;/g;
<a name="line556"></a>
<a name="line557"></a>
<a name="line558"></a>/**
<a name="line559"></a> * Regular expression that matches a less than sign, for use in escaping.
<a name="line560"></a> * @const {!RegExp}
<a name="line561"></a> * @private
<a name="line562"></a> */
<a name="line563"></a>goog.string.LT_RE_ = /&lt;/g;
<a name="line564"></a>
<a name="line565"></a>
<a name="line566"></a>/**
<a name="line567"></a> * Regular expression that matches a greater than sign, for use in escaping.
<a name="line568"></a> * @const {!RegExp}
<a name="line569"></a> * @private
<a name="line570"></a> */
<a name="line571"></a>goog.string.GT_RE_ = /&gt;/g;
<a name="line572"></a>
<a name="line573"></a>
<a name="line574"></a>/**
<a name="line575"></a> * Regular expression that matches a double quote, for use in escaping.
<a name="line576"></a> * @const {!RegExp}
<a name="line577"></a> * @private
<a name="line578"></a> */
<a name="line579"></a>goog.string.QUOT_RE_ = /&quot;/g;
<a name="line580"></a>
<a name="line581"></a>
<a name="line582"></a>/**
<a name="line583"></a> * Regular expression that matches a single quote, for use in escaping.
<a name="line584"></a> * @const {!RegExp}
<a name="line585"></a> * @private
<a name="line586"></a> */
<a name="line587"></a>goog.string.SINGLE_QUOTE_RE_ = /&#39;/g;
<a name="line588"></a>
<a name="line589"></a>
<a name="line590"></a>/**
<a name="line591"></a> * Regular expression that matches null character, for use in escaping.
<a name="line592"></a> * @const {!RegExp}
<a name="line593"></a> * @private
<a name="line594"></a> */
<a name="line595"></a>goog.string.NULL_RE_ = /\x00/g;
<a name="line596"></a>
<a name="line597"></a>
<a name="line598"></a>/**
<a name="line599"></a> * Regular expression that matches a lowercase letter &quot;e&quot;, for use in escaping.
<a name="line600"></a> * @const {!RegExp}
<a name="line601"></a> * @private
<a name="line602"></a> */
<a name="line603"></a>goog.string.E_RE_ = /e/g;
<a name="line604"></a>
<a name="line605"></a>
<a name="line606"></a>/**
<a name="line607"></a> * Regular expression that matches any character that needs to be escaped.
<a name="line608"></a> * @const {!RegExp}
<a name="line609"></a> * @private
<a name="line610"></a> */
<a name="line611"></a>goog.string.ALL_RE_ = (goog.string.DETECT_DOUBLE_ESCAPING ?
<a name="line612"></a>    /[\x00&amp;&lt;&gt;&quot;&#39;e]/ :
<a name="line613"></a>    /[\x00&amp;&lt;&gt;&quot;&#39;]/);
<a name="line614"></a>
<a name="line615"></a>
<a name="line616"></a>/**
<a name="line617"></a> * Unescapes an HTML string.
<a name="line618"></a> *
<a name="line619"></a> * @param {string} str The string to unescape.
<a name="line620"></a> * @return {string} An unescaped copy of {@code str}.
<a name="line621"></a> */
<a name="line622"></a>goog.string.unescapeEntities = function(str) {
<a name="line623"></a>  if (goog.string.contains(str, &#39;&amp;&#39;)) {
<a name="line624"></a>    // We are careful not to use a DOM if we do not have one. We use the []
<a name="line625"></a>    // notation so that the JSCompiler will not complain about these objects and
<a name="line626"></a>    // fields in the case where we have no DOM.
<a name="line627"></a>    if (&#39;document&#39; in goog.global) {
<a name="line628"></a>      return goog.string.unescapeEntitiesUsingDom_(str);
<a name="line629"></a>    } else {
<a name="line630"></a>      // Fall back on pure XML entities
<a name="line631"></a>      return goog.string.unescapePureXmlEntities_(str);
<a name="line632"></a>    }
<a name="line633"></a>  }
<a name="line634"></a>  return str;
<a name="line635"></a>};
<a name="line636"></a>
<a name="line637"></a>
<a name="line638"></a>/**
<a name="line639"></a> * Unescapes a HTML string using the provided document.
<a name="line640"></a> *
<a name="line641"></a> * @param {string} str The string to unescape.
<a name="line642"></a> * @param {!Document} document A document to use in escaping the string.
<a name="line643"></a> * @return {string} An unescaped copy of {@code str}.
<a name="line644"></a> */
<a name="line645"></a>goog.string.unescapeEntitiesWithDocument = function(str, document) {
<a name="line646"></a>  if (goog.string.contains(str, &#39;&amp;&#39;)) {
<a name="line647"></a>    return goog.string.unescapeEntitiesUsingDom_(str, document);
<a name="line648"></a>  }
<a name="line649"></a>  return str;
<a name="line650"></a>};
<a name="line651"></a>
<a name="line652"></a>
<a name="line653"></a>/**
<a name="line654"></a> * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
<a name="line655"></a> * entities. This function is XSS-safe and whitespace-preserving.
<a name="line656"></a> * @private
<a name="line657"></a> * @param {string} str The string to unescape.
<a name="line658"></a> * @param {Document=} opt_document An optional document to use for creating
<a name="line659"></a> *     elements. If this is not specified then the default window.document
<a name="line660"></a> *     will be used.
<a name="line661"></a> * @return {string} The unescaped {@code str} string.
<a name="line662"></a> */
<a name="line663"></a>goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
<a name="line664"></a>  var seen = {&#39;&amp;amp;&#39;: &#39;&amp;&#39;, &#39;&amp;lt;&#39;: &#39;&lt;&#39;, &#39;&amp;gt;&#39;: &#39;&gt;&#39;, &#39;&amp;quot;&#39;: &#39;&quot;&#39;};
<a name="line665"></a>  var div;
<a name="line666"></a>  if (opt_document) {
<a name="line667"></a>    div = opt_document.createElement(&#39;div&#39;);
<a name="line668"></a>  } else {
<a name="line669"></a>    div = goog.global.document.createElement(&#39;div&#39;);
<a name="line670"></a>  }
<a name="line671"></a>  // Match as many valid entity characters as possible. If the actual entity
<a name="line672"></a>  // happens to be shorter, it will still work as innerHTML will return the
<a name="line673"></a>  // trailing characters unchanged. Since the entity characters do not include
<a name="line674"></a>  // open angle bracket, there is no chance of XSS from the innerHTML use.
<a name="line675"></a>  // Since no whitespace is passed to innerHTML, whitespace is preserved.
<a name="line676"></a>  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
<a name="line677"></a>    // Check for cached entity.
<a name="line678"></a>    var value = seen[s];
<a name="line679"></a>    if (value) {
<a name="line680"></a>      return value;
<a name="line681"></a>    }
<a name="line682"></a>    // Check for numeric entity.
<a name="line683"></a>    if (entity.charAt(0) == &#39;#&#39;) {
<a name="line684"></a>      // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex numbers.
<a name="line685"></a>      var n = Number(&#39;0&#39; + entity.substr(1));
<a name="line686"></a>      if (!isNaN(n)) {
<a name="line687"></a>        value = String.fromCharCode(n);
<a name="line688"></a>      }
<a name="line689"></a>    }
<a name="line690"></a>    // Fall back to innerHTML otherwise.
<a name="line691"></a>    if (!value) {
<a name="line692"></a>      // Append a non-entity character to avoid a bug in Webkit that parses
<a name="line693"></a>      // an invalid entity at the end of innerHTML text as the empty string.
<a name="line694"></a>      div.innerHTML = s + &#39; &#39;;
<a name="line695"></a>      // Then remove the trailing character from the result.
<a name="line696"></a>      value = div.firstChild.nodeValue.slice(0, -1);
<a name="line697"></a>    }
<a name="line698"></a>    // Cache and return.
<a name="line699"></a>    return seen[s] = value;
<a name="line700"></a>  });
<a name="line701"></a>};
<a name="line702"></a>
<a name="line703"></a>
<a name="line704"></a>/**
<a name="line705"></a> * Unescapes XML entities.
<a name="line706"></a> * @private
<a name="line707"></a> * @param {string} str The string to unescape.
<a name="line708"></a> * @return {string} An unescaped copy of {@code str}.
<a name="line709"></a> */
<a name="line710"></a>goog.string.unescapePureXmlEntities_ = function(str) {
<a name="line711"></a>  return str.replace(/&amp;([^;]+);/g, function(s, entity) {
<a name="line712"></a>    switch (entity) {
<a name="line713"></a>      case &#39;amp&#39;:
<a name="line714"></a>        return &#39;&amp;&#39;;
<a name="line715"></a>      case &#39;lt&#39;:
<a name="line716"></a>        return &#39;&lt;&#39;;
<a name="line717"></a>      case &#39;gt&#39;:
<a name="line718"></a>        return &#39;&gt;&#39;;
<a name="line719"></a>      case &#39;quot&#39;:
<a name="line720"></a>        return &#39;&quot;&#39;;
<a name="line721"></a>      default:
<a name="line722"></a>        if (entity.charAt(0) == &#39;#&#39;) {
<a name="line723"></a>          // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex.
<a name="line724"></a>          var n = Number(&#39;0&#39; + entity.substr(1));
<a name="line725"></a>          if (!isNaN(n)) {
<a name="line726"></a>            return String.fromCharCode(n);
<a name="line727"></a>          }
<a name="line728"></a>        }
<a name="line729"></a>        // For invalid entities we just return the entity
<a name="line730"></a>        return s;
<a name="line731"></a>    }
<a name="line732"></a>  });
<a name="line733"></a>};
<a name="line734"></a>
<a name="line735"></a>
<a name="line736"></a>/**
<a name="line737"></a> * Regular expression that matches an HTML entity.
<a name="line738"></a> * See also HTML5: Tokenization / Tokenizing character references.
<a name="line739"></a> * @private
<a name="line740"></a> * @type {!RegExp}
<a name="line741"></a> */
<a name="line742"></a>goog.string.HTML_ENTITY_PATTERN_ = /&amp;([^;\s&lt;&amp;]+);?/g;
<a name="line743"></a>
<a name="line744"></a>
<a name="line745"></a>/**
<a name="line746"></a> * Do escaping of whitespace to preserve spatial formatting. We use character
<a name="line747"></a> * entity #160 to make it safer for xml.
<a name="line748"></a> * @param {string} str The string in which to escape whitespace.
<a name="line749"></a> * @param {boolean=} opt_xml Whether to use XML compatible tags.
<a name="line750"></a> * @return {string} An escaped copy of {@code str}.
<a name="line751"></a> */
<a name="line752"></a>goog.string.whitespaceEscape = function(str, opt_xml) {
<a name="line753"></a>  // This doesn&#39;t use goog.string.preserveSpaces for backwards compatibility.
<a name="line754"></a>  return goog.string.newLineToBr(str.replace(/  /g, &#39; &amp;#160;&#39;), opt_xml);
<a name="line755"></a>};
<a name="line756"></a>
<a name="line757"></a>
<a name="line758"></a>/**
<a name="line759"></a> * Preserve spaces that would be otherwise collapsed in HTML by replacing them
<a name="line760"></a> * with non-breaking space Unicode characters.
<a name="line761"></a> * @param {string} str The string in which to preserve whitespace.
<a name="line762"></a> * @return {string} A copy of {@code str} with preserved whitespace.
<a name="line763"></a> */
<a name="line764"></a>goog.string.preserveSpaces = function(str) {
<a name="line765"></a>  return str.replace(/(^|[\n ]) /g, &#39;$1&#39; + goog.string.Unicode.NBSP);
<a name="line766"></a>};
<a name="line767"></a>
<a name="line768"></a>
<a name="line769"></a>/**
<a name="line770"></a> * Strip quote characters around a string.  The second argument is a string of
<a name="line771"></a> * characters to treat as quotes.  This can be a single character or a string of
<a name="line772"></a> * multiple character and in that case each of those are treated as possible
<a name="line773"></a> * quote characters. For example:
<a name="line774"></a> *
<a name="line775"></a> * &lt;pre&gt;
<a name="line776"></a> * goog.string.stripQuotes(&#39;&quot;abc&quot;&#39;, &#39;&quot;`&#39;) --&gt; &#39;abc&#39;
<a name="line777"></a> * goog.string.stripQuotes(&#39;`abc`&#39;, &#39;&quot;`&#39;) --&gt; &#39;abc&#39;
<a name="line778"></a> * &lt;/pre&gt;
<a name="line779"></a> *
<a name="line780"></a> * @param {string} str The string to strip.
<a name="line781"></a> * @param {string} quoteChars The quote characters to strip.
<a name="line782"></a> * @return {string} A copy of {@code str} without the quotes.
<a name="line783"></a> */
<a name="line784"></a>goog.string.stripQuotes = function(str, quoteChars) {
<a name="line785"></a>  var length = quoteChars.length;
<a name="line786"></a>  for (var i = 0; i &lt; length; i++) {
<a name="line787"></a>    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
<a name="line788"></a>    if (str.charAt(0) == quoteChar &amp;&amp; str.charAt(str.length - 1) == quoteChar) {
<a name="line789"></a>      return str.substring(1, str.length - 1);
<a name="line790"></a>    }
<a name="line791"></a>  }
<a name="line792"></a>  return str;
<a name="line793"></a>};
<a name="line794"></a>
<a name="line795"></a>
<a name="line796"></a>/**
<a name="line797"></a> * Truncates a string to a certain length and adds &#39;...&#39; if necessary.  The
<a name="line798"></a> * length also accounts for the ellipsis, so a maximum length of 10 and a string
<a name="line799"></a> * &#39;Hello World!&#39; produces &#39;Hello W...&#39;.
<a name="line800"></a> * @param {string} str The string to truncate.
<a name="line801"></a> * @param {number} chars Max number of characters.
<a name="line802"></a> * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
<a name="line803"></a> *     characters from being cut off in the middle.
<a name="line804"></a> * @return {string} The truncated {@code str} string.
<a name="line805"></a> */
<a name="line806"></a>goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
<a name="line807"></a>  if (opt_protectEscapedCharacters) {
<a name="line808"></a>    str = goog.string.unescapeEntities(str);
<a name="line809"></a>  }
<a name="line810"></a>
<a name="line811"></a>  if (str.length &gt; chars) {
<a name="line812"></a>    str = str.substring(0, chars - 3) + &#39;...&#39;;
<a name="line813"></a>  }
<a name="line814"></a>
<a name="line815"></a>  if (opt_protectEscapedCharacters) {
<a name="line816"></a>    str = goog.string.htmlEscape(str);
<a name="line817"></a>  }
<a name="line818"></a>
<a name="line819"></a>  return str;
<a name="line820"></a>};
<a name="line821"></a>
<a name="line822"></a>
<a name="line823"></a>/**
<a name="line824"></a> * Truncate a string in the middle, adding &quot;...&quot; if necessary,
<a name="line825"></a> * and favoring the beginning of the string.
<a name="line826"></a> * @param {string} str The string to truncate the middle of.
<a name="line827"></a> * @param {number} chars Max number of characters.
<a name="line828"></a> * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
<a name="line829"></a> *     characters from being cutoff in the middle.
<a name="line830"></a> * @param {number=} opt_trailingChars Optional number of trailing characters to
<a name="line831"></a> *     leave at the end of the string, instead of truncating as close to the
<a name="line832"></a> *     middle as possible.
<a name="line833"></a> * @return {string} A truncated copy of {@code str}.
<a name="line834"></a> */
<a name="line835"></a>goog.string.truncateMiddle = function(str, chars,
<a name="line836"></a>    opt_protectEscapedCharacters, opt_trailingChars) {
<a name="line837"></a>  if (opt_protectEscapedCharacters) {
<a name="line838"></a>    str = goog.string.unescapeEntities(str);
<a name="line839"></a>  }
<a name="line840"></a>
<a name="line841"></a>  if (opt_trailingChars &amp;&amp; str.length &gt; chars) {
<a name="line842"></a>    if (opt_trailingChars &gt; chars) {
<a name="line843"></a>      opt_trailingChars = chars;
<a name="line844"></a>    }
<a name="line845"></a>    var endPoint = str.length - opt_trailingChars;
<a name="line846"></a>    var startPoint = chars - opt_trailingChars;
<a name="line847"></a>    str = str.substring(0, startPoint) + &#39;...&#39; + str.substring(endPoint);
<a name="line848"></a>  } else if (str.length &gt; chars) {
<a name="line849"></a>    // Favor the beginning of the string:
<a name="line850"></a>    var half = Math.floor(chars / 2);
<a name="line851"></a>    var endPos = str.length - half;
<a name="line852"></a>    half += chars % 2;
<a name="line853"></a>    str = str.substring(0, half) + &#39;...&#39; + str.substring(endPos);
<a name="line854"></a>  }
<a name="line855"></a>
<a name="line856"></a>  if (opt_protectEscapedCharacters) {
<a name="line857"></a>    str = goog.string.htmlEscape(str);
<a name="line858"></a>  }
<a name="line859"></a>
<a name="line860"></a>  return str;
<a name="line861"></a>};
<a name="line862"></a>
<a name="line863"></a>
<a name="line864"></a>/**
<a name="line865"></a> * Special chars that need to be escaped for goog.string.quote.
<a name="line866"></a> * @private
<a name="line867"></a> * @type {Object}
<a name="line868"></a> */
<a name="line869"></a>goog.string.specialEscapeChars_ = {
<a name="line870"></a>  &#39;\0&#39;: &#39;\\0&#39;,
<a name="line871"></a>  &#39;\b&#39;: &#39;\\b&#39;,
<a name="line872"></a>  &#39;\f&#39;: &#39;\\f&#39;,
<a name="line873"></a>  &#39;\n&#39;: &#39;\\n&#39;,
<a name="line874"></a>  &#39;\r&#39;: &#39;\\r&#39;,
<a name="line875"></a>  &#39;\t&#39;: &#39;\\t&#39;,
<a name="line876"></a>  &#39;\x0B&#39;: &#39;\\x0B&#39;, // &#39;\v&#39; is not supported in JScript
<a name="line877"></a>  &#39;&quot;&#39;: &#39;\\&quot;&#39;,
<a name="line878"></a>  &#39;\\&#39;: &#39;\\\\&#39;
<a name="line879"></a>};
<a name="line880"></a>
<a name="line881"></a>
<a name="line882"></a>/**
<a name="line883"></a> * Character mappings used internally for goog.string.escapeChar.
<a name="line884"></a> * @private
<a name="line885"></a> * @type {Object}
<a name="line886"></a> */
<a name="line887"></a>goog.string.jsEscapeCache_ = {
<a name="line888"></a>  &#39;\&#39;&#39;: &#39;\\\&#39;&#39;
<a name="line889"></a>};
<a name="line890"></a>
<a name="line891"></a>
<a name="line892"></a>/**
<a name="line893"></a> * Encloses a string in double quotes and escapes characters so that the
<a name="line894"></a> * string is a valid JS string.
<a name="line895"></a> * @param {string} s The string to quote.
<a name="line896"></a> * @return {string} A copy of {@code s} surrounded by double quotes.
<a name="line897"></a> */
<a name="line898"></a>goog.string.quote = function(s) {
<a name="line899"></a>  s = String(s);
<a name="line900"></a>  if (s.quote) {
<a name="line901"></a>    return s.quote();
<a name="line902"></a>  } else {
<a name="line903"></a>    var sb = [&#39;&quot;&#39;];
<a name="line904"></a>    for (var i = 0; i &lt; s.length; i++) {
<a name="line905"></a>      var ch = s.charAt(i);
<a name="line906"></a>      var cc = ch.charCodeAt(0);
<a name="line907"></a>      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
<a name="line908"></a>          ((cc &gt; 31 &amp;&amp; cc &lt; 127) ? ch : goog.string.escapeChar(ch));
<a name="line909"></a>    }
<a name="line910"></a>    sb.push(&#39;&quot;&#39;);
<a name="line911"></a>    return sb.join(&#39;&#39;);
<a name="line912"></a>  }
<a name="line913"></a>};
<a name="line914"></a>
<a name="line915"></a>
<a name="line916"></a>/**
<a name="line917"></a> * Takes a string and returns the escaped string for that character.
<a name="line918"></a> * @param {string} str The string to escape.
<a name="line919"></a> * @return {string} An escaped string representing {@code str}.
<a name="line920"></a> */
<a name="line921"></a>goog.string.escapeString = function(str) {
<a name="line922"></a>  var sb = [];
<a name="line923"></a>  for (var i = 0; i &lt; str.length; i++) {
<a name="line924"></a>    sb[i] = goog.string.escapeChar(str.charAt(i));
<a name="line925"></a>  }
<a name="line926"></a>  return sb.join(&#39;&#39;);
<a name="line927"></a>};
<a name="line928"></a>
<a name="line929"></a>
<a name="line930"></a>/**
<a name="line931"></a> * Takes a character and returns the escaped string for that character. For
<a name="line932"></a> * example escapeChar(String.fromCharCode(15)) -&gt; &quot;\\x0E&quot;.
<a name="line933"></a> * @param {string} c The character to escape.
<a name="line934"></a> * @return {string} An escaped string representing {@code c}.
<a name="line935"></a> */
<a name="line936"></a>goog.string.escapeChar = function(c) {
<a name="line937"></a>  if (c in goog.string.jsEscapeCache_) {
<a name="line938"></a>    return goog.string.jsEscapeCache_[c];
<a name="line939"></a>  }
<a name="line940"></a>
<a name="line941"></a>  if (c in goog.string.specialEscapeChars_) {
<a name="line942"></a>    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
<a name="line943"></a>  }
<a name="line944"></a>
<a name="line945"></a>  var rv = c;
<a name="line946"></a>  var cc = c.charCodeAt(0);
<a name="line947"></a>  if (cc &gt; 31 &amp;&amp; cc &lt; 127) {
<a name="line948"></a>    rv = c;
<a name="line949"></a>  } else {
<a name="line950"></a>    // tab is 9 but handled above
<a name="line951"></a>    if (cc &lt; 256) {
<a name="line952"></a>      rv = &#39;\\x&#39;;
<a name="line953"></a>      if (cc &lt; 16 || cc &gt; 256) {
<a name="line954"></a>        rv += &#39;0&#39;;
<a name="line955"></a>      }
<a name="line956"></a>    } else {
<a name="line957"></a>      rv = &#39;\\u&#39;;
<a name="line958"></a>      if (cc &lt; 4096) { // \u1000
<a name="line959"></a>        rv += &#39;0&#39;;
<a name="line960"></a>      }
<a name="line961"></a>    }
<a name="line962"></a>    rv += cc.toString(16).toUpperCase();
<a name="line963"></a>  }
<a name="line964"></a>
<a name="line965"></a>  return goog.string.jsEscapeCache_[c] = rv;
<a name="line966"></a>};
<a name="line967"></a>
<a name="line968"></a>
<a name="line969"></a>/**
<a name="line970"></a> * Takes a string and creates a map (Object) in which the keys are the
<a name="line971"></a> * characters in the string. The value for the key is set to true. You can
<a name="line972"></a> * then use goog.object.map or goog.array.map to change the values.
<a name="line973"></a> * @param {string} s The string to build the map from.
<a name="line974"></a> * @return {!Object} The map of characters used.
<a name="line975"></a> */
<a name="line976"></a>// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
<a name="line977"></a>//            we want a dependency on goog.array in goog.string?
<a name="line978"></a>goog.string.toMap = function(s) {
<a name="line979"></a>  var rv = {};
<a name="line980"></a>  for (var i = 0; i &lt; s.length; i++) {
<a name="line981"></a>    rv[s.charAt(i)] = true;
<a name="line982"></a>  }
<a name="line983"></a>  return rv;
<a name="line984"></a>};
<a name="line985"></a>
<a name="line986"></a>
<a name="line987"></a>/**
<a name="line988"></a> * Determines whether a string contains a substring.
<a name="line989"></a> * @param {string} str The string to search.
<a name="line990"></a> * @param {string} subString The substring to search for.
<a name="line991"></a> * @return {boolean} Whether {@code str} contains {@code subString}.
<a name="line992"></a> */
<a name="line993"></a>goog.string.contains = function(str, subString) {
<a name="line994"></a>  return str.indexOf(subString) != -1;
<a name="line995"></a>};
<a name="line996"></a>
<a name="line997"></a>
<a name="line998"></a>/**
<a name="line999"></a> * Determines whether a string contains a substring, ignoring case.
<a name="line1000"></a> * @param {string} str The string to search.
<a name="line1001"></a> * @param {string} subString The substring to search for.
<a name="line1002"></a> * @return {boolean} Whether {@code str} contains {@code subString}.
<a name="line1003"></a> */
<a name="line1004"></a>goog.string.caseInsensitiveContains = function(str, subString) {
<a name="line1005"></a>  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());
<a name="line1006"></a>};
<a name="line1007"></a>
<a name="line1008"></a>
<a name="line1009"></a>/**
<a name="line1010"></a> * Returns the non-overlapping occurrences of ss in s.
<a name="line1011"></a> * If either s or ss evalutes to false, then returns zero.
<a name="line1012"></a> * @param {string} s The string to look in.
<a name="line1013"></a> * @param {string} ss The string to look for.
<a name="line1014"></a> * @return {number} Number of occurrences of ss in s.
<a name="line1015"></a> */
<a name="line1016"></a>goog.string.countOf = function(s, ss) {
<a name="line1017"></a>  return s &amp;&amp; ss ? s.split(ss).length - 1 : 0;
<a name="line1018"></a>};
<a name="line1019"></a>
<a name="line1020"></a>
<a name="line1021"></a>/**
<a name="line1022"></a> * Removes a substring of a specified length at a specific
<a name="line1023"></a> * index in a string.
<a name="line1024"></a> * @param {string} s The base string from which to remove.
<a name="line1025"></a> * @param {number} index The index at which to remove the substring.
<a name="line1026"></a> * @param {number} stringLength The length of the substring to remove.
<a name="line1027"></a> * @return {string} A copy of {@code s} with the substring removed or the full
<a name="line1028"></a> *     string if nothing is removed or the input is invalid.
<a name="line1029"></a> */
<a name="line1030"></a>goog.string.removeAt = function(s, index, stringLength) {
<a name="line1031"></a>  var resultStr = s;
<a name="line1032"></a>  // If the index is greater or equal to 0 then remove substring
<a name="line1033"></a>  if (index &gt;= 0 &amp;&amp; index &lt; s.length &amp;&amp; stringLength &gt; 0) {
<a name="line1034"></a>    resultStr = s.substr(0, index) +
<a name="line1035"></a>        s.substr(index + stringLength, s.length - index - stringLength);
<a name="line1036"></a>  }
<a name="line1037"></a>  return resultStr;
<a name="line1038"></a>};
<a name="line1039"></a>
<a name="line1040"></a>
<a name="line1041"></a>/**
<a name="line1042"></a> *  Removes the first occurrence of a substring from a string.
<a name="line1043"></a> *  @param {string} s The base string from which to remove.
<a name="line1044"></a> *  @param {string} ss The string to remove.
<a name="line1045"></a> *  @return {string} A copy of {@code s} with {@code ss} removed or the full
<a name="line1046"></a> *      string if nothing is removed.
<a name="line1047"></a> */
<a name="line1048"></a>goog.string.remove = function(s, ss) {
<a name="line1049"></a>  var re = new RegExp(goog.string.regExpEscape(ss), &#39;&#39;);
<a name="line1050"></a>  return s.replace(re, &#39;&#39;);
<a name="line1051"></a>};
<a name="line1052"></a>
<a name="line1053"></a>
<a name="line1054"></a>/**
<a name="line1055"></a> *  Removes all occurrences of a substring from a string.
<a name="line1056"></a> *  @param {string} s The base string from which to remove.
<a name="line1057"></a> *  @param {string} ss The string to remove.
<a name="line1058"></a> *  @return {string} A copy of {@code s} with {@code ss} removed or the full
<a name="line1059"></a> *      string if nothing is removed.
<a name="line1060"></a> */
<a name="line1061"></a>goog.string.removeAll = function(s, ss) {
<a name="line1062"></a>  var re = new RegExp(goog.string.regExpEscape(ss), &#39;g&#39;);
<a name="line1063"></a>  return s.replace(re, &#39;&#39;);
<a name="line1064"></a>};
<a name="line1065"></a>
<a name="line1066"></a>
<a name="line1067"></a>/**
<a name="line1068"></a> * Escapes characters in the string that are not safe to use in a RegExp.
<a name="line1069"></a> * @param {*} s The string to escape. If not a string, it will be casted
<a name="line1070"></a> *     to one.
<a name="line1071"></a> * @return {string} A RegExp safe, escaped copy of {@code s}.
<a name="line1072"></a> */
<a name="line1073"></a>goog.string.regExpEscape = function(s) {
<a name="line1074"></a>  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, &#39;\\$1&#39;).
<a name="line1075"></a>      replace(/\x08/g, &#39;\\x08&#39;);
<a name="line1076"></a>};
<a name="line1077"></a>
<a name="line1078"></a>
<a name="line1079"></a>/**
<a name="line1080"></a> * Repeats a string n times.
<a name="line1081"></a> * @param {string} string The string to repeat.
<a name="line1082"></a> * @param {number} length The number of times to repeat.
<a name="line1083"></a> * @return {string} A string containing {@code length} repetitions of
<a name="line1084"></a> *     {@code string}.
<a name="line1085"></a> */
<a name="line1086"></a>goog.string.repeat = function(string, length) {
<a name="line1087"></a>  return new Array(length + 1).join(string);
<a name="line1088"></a>};
<a name="line1089"></a>
<a name="line1090"></a>
<a name="line1091"></a>/**
<a name="line1092"></a> * Pads number to given length and optionally rounds it to a given precision.
<a name="line1093"></a> * For example:
<a name="line1094"></a> * &lt;pre&gt;padNumber(1.25, 2, 3) -&gt; &#39;01.250&#39;
<a name="line1095"></a> * padNumber(1.25, 2) -&gt; &#39;01.25&#39;
<a name="line1096"></a> * padNumber(1.25, 2, 1) -&gt; &#39;01.3&#39;
<a name="line1097"></a> * padNumber(1.25, 0) -&gt; &#39;1.25&#39;&lt;/pre&gt;
<a name="line1098"></a> *
<a name="line1099"></a> * @param {number} num The number to pad.
<a name="line1100"></a> * @param {number} length The desired length.
<a name="line1101"></a> * @param {number=} opt_precision The desired precision.
<a name="line1102"></a> * @return {string} {@code num} as a string with the given options.
<a name="line1103"></a> */
<a name="line1104"></a>goog.string.padNumber = function(num, length, opt_precision) {
<a name="line1105"></a>  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
<a name="line1106"></a>  var index = s.indexOf(&#39;.&#39;);
<a name="line1107"></a>  if (index == -1) {
<a name="line1108"></a>    index = s.length;
<a name="line1109"></a>  }
<a name="line1110"></a>  return goog.string.repeat(&#39;0&#39;, Math.max(0, length - index)) + s;
<a name="line1111"></a>};
<a name="line1112"></a>
<a name="line1113"></a>
<a name="line1114"></a>/**
<a name="line1115"></a> * Returns a string representation of the given object, with
<a name="line1116"></a> * null and undefined being returned as the empty string.
<a name="line1117"></a> *
<a name="line1118"></a> * @param {*} obj The object to convert.
<a name="line1119"></a> * @return {string} A string representation of the {@code obj}.
<a name="line1120"></a> */
<a name="line1121"></a>goog.string.makeSafe = function(obj) {
<a name="line1122"></a>  return obj == null ? &#39;&#39; : String(obj);
<a name="line1123"></a>};
<a name="line1124"></a>
<a name="line1125"></a>
<a name="line1126"></a>/**
<a name="line1127"></a> * Concatenates string expressions. This is useful
<a name="line1128"></a> * since some browsers are very inefficient when it comes to using plus to
<a name="line1129"></a> * concat strings. Be careful when using null and undefined here since
<a name="line1130"></a> * these will not be included in the result. If you need to represent these
<a name="line1131"></a> * be sure to cast the argument to a String first.
<a name="line1132"></a> * For example:
<a name="line1133"></a> * &lt;pre&gt;buildString(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) -&gt; &#39;abcd&#39;
<a name="line1134"></a> * buildString(null, undefined) -&gt; &#39;&#39;
<a name="line1135"></a> * &lt;/pre&gt;
<a name="line1136"></a> * @param {...*} var_args A list of strings to concatenate. If not a string,
<a name="line1137"></a> *     it will be casted to one.
<a name="line1138"></a> * @return {string} The concatenation of {@code var_args}.
<a name="line1139"></a> */
<a name="line1140"></a>goog.string.buildString = function(var_args) {
<a name="line1141"></a>  return Array.prototype.join.call(arguments, &#39;&#39;);
<a name="line1142"></a>};
<a name="line1143"></a>
<a name="line1144"></a>
<a name="line1145"></a>/**
<a name="line1146"></a> * Returns a string with at least 64-bits of randomness.
<a name="line1147"></a> *
<a name="line1148"></a> * Doesn&#39;t trust Javascript&#39;s random function entirely. Uses a combination of
<a name="line1149"></a> * random and current timestamp, and then encodes the string in base-36 to
<a name="line1150"></a> * make it shorter.
<a name="line1151"></a> *
<a name="line1152"></a> * @return {string} A random string, e.g. sn1s7vb4gcic.
<a name="line1153"></a> */
<a name="line1154"></a>goog.string.getRandomString = function() {
<a name="line1155"></a>  var x = 2147483648;
<a name="line1156"></a>  return Math.floor(Math.random() * x).toString(36) +
<a name="line1157"></a>         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
<a name="line1158"></a>};
<a name="line1159"></a>
<a name="line1160"></a>
<a name="line1161"></a>/**
<a name="line1162"></a> * Compares two version numbers.
<a name="line1163"></a> *
<a name="line1164"></a> * @param {string|number} version1 Version of first item.
<a name="line1165"></a> * @param {string|number} version2 Version of second item.
<a name="line1166"></a> *
<a name="line1167"></a> * @return {number}  1 if {@code version1} is higher.
<a name="line1168"></a> *                   0 if arguments are equal.
<a name="line1169"></a> *                  -1 if {@code version2} is higher.
<a name="line1170"></a> */
<a name="line1171"></a>goog.string.compareVersions = function(version1, version2) {
<a name="line1172"></a>  var order = 0;
<a name="line1173"></a>  // Trim leading and trailing whitespace and split the versions into
<a name="line1174"></a>  // subversions.
<a name="line1175"></a>  var v1Subs = goog.string.trim(String(version1)).split(&#39;.&#39;);
<a name="line1176"></a>  var v2Subs = goog.string.trim(String(version2)).split(&#39;.&#39;);
<a name="line1177"></a>  var subCount = Math.max(v1Subs.length, v2Subs.length);
<a name="line1178"></a>
<a name="line1179"></a>  // Iterate over the subversions, as long as they appear to be equivalent.
<a name="line1180"></a>  for (var subIdx = 0; order == 0 &amp;&amp; subIdx &lt; subCount; subIdx++) {
<a name="line1181"></a>    var v1Sub = v1Subs[subIdx] || &#39;&#39;;
<a name="line1182"></a>    var v2Sub = v2Subs[subIdx] || &#39;&#39;;
<a name="line1183"></a>
<a name="line1184"></a>    // Split the subversions into pairs of numbers and qualifiers (like &#39;b&#39;).
<a name="line1185"></a>    // Two different RegExp objects are needed because they are both using
<a name="line1186"></a>    // the &#39;g&#39; flag.
<a name="line1187"></a>    var v1CompParser = new RegExp(&#39;(\\d*)(\\D*)&#39;, &#39;g&#39;);
<a name="line1188"></a>    var v2CompParser = new RegExp(&#39;(\\d*)(\\D*)&#39;, &#39;g&#39;);
<a name="line1189"></a>    do {
<a name="line1190"></a>      var v1Comp = v1CompParser.exec(v1Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;];
<a name="line1191"></a>      var v2Comp = v2CompParser.exec(v2Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;];
<a name="line1192"></a>      // Break if there are no more matches.
<a name="line1193"></a>      if (v1Comp[0].length == 0 &amp;&amp; v2Comp[0].length == 0) {
<a name="line1194"></a>        break;
<a name="line1195"></a>      }
<a name="line1196"></a>
<a name="line1197"></a>      // Parse the numeric part of the subversion. A missing number is
<a name="line1198"></a>      // equivalent to 0.
<a name="line1199"></a>      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
<a name="line1200"></a>      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
<a name="line1201"></a>
<a name="line1202"></a>      // Compare the subversion components. The number has the highest
<a name="line1203"></a>      // precedence. Next, if the numbers are equal, a subversion without any
<a name="line1204"></a>      // qualifier is always higher than a subversion with any qualifier. Next,
<a name="line1205"></a>      // the qualifiers are compared as strings.
<a name="line1206"></a>      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
<a name="line1207"></a>          goog.string.compareElements_(v1Comp[2].length == 0,
<a name="line1208"></a>              v2Comp[2].length == 0) ||
<a name="line1209"></a>          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
<a name="line1210"></a>      // Stop as soon as an inequality is discovered.
<a name="line1211"></a>    } while (order == 0);
<a name="line1212"></a>  }
<a name="line1213"></a>
<a name="line1214"></a>  return order;
<a name="line1215"></a>};
<a name="line1216"></a>
<a name="line1217"></a>
<a name="line1218"></a>/**
<a name="line1219"></a> * Compares elements of a version number.
<a name="line1220"></a> *
<a name="line1221"></a> * @param {string|number|boolean} left An element from a version number.
<a name="line1222"></a> * @param {string|number|boolean} right An element from a version number.
<a name="line1223"></a> *
<a name="line1224"></a> * @return {number}  1 if {@code left} is higher.
<a name="line1225"></a> *                   0 if arguments are equal.
<a name="line1226"></a> *                  -1 if {@code right} is higher.
<a name="line1227"></a> * @private
<a name="line1228"></a> */
<a name="line1229"></a>goog.string.compareElements_ = function(left, right) {
<a name="line1230"></a>  if (left &lt; right) {
<a name="line1231"></a>    return -1;
<a name="line1232"></a>  } else if (left &gt; right) {
<a name="line1233"></a>    return 1;
<a name="line1234"></a>  }
<a name="line1235"></a>  return 0;
<a name="line1236"></a>};
<a name="line1237"></a>
<a name="line1238"></a>
<a name="line1239"></a>/**
<a name="line1240"></a> * Maximum value of #goog.string.hashCode, exclusive. 2^32.
<a name="line1241"></a> * @type {number}
<a name="line1242"></a> * @private
<a name="line1243"></a> */
<a name="line1244"></a>goog.string.HASHCODE_MAX_ = 0x100000000;
<a name="line1245"></a>
<a name="line1246"></a>
<a name="line1247"></a>/**
<a name="line1248"></a> * String hash function similar to java.lang.String.hashCode().
<a name="line1249"></a> * The hash code for a string is computed as
<a name="line1250"></a> * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
<a name="line1251"></a> * where s[i] is the ith character of the string and n is the length of
<a name="line1252"></a> * the string. We mod the result to make it between 0 (inclusive) and 2^32
<a name="line1253"></a> * (exclusive).
<a name="line1254"></a> * @param {string} str A string.
<a name="line1255"></a> * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
<a name="line1256"></a> *  (exclusive). The empty string returns 0.
<a name="line1257"></a> */
<a name="line1258"></a>goog.string.hashCode = function(str) {
<a name="line1259"></a>  var result = 0;
<a name="line1260"></a>  for (var i = 0; i &lt; str.length; ++i) {
<a name="line1261"></a>    result = 31 * result + str.charCodeAt(i);
<a name="line1262"></a>    // Normalize to 4 byte range, 0 ... 2^32.
<a name="line1263"></a>    result %= goog.string.HASHCODE_MAX_;
<a name="line1264"></a>  }
<a name="line1265"></a>  return result;
<a name="line1266"></a>};
<a name="line1267"></a>
<a name="line1268"></a>
<a name="line1269"></a>/**
<a name="line1270"></a> * The most recent unique ID. |0 is equivalent to Math.floor in this case.
<a name="line1271"></a> * @type {number}
<a name="line1272"></a> * @private
<a name="line1273"></a> */
<a name="line1274"></a>goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;
<a name="line1275"></a>
<a name="line1276"></a>
<a name="line1277"></a>/**
<a name="line1278"></a> * Generates and returns a string which is unique in the current document.
<a name="line1279"></a> * This is useful, for example, to create unique IDs for DOM elements.
<a name="line1280"></a> * @return {string} A unique id.
<a name="line1281"></a> */
<a name="line1282"></a>goog.string.createUniqueString = function() {
<a name="line1283"></a>  return &#39;goog_&#39; + goog.string.uniqueStringCounter_++;
<a name="line1284"></a>};
<a name="line1285"></a>
<a name="line1286"></a>
<a name="line1287"></a>/**
<a name="line1288"></a> * Converts the supplied string to a number, which may be Infinity or NaN.
<a name="line1289"></a> * This function strips whitespace: (toNumber(&#39; 123&#39;) === 123)
<a name="line1290"></a> * This function accepts scientific notation: (toNumber(&#39;1e1&#39;) === 10)
<a name="line1291"></a> *
<a name="line1292"></a> * This is better than Javascript&#39;s built-in conversions because, sadly:
<a name="line1293"></a> *     (Number(&#39; &#39;) === 0) and (parseFloat(&#39;123a&#39;) === 123)
<a name="line1294"></a> *
<a name="line1295"></a> * @param {string} str The string to convert.
<a name="line1296"></a> * @return {number} The number the supplied string represents, or NaN.
<a name="line1297"></a> */
<a name="line1298"></a>goog.string.toNumber = function(str) {
<a name="line1299"></a>  var num = Number(str);
<a name="line1300"></a>  if (num == 0 &amp;&amp; goog.string.isEmpty(str)) {
<a name="line1301"></a>    return NaN;
<a name="line1302"></a>  }
<a name="line1303"></a>  return num;
<a name="line1304"></a>};
<a name="line1305"></a>
<a name="line1306"></a>
<a name="line1307"></a>/**
<a name="line1308"></a> * Returns whether the given string is lower camel case (e.g. &quot;isFooBar&quot;).
<a name="line1309"></a> *
<a name="line1310"></a> * Note that this assumes the string is entirely letters.
<a name="line1311"></a> * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
<a name="line1312"></a> *
<a name="line1313"></a> * @param {string} str String to test.
<a name="line1314"></a> * @return {boolean} Whether the string is lower camel case.
<a name="line1315"></a> */
<a name="line1316"></a>goog.string.isLowerCamelCase = function(str) {
<a name="line1317"></a>  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
<a name="line1318"></a>};
<a name="line1319"></a>
<a name="line1320"></a>
<a name="line1321"></a>/**
<a name="line1322"></a> * Returns whether the given string is upper camel case (e.g. &quot;FooBarBaz&quot;).
<a name="line1323"></a> *
<a name="line1324"></a> * Note that this assumes the string is entirely letters.
<a name="line1325"></a> * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
<a name="line1326"></a> *
<a name="line1327"></a> * @param {string} str String to test.
<a name="line1328"></a> * @return {boolean} Whether the string is upper camel case.
<a name="line1329"></a> */
<a name="line1330"></a>goog.string.isUpperCamelCase = function(str) {
<a name="line1331"></a>  return /^([A-Z][a-z]*)+$/.test(str);
<a name="line1332"></a>};
<a name="line1333"></a>
<a name="line1334"></a>
<a name="line1335"></a>/**
<a name="line1336"></a> * Converts a string from selector-case to camelCase (e.g. from
<a name="line1337"></a> * &quot;multi-part-string&quot; to &quot;multiPartString&quot;), useful for converting
<a name="line1338"></a> * CSS selectors and HTML dataset keys to their equivalent JS properties.
<a name="line1339"></a> * @param {string} str The string in selector-case form.
<a name="line1340"></a> * @return {string} The string in camelCase form.
<a name="line1341"></a> */
<a name="line1342"></a>goog.string.toCamelCase = function(str) {
<a name="line1343"></a>  return String(str).replace(/\-([a-z])/g, function(all, match) {
<a name="line1344"></a>    return match.toUpperCase();
<a name="line1345"></a>  });
<a name="line1346"></a>};
<a name="line1347"></a>
<a name="line1348"></a>
<a name="line1349"></a>/**
<a name="line1350"></a> * Converts a string from camelCase to selector-case (e.g. from
<a name="line1351"></a> * &quot;multiPartString&quot; to &quot;multi-part-string&quot;), useful for converting JS
<a name="line1352"></a> * style and dataset properties to equivalent CSS selectors and HTML keys.
<a name="line1353"></a> * @param {string} str The string in camelCase form.
<a name="line1354"></a> * @return {string} The string in selector-case form.
<a name="line1355"></a> */
<a name="line1356"></a>goog.string.toSelectorCase = function(str) {
<a name="line1357"></a>  return String(str).replace(/([A-Z])/g, &#39;-$1&#39;).toLowerCase();
<a name="line1358"></a>};
<a name="line1359"></a>
<a name="line1360"></a>
<a name="line1361"></a>/**
<a name="line1362"></a> * Converts a string into TitleCase. First character of the string is always
<a name="line1363"></a> * capitalized in addition to the first letter of every subsequent word.
<a name="line1364"></a> * Words are delimited by one or more whitespaces by default. Custom delimiters
<a name="line1365"></a> * can optionally be specified to replace the default, which doesn&#39;t preserve
<a name="line1366"></a> * whitespace delimiters and instead must be explicitly included if needed.
<a name="line1367"></a> *
<a name="line1368"></a> * Default delimiter =&gt; &quot; &quot;:
<a name="line1369"></a> *    goog.string.toTitleCase(&#39;oneTwoThree&#39;)    =&gt; &#39;OneTwoThree&#39;
<a name="line1370"></a> *    goog.string.toTitleCase(&#39;one two three&#39;)  =&gt; &#39;One Two Three&#39;
<a name="line1371"></a> *    goog.string.toTitleCase(&#39;  one   two   &#39;) =&gt; &#39;  One   Two   &#39;
<a name="line1372"></a> *    goog.string.toTitleCase(&#39;one_two_three&#39;)  =&gt; &#39;One_two_three&#39;
<a name="line1373"></a> *    goog.string.toTitleCase(&#39;one-two-three&#39;)  =&gt; &#39;One-two-three&#39;
<a name="line1374"></a> *
<a name="line1375"></a> * Custom delimiter =&gt; &quot;_-.&quot;:
<a name="line1376"></a> *    goog.string.toTitleCase(&#39;oneTwoThree&#39;, &#39;_-.&#39;)       =&gt; &#39;OneTwoThree&#39;
<a name="line1377"></a> *    goog.string.toTitleCase(&#39;one two three&#39;, &#39;_-.&#39;)     =&gt; &#39;One two three&#39;
<a name="line1378"></a> *    goog.string.toTitleCase(&#39;  one   two   &#39;, &#39;_-.&#39;)    =&gt; &#39;  one   two   &#39;
<a name="line1379"></a> *    goog.string.toTitleCase(&#39;one_two_three&#39;, &#39;_-.&#39;)     =&gt; &#39;One_Two_Three&#39;
<a name="line1380"></a> *    goog.string.toTitleCase(&#39;one-two-three&#39;, &#39;_-.&#39;)     =&gt; &#39;One-Two-Three&#39;
<a name="line1381"></a> *    goog.string.toTitleCase(&#39;one...two...three&#39;, &#39;_-.&#39;) =&gt; &#39;One...Two...Three&#39;
<a name="line1382"></a> *    goog.string.toTitleCase(&#39;one. two. three&#39;, &#39;_-.&#39;)   =&gt; &#39;One. two. three&#39;
<a name="line1383"></a> *    goog.string.toTitleCase(&#39;one-two.three&#39;, &#39;_-.&#39;)     =&gt; &#39;One-Two.Three&#39;
<a name="line1384"></a> *
<a name="line1385"></a> * @param {string} str String value in camelCase form.
<a name="line1386"></a> * @param {string=} opt_delimiters Custom delimiter character set used to
<a name="line1387"></a> *      distinguish words in the string value. Each character represents a
<a name="line1388"></a> *      single delimiter. When provided, default whitespace delimiter is
<a name="line1389"></a> *      overridden and must be explicitly included if needed.
<a name="line1390"></a> * @return {string} String value in TitleCase form.
<a name="line1391"></a> */
<a name="line1392"></a>goog.string.toTitleCase = function(str, opt_delimiters) {
<a name="line1393"></a>  var delimiters = goog.isString(opt_delimiters) ?
<a name="line1394"></a>      goog.string.regExpEscape(opt_delimiters) : &#39;\\s&#39;;
<a name="line1395"></a>
<a name="line1396"></a>  // For IE8, we need to prevent using an empty character set. Otherwise,
<a name="line1397"></a>  // incorrect matching will occur.
<a name="line1398"></a>  delimiters = delimiters ? &#39;|[&#39; + delimiters + &#39;]+&#39; : &#39;&#39;;
<a name="line1399"></a>
<a name="line1400"></a>  var regexp = new RegExp(&#39;(^&#39; + delimiters + &#39;)([a-z])&#39;, &#39;g&#39;);
<a name="line1401"></a>  return str.replace(regexp, function(all, p1, p2) {
<a name="line1402"></a>    return p1 + p2.toUpperCase();
<a name="line1403"></a>  });
<a name="line1404"></a>};
<a name="line1405"></a>
<a name="line1406"></a>
<a name="line1407"></a>/**
<a name="line1408"></a> * Parse a string in decimal or hexidecimal (&#39;0xFFFF&#39;) form.
<a name="line1409"></a> *
<a name="line1410"></a> * To parse a particular radix, please use parseInt(string, radix) directly. See
<a name="line1411"></a> * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
<a name="line1412"></a> *
<a name="line1413"></a> * This is a wrapper for the built-in parseInt function that will only parse
<a name="line1414"></a> * numbers as base 10 or base 16.  Some JS implementations assume strings
<a name="line1415"></a> * starting with &quot;0&quot; are intended to be octal. ES3 allowed but discouraged
<a name="line1416"></a> * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
<a name="line1417"></a> *
<a name="line1418"></a> * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
<a name="line1419"></a> *
<a name="line1420"></a> * @param {string|number|null|undefined} value The value to be parsed.
<a name="line1421"></a> * @return {number} The number, parsed. If the string failed to parse, this
<a name="line1422"></a> *     will be NaN.
<a name="line1423"></a> */
<a name="line1424"></a>goog.string.parseInt = function(value) {
<a name="line1425"></a>  // Force finite numbers to strings.
<a name="line1426"></a>  if (isFinite(value)) {
<a name="line1427"></a>    value = String(value);
<a name="line1428"></a>  }
<a name="line1429"></a>
<a name="line1430"></a>  if (goog.isString(value)) {
<a name="line1431"></a>    // If the string starts with &#39;0x&#39; or &#39;-0x&#39;, parse as hex.
<a name="line1432"></a>    return /^\s*-?0x/i.test(value) ?
<a name="line1433"></a>        parseInt(value, 16) : parseInt(value, 10);
<a name="line1434"></a>  }
<a name="line1435"></a>
<a name="line1436"></a>  return NaN;
<a name="line1437"></a>};
<a name="line1438"></a>
<a name="line1439"></a>
<a name="line1440"></a>/**
<a name="line1441"></a> * Splits a string on a separator a limited number of times.
<a name="line1442"></a> *
<a name="line1443"></a> * This implementation is more similar to Python or Java, where the limit
<a name="line1444"></a> * parameter specifies the maximum number of splits rather than truncating
<a name="line1445"></a> * the number of results.
<a name="line1446"></a> *
<a name="line1447"></a> * See http://docs.python.org/2/library/stdtypes.html#str.split
<a name="line1448"></a> * See JavaDoc: http://goo.gl/F2AsY
<a name="line1449"></a> * See Mozilla reference: http://goo.gl/dZdZs
<a name="line1450"></a> *
<a name="line1451"></a> * @param {string} str String to split.
<a name="line1452"></a> * @param {string} separator The separator.
<a name="line1453"></a> * @param {number} limit The limit to the number of splits. The resulting array
<a name="line1454"></a> *     will have a maximum length of limit+1.  Negative numbers are the same
<a name="line1455"></a> *     as zero.
<a name="line1456"></a> * @return {!Array.&lt;string&gt;} The string, split.
<a name="line1457"></a> */
<a name="line1458"></a>
<a name="line1459"></a>goog.string.splitLimit = function(str, separator, limit) {
<a name="line1460"></a>  var parts = str.split(separator);
<a name="line1461"></a>  var returnVal = [];
<a name="line1462"></a>
<a name="line1463"></a>  // Only continue doing this while we haven&#39;t hit the limit and we have
<a name="line1464"></a>  // parts left.
<a name="line1465"></a>  while (limit &gt; 0 &amp;&amp; parts.length) {
<a name="line1466"></a>    returnVal.push(parts.shift());
<a name="line1467"></a>    limit--;
<a name="line1468"></a>  }
<a name="line1469"></a>
<a name="line1470"></a>  // If there are remaining parts, append them to the end.
<a name="line1471"></a>  if (parts.length) {
<a name="line1472"></a>    returnVal.push(parts.join(separator));
<a name="line1473"></a>  }
<a name="line1474"></a>
<a name="line1475"></a>  return returnVal;
<a name="line1476"></a>};
</pre>


</body>
</html>
