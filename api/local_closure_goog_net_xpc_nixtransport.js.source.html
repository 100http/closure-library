<!doctype html>

<html>
<head>
  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <title>nixtransport.js (Closure Library API Documentation - JavaScript)</title>
  <link rel="stylesheet" href="static/css/base.css">
  <link rel="stylesheet" href="static/css/doc.css">
  <link rel="stylesheet" href="static/css/sidetree.css">
  <link rel="stylesheet" href="static/css/prettify.css">

  <script>
     var _staticFilePath = "static/";
     var _typeTreeName = "goog";
     var _fileTreeName = "Source";
  </script>

  <script src="static/js/doc.js">
  </script>


  <meta charset="utf8">
</head>

<body onload="grokdoc.onLoad();">

<div id="header">
  <div class="g-section g-tpl-50-50 g-split">
    <div class="g-unit g-first">
      <a id="logo" href="index.html">Closure Library API Documentation</a>
    </div>

    <div class="g-unit">
      <div class="g-c">
        <strong>Go to class or file:</strong>
        <input type="text" id="ac">
      </div>
    </div>
  </div>
</div>

<div class="clear"></div>

<h2><a href="local_closure_goog_net_xpc_nixtransport.js.html">nixtransport.js</a></h2>

<pre class="prettyprint lang-js">
<a name="line1"></a>// Copyright 2008 The Closure Library Authors. All Rights Reserved.
<a name="line2"></a>//
<a name="line3"></a>// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<a name="line4"></a>// you may not use this file except in compliance with the License.
<a name="line5"></a>// You may obtain a copy of the License at
<a name="line6"></a>//
<a name="line7"></a>//      http://www.apache.org/licenses/LICENSE-2.0
<a name="line8"></a>//
<a name="line9"></a>// Unless required by applicable law or agreed to in writing, software
<a name="line10"></a>// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
<a name="line11"></a>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<a name="line12"></a>// See the License for the specific language governing permissions and
<a name="line13"></a>// limitations under the License.
<a name="line14"></a>
<a name="line15"></a>/**
<a name="line16"></a> * @fileoverview Contains the NIX (Native IE XDC) method transport for
<a name="line17"></a> * cross-domain communication. It exploits the fact that Internet Explorer
<a name="line18"></a> * allows a window that is the parent of an iframe to set said iframe window&#39;s
<a name="line19"></a> * opener property to an object. This object can be a function that in turn
<a name="line20"></a> * can be used to send a message despite same-origin constraints. Note that
<a name="line21"></a> * this function, if a pure JavaScript object, opens up the possibilitiy of
<a name="line22"></a> * gaining a hold of the context of the other window and in turn, attacking
<a name="line23"></a> * it. This implementation therefore wraps the JavaScript objects used inside
<a name="line24"></a> * a VBScript class. Since VBScript objects are passed in JavaScript as a COM
<a name="line25"></a> * wrapper (like DOM objects), they are thus opaque to JavaScript
<a name="line26"></a> * (except for the interface they expose). This therefore provides a safe
<a name="line27"></a> * method of transport.
<a name="line28"></a> *
<a name="line29"></a> *
<a name="line30"></a> * Initially based on FrameElementTransport which shares some similarities
<a name="line31"></a> * to this method.
<a name="line32"></a> */
<a name="line33"></a>
<a name="line34"></a>goog.provide(&#39;goog.net.xpc.NixTransport&#39;);
<a name="line35"></a>
<a name="line36"></a>goog.require(&#39;goog.log&#39;);
<a name="line37"></a>goog.require(&#39;goog.net.xpc&#39;);
<a name="line38"></a>goog.require(&#39;goog.net.xpc.CfgFields&#39;);
<a name="line39"></a>goog.require(&#39;goog.net.xpc.CrossPageChannelRole&#39;);
<a name="line40"></a>goog.require(&#39;goog.net.xpc.Transport&#39;);
<a name="line41"></a>goog.require(&#39;goog.net.xpc.TransportTypes&#39;);
<a name="line42"></a>goog.require(&#39;goog.reflect&#39;);
<a name="line43"></a>
<a name="line44"></a>
<a name="line45"></a>
<a name="line46"></a>/**
<a name="line47"></a> * NIX method transport.
<a name="line48"></a> *
<a name="line49"></a> * NOTE(user): NIX method tested in all IE versions starting from 6.0.
<a name="line50"></a> *
<a name="line51"></a> * @param {goog.net.xpc.CrossPageChannel} channel The channel this transport
<a name="line52"></a> *     belongs to.
<a name="line53"></a> * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use for finding
<a name="line54"></a> *     the correct window.
<a name="line55"></a> * @constructor
<a name="line56"></a> * @extends {goog.net.xpc.Transport}
<a name="line57"></a> * @final
<a name="line58"></a> */
<a name="line59"></a>goog.net.xpc.NixTransport = function(channel, opt_domHelper) {
<a name="line60"></a>  goog.net.xpc.NixTransport.base(this, &#39;constructor&#39;, opt_domHelper);
<a name="line61"></a>
<a name="line62"></a>  /**
<a name="line63"></a>   * The channel this transport belongs to.
<a name="line64"></a>   * @type {goog.net.xpc.CrossPageChannel}
<a name="line65"></a>   * @private
<a name="line66"></a>   */
<a name="line67"></a>  this.channel_ = channel;
<a name="line68"></a>
<a name="line69"></a>  /**
<a name="line70"></a>   * The authorization token, if any, used by this transport.
<a name="line71"></a>   * @type {?string}
<a name="line72"></a>   * @private
<a name="line73"></a>   */
<a name="line74"></a>  this.authToken_ = channel[goog.net.xpc.CfgFields.AUTH_TOKEN] || &#39;&#39;;
<a name="line75"></a>
<a name="line76"></a>  /**
<a name="line77"></a>   * The authorization token, if any, that must be sent by the other party
<a name="line78"></a>   * for setup to occur.
<a name="line79"></a>   * @type {?string}
<a name="line80"></a>   * @private
<a name="line81"></a>   */
<a name="line82"></a>  this.remoteAuthToken_ =
<a name="line83"></a>      channel[goog.net.xpc.CfgFields.REMOTE_AUTH_TOKEN] || &#39;&#39;;
<a name="line84"></a>
<a name="line85"></a>  // Conduct the setup work for NIX in general, if need be.
<a name="line86"></a>  goog.net.xpc.NixTransport.conductGlobalSetup_(this.getWindow());
<a name="line87"></a>
<a name="line88"></a>  // Setup aliases so that VBScript can call these methods
<a name="line89"></a>  // on the transport class, even if they are renamed during
<a name="line90"></a>  // compression.
<a name="line91"></a>  this[goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE] = this.handleMessage_;
<a name="line92"></a>  this[goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL] = this.createChannel_;
<a name="line93"></a>};
<a name="line94"></a>goog.inherits(goog.net.xpc.NixTransport, goog.net.xpc.Transport);
<a name="line95"></a>
<a name="line96"></a>
<a name="line97"></a>// Consts for NIX. VBScript doesn&#39;t allow items to start with _ for some
<a name="line98"></a>// reason, so we need to make these names quite unique, as they will go into
<a name="line99"></a>// the global namespace.
<a name="line100"></a>
<a name="line101"></a>
<a name="line102"></a>/**
<a name="line103"></a> * Global name of the Wrapper VBScript class.
<a name="line104"></a> * Note that this class will be stored in the *global*
<a name="line105"></a> * namespace (i.e. window in browsers).
<a name="line106"></a> * @type {string}
<a name="line107"></a> */
<a name="line108"></a>goog.net.xpc.NixTransport.NIX_WRAPPER = &#39;GCXPC____NIXVBS_wrapper&#39;;
<a name="line109"></a>
<a name="line110"></a>
<a name="line111"></a>/**
<a name="line112"></a> * Global name of the GetWrapper VBScript function. This
<a name="line113"></a> * constant is used by JavaScript to call this function.
<a name="line114"></a> * Note that this function will be stored in the *global*
<a name="line115"></a> * namespace (i.e. window in browsers).
<a name="line116"></a> * @type {string}
<a name="line117"></a> */
<a name="line118"></a>goog.net.xpc.NixTransport.NIX_GET_WRAPPER = &#39;GCXPC____NIXVBS_get_wrapper&#39;;
<a name="line119"></a>
<a name="line120"></a>
<a name="line121"></a>/**
<a name="line122"></a> * The name of the handle message method used by the wrapper class
<a name="line123"></a> * when calling the transport.
<a name="line124"></a> * @type {string}
<a name="line125"></a> */
<a name="line126"></a>goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE = &#39;GCXPC____NIXJS_handle_message&#39;;
<a name="line127"></a>
<a name="line128"></a>
<a name="line129"></a>/**
<a name="line130"></a> * The name of the create channel method used by the wrapper class
<a name="line131"></a> * when calling the transport.
<a name="line132"></a> * @type {string}
<a name="line133"></a> */
<a name="line134"></a>goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL = &#39;GCXPC____NIXJS_create_channel&#39;;
<a name="line135"></a>
<a name="line136"></a>
<a name="line137"></a>/**
<a name="line138"></a> * A &quot;unique&quot; identifier that is stored in the wrapper
<a name="line139"></a> * class so that the wrapper can be distinguished from
<a name="line140"></a> * other objects easily.
<a name="line141"></a> * @type {string}
<a name="line142"></a> */
<a name="line143"></a>goog.net.xpc.NixTransport.NIX_ID_FIELD = &#39;GCXPC____NIXVBS_container&#39;;
<a name="line144"></a>
<a name="line145"></a>
<a name="line146"></a>/**
<a name="line147"></a> * Determines if the installed version of IE supports accessing window.opener
<a name="line148"></a> * after it has been set to a non-Window/null value. NIX relies on this being
<a name="line149"></a> * possible.
<a name="line150"></a> * @return {boolean} Whether window.opener behavior is compatible with NIX.
<a name="line151"></a> */
<a name="line152"></a>goog.net.xpc.NixTransport.isNixSupported = function() {
<a name="line153"></a>  var isSupported = false;
<a name="line154"></a>  try {
<a name="line155"></a>    var oldOpener = window.opener;
<a name="line156"></a>    // The compiler complains (as it should!) if we set window.opener to
<a name="line157"></a>    // something other than a window or null.
<a name="line158"></a>    window.opener = /** @type {Window} */ ({});
<a name="line159"></a>    isSupported = goog.reflect.canAccessProperty(window, &#39;opener&#39;);
<a name="line160"></a>    window.opener = oldOpener;
<a name="line161"></a>  } catch (e) { }
<a name="line162"></a>  return isSupported;
<a name="line163"></a>};
<a name="line164"></a>
<a name="line165"></a>
<a name="line166"></a>/**
<a name="line167"></a> * Conducts the global setup work for the NIX transport method.
<a name="line168"></a> * This function creates and then injects into the page the
<a name="line169"></a> * VBScript code necessary to create the NIX wrapper class.
<a name="line170"></a> * Note that this method can be called multiple times, as
<a name="line171"></a> * it internally checks whether the work is necessary before
<a name="line172"></a> * proceeding.
<a name="line173"></a> * @param {Window} listenWindow The window containing the affected page.
<a name="line174"></a> * @private
<a name="line175"></a> */
<a name="line176"></a>goog.net.xpc.NixTransport.conductGlobalSetup_ = function(listenWindow) {
<a name="line177"></a>  if (listenWindow[&#39;nix_setup_complete&#39;]) {
<a name="line178"></a>    return;
<a name="line179"></a>  }
<a name="line180"></a>
<a name="line181"></a>  // Inject the VBScript code needed.
<a name="line182"></a>  var vbscript =
<a name="line183"></a>      // We create a class to act as a wrapper for
<a name="line184"></a>      // a Javascript call, to prevent a break in of
<a name="line185"></a>      // the context.
<a name="line186"></a>      &#39;Class &#39; + goog.net.xpc.NixTransport.NIX_WRAPPER + &#39;\n &#39; +
<a name="line187"></a>
<a name="line188"></a>      // An internal member for keeping track of the
<a name="line189"></a>      // transport for which this wrapper exists.
<a name="line190"></a>      &#39;Private m_Transport\n&#39; +
<a name="line191"></a>
<a name="line192"></a>      // An internal member for keeping track of the
<a name="line193"></a>      // auth token associated with the context that
<a name="line194"></a>      // created this wrapper. Used for validation
<a name="line195"></a>      // purposes.
<a name="line196"></a>      &#39;Private m_Auth\n&#39; +
<a name="line197"></a>
<a name="line198"></a>      // Method for internally setting the value
<a name="line199"></a>      // of the m_Transport property. We have the
<a name="line200"></a>      // isEmpty check to prevent the transport
<a name="line201"></a>      // from being overridden with an illicit
<a name="line202"></a>      // object by a malicious party.
<a name="line203"></a>      &#39;Public Sub SetTransport(transport)\n&#39; +
<a name="line204"></a>      &#39;If isEmpty(m_Transport) Then\n&#39; +
<a name="line205"></a>      &#39;Set m_Transport = transport\n&#39; +
<a name="line206"></a>      &#39;End If\n&#39; +
<a name="line207"></a>      &#39;End Sub\n&#39; +
<a name="line208"></a>
<a name="line209"></a>      // Method for internally setting the value
<a name="line210"></a>      // of the m_Auth property. We have the
<a name="line211"></a>      // isEmpty check to prevent the transport
<a name="line212"></a>      // from being overridden with an illicit
<a name="line213"></a>      // object by a malicious party.
<a name="line214"></a>      &#39;Public Sub SetAuth(auth)\n&#39; +
<a name="line215"></a>      &#39;If isEmpty(m_Auth) Then\n&#39; +
<a name="line216"></a>      &#39;m_Auth = auth\n&#39; +
<a name="line217"></a>      &#39;End If\n&#39; +
<a name="line218"></a>      &#39;End Sub\n&#39; +
<a name="line219"></a>
<a name="line220"></a>      // Returns the auth token to the gadget, so it can
<a name="line221"></a>      // confirm a match before initiating the connection
<a name="line222"></a>      &#39;Public Function GetAuthToken()\n &#39; +
<a name="line223"></a>      &#39;GetAuthToken = m_Auth\n&#39; +
<a name="line224"></a>      &#39;End Function\n&#39; +
<a name="line225"></a>
<a name="line226"></a>      // A wrapper method which causes a
<a name="line227"></a>      // message to be sent to the other context.
<a name="line228"></a>      &#39;Public Sub SendMessage(service, payload)\n &#39; +
<a name="line229"></a>      &#39;Call m_Transport.&#39; +
<a name="line230"></a>      goog.net.xpc.NixTransport.NIX_HANDLE_MESSAGE + &#39;(service, payload)\n&#39; +
<a name="line231"></a>      &#39;End Sub\n&#39; +
<a name="line232"></a>
<a name="line233"></a>      // Method for setting up the inner-&gt;outer
<a name="line234"></a>      // channel.
<a name="line235"></a>      &#39;Public Sub CreateChannel(channel)\n &#39; +
<a name="line236"></a>      &#39;Call m_Transport.&#39; +
<a name="line237"></a>      goog.net.xpc.NixTransport.NIX_CREATE_CHANNEL + &#39;(channel)\n&#39; +
<a name="line238"></a>      &#39;End Sub\n&#39; +
<a name="line239"></a>
<a name="line240"></a>      // An empty field with a unique identifier to
<a name="line241"></a>      // prevent the code from confusing this wrapper
<a name="line242"></a>      // with a run-of-the-mill value found in window.opener.
<a name="line243"></a>      &#39;Public Sub &#39; + goog.net.xpc.NixTransport.NIX_ID_FIELD + &#39;()\n &#39; +
<a name="line244"></a>      &#39;End Sub\n&#39; +
<a name="line245"></a>      &#39;End Class\n &#39; +
<a name="line246"></a>
<a name="line247"></a>      // Function to get a reference to the wrapper.
<a name="line248"></a>      &#39;Function &#39; +
<a name="line249"></a>      goog.net.xpc.NixTransport.NIX_GET_WRAPPER + &#39;(transport, auth)\n&#39; +
<a name="line250"></a>      &#39;Dim wrap\n&#39; +
<a name="line251"></a>      &#39;Set wrap = New &#39; + goog.net.xpc.NixTransport.NIX_WRAPPER + &#39;\n&#39; +
<a name="line252"></a>      &#39;wrap.SetTransport transport\n&#39; +
<a name="line253"></a>      &#39;wrap.SetAuth auth\n&#39; +
<a name="line254"></a>      &#39;Set &#39; + goog.net.xpc.NixTransport.NIX_GET_WRAPPER + &#39; = wrap\n&#39; +
<a name="line255"></a>      &#39;End Function&#39;;
<a name="line256"></a>
<a name="line257"></a>  try {
<a name="line258"></a>    listenWindow.execScript(vbscript, &#39;vbscript&#39;);
<a name="line259"></a>    listenWindow[&#39;nix_setup_complete&#39;] = true;
<a name="line260"></a>  }
<a name="line261"></a>  catch (e) {
<a name="line262"></a>    goog.log.error(goog.net.xpc.logger,
<a name="line263"></a>        &#39;exception caught while attempting global setup: &#39; + e);
<a name="line264"></a>  }
<a name="line265"></a>};
<a name="line266"></a>
<a name="line267"></a>
<a name="line268"></a>/**
<a name="line269"></a> * The transport type.
<a name="line270"></a> * @type {number}
<a name="line271"></a> * @protected
<a name="line272"></a> * @override
<a name="line273"></a> */
<a name="line274"></a>goog.net.xpc.NixTransport.prototype.transportType =
<a name="line275"></a>    goog.net.xpc.TransportTypes.NIX;
<a name="line276"></a>
<a name="line277"></a>
<a name="line278"></a>/**
<a name="line279"></a> * Keeps track of whether the local setup has completed (i.e.
<a name="line280"></a> * the initial work towards setting the channel up has been
<a name="line281"></a> * completed for this end).
<a name="line282"></a> * @type {boolean}
<a name="line283"></a> * @private
<a name="line284"></a> */
<a name="line285"></a>goog.net.xpc.NixTransport.prototype.localSetupCompleted_ = false;
<a name="line286"></a>
<a name="line287"></a>
<a name="line288"></a>/**
<a name="line289"></a> * The NIX channel used to talk to the other page. This
<a name="line290"></a> * object is in fact a reference to a VBScript class
<a name="line291"></a> * (see above) and as such, is in fact a COM wrapper.
<a name="line292"></a> * When using this object, make sure to not access methods
<a name="line293"></a> * without calling them, otherwise a COM error will be thrown.
<a name="line294"></a> * @type {Object}
<a name="line295"></a> * @private
<a name="line296"></a> */
<a name="line297"></a>goog.net.xpc.NixTransport.prototype.nixChannel_ = null;
<a name="line298"></a>
<a name="line299"></a>
<a name="line300"></a>/**
<a name="line301"></a> * Connect this transport.
<a name="line302"></a> * @override
<a name="line303"></a> */
<a name="line304"></a>goog.net.xpc.NixTransport.prototype.connect = function() {
<a name="line305"></a>  if (this.channel_.getRole() == goog.net.xpc.CrossPageChannelRole.OUTER) {
<a name="line306"></a>    this.attemptOuterSetup_();
<a name="line307"></a>  } else {
<a name="line308"></a>    this.attemptInnerSetup_();
<a name="line309"></a>  }
<a name="line310"></a>};
<a name="line311"></a>
<a name="line312"></a>
<a name="line313"></a>/**
<a name="line314"></a> * Attempts to setup the channel from the perspective
<a name="line315"></a> * of the outer (read: container) page. This method
<a name="line316"></a> * will attempt to create a NIX wrapper for this transport
<a name="line317"></a> * and place it into the &quot;opener&quot; property of the inner
<a name="line318"></a> * page&#39;s window object. If it fails, it will continue
<a name="line319"></a> * to loop until it does so.
<a name="line320"></a> *
<a name="line321"></a> * @private
<a name="line322"></a> */
<a name="line323"></a>goog.net.xpc.NixTransport.prototype.attemptOuterSetup_ = function() {
<a name="line324"></a>  if (this.localSetupCompleted_) {
<a name="line325"></a>    return;
<a name="line326"></a>  }
<a name="line327"></a>
<a name="line328"></a>  // Get shortcut to iframe-element that contains the inner
<a name="line329"></a>  // page.
<a name="line330"></a>  var innerFrame = this.channel_.getIframeElement();
<a name="line331"></a>
<a name="line332"></a>  try {
<a name="line333"></a>    // Attempt to place the NIX wrapper object into the inner
<a name="line334"></a>    // frame&#39;s opener property.
<a name="line335"></a>    var theWindow = this.getWindow();
<a name="line336"></a>    var getWrapper = theWindow[goog.net.xpc.NixTransport.NIX_GET_WRAPPER];
<a name="line337"></a>    innerFrame.contentWindow.opener = getWrapper(this, this.authToken_);
<a name="line338"></a>    this.localSetupCompleted_ = true;
<a name="line339"></a>  }
<a name="line340"></a>  catch (e) {
<a name="line341"></a>    goog.log.error(goog.net.xpc.logger,
<a name="line342"></a>        &#39;exception caught while attempting setup: &#39; + e);
<a name="line343"></a>  }
<a name="line344"></a>
<a name="line345"></a>  // If the retry is necessary, reattempt this setup.
<a name="line346"></a>  if (!this.localSetupCompleted_) {
<a name="line347"></a>    this.getWindow().setTimeout(goog.bind(this.attemptOuterSetup_, this), 100);
<a name="line348"></a>  }
<a name="line349"></a>};
<a name="line350"></a>
<a name="line351"></a>
<a name="line352"></a>/**
<a name="line353"></a> * Attempts to setup the channel from the perspective
<a name="line354"></a> * of the inner (read: iframe) page. This method
<a name="line355"></a> * will attempt to *read* the opener object from the
<a name="line356"></a> * page&#39;s opener property. If it succeeds, this object
<a name="line357"></a> * is saved into nixChannel_ and the channel is confirmed
<a name="line358"></a> * with the container by calling CreateChannel with an instance
<a name="line359"></a> * of a wrapper for *this* page. Note that if this method
<a name="line360"></a> * fails, it will continue to loop until it succeeds.
<a name="line361"></a> *
<a name="line362"></a> * @private
<a name="line363"></a> */
<a name="line364"></a>goog.net.xpc.NixTransport.prototype.attemptInnerSetup_ = function() {
<a name="line365"></a>  if (this.localSetupCompleted_) {
<a name="line366"></a>    return;
<a name="line367"></a>  }
<a name="line368"></a>
<a name="line369"></a>  try {
<a name="line370"></a>    var opener = this.getWindow().opener;
<a name="line371"></a>
<a name="line372"></a>    // Ensure that the object contained inside the opener
<a name="line373"></a>    // property is in fact a NIX wrapper.
<a name="line374"></a>    if (opener &amp;&amp; goog.net.xpc.NixTransport.NIX_ID_FIELD in opener) {
<a name="line375"></a>      this.nixChannel_ = opener;
<a name="line376"></a>
<a name="line377"></a>      // Ensure that the NIX channel given to use is valid.
<a name="line378"></a>      var remoteAuthToken = this.nixChannel_[&#39;GetAuthToken&#39;]();
<a name="line379"></a>
<a name="line380"></a>      if (remoteAuthToken != this.remoteAuthToken_) {
<a name="line381"></a>        goog.log.error(goog.net.xpc.logger,
<a name="line382"></a>            &#39;Invalid auth token from other party&#39;);
<a name="line383"></a>        return;
<a name="line384"></a>      }
<a name="line385"></a>
<a name="line386"></a>      // Complete the construction of the channel by sending our own
<a name="line387"></a>      // wrapper to the container via the channel they gave us.
<a name="line388"></a>      var theWindow = this.getWindow();
<a name="line389"></a>      var getWrapper = theWindow[goog.net.xpc.NixTransport.NIX_GET_WRAPPER];
<a name="line390"></a>      this.nixChannel_[&#39;CreateChannel&#39;](getWrapper(this, this.authToken_));
<a name="line391"></a>
<a name="line392"></a>      this.localSetupCompleted_ = true;
<a name="line393"></a>
<a name="line394"></a>      // Notify channel that the transport is ready.
<a name="line395"></a>      this.channel_.notifyConnected();
<a name="line396"></a>    }
<a name="line397"></a>  }
<a name="line398"></a>  catch (e) {
<a name="line399"></a>    goog.log.error(goog.net.xpc.logger,
<a name="line400"></a>        &#39;exception caught while attempting setup: &#39; + e);
<a name="line401"></a>    return;
<a name="line402"></a>  }
<a name="line403"></a>
<a name="line404"></a>  // If the retry is necessary, reattempt this setup.
<a name="line405"></a>  if (!this.localSetupCompleted_) {
<a name="line406"></a>    this.getWindow().setTimeout(goog.bind(this.attemptInnerSetup_, this), 100);
<a name="line407"></a>  }
<a name="line408"></a>};
<a name="line409"></a>
<a name="line410"></a>
<a name="line411"></a>/**
<a name="line412"></a> * Internal method called by the inner page, via the
<a name="line413"></a> * NIX wrapper, to complete the setup of the channel.
<a name="line414"></a> *
<a name="line415"></a> * @param {Object} channel The NIX wrapper of the
<a name="line416"></a> *  inner page.
<a name="line417"></a> * @private
<a name="line418"></a> */
<a name="line419"></a>goog.net.xpc.NixTransport.prototype.createChannel_ = function(channel) {
<a name="line420"></a>  // Verify that the channel is in fact a NIX wrapper.
<a name="line421"></a>  if (typeof channel != &#39;unknown&#39; ||
<a name="line422"></a>      !(goog.net.xpc.NixTransport.NIX_ID_FIELD in channel)) {
<a name="line423"></a>    goog.log.error(goog.net.xpc.logger,
<a name="line424"></a>        &#39;Invalid NIX channel given to createChannel_&#39;);
<a name="line425"></a>  }
<a name="line426"></a>
<a name="line427"></a>  this.nixChannel_ = channel;
<a name="line428"></a>
<a name="line429"></a>  // Ensure that the NIX channel given to use is valid.
<a name="line430"></a>  var remoteAuthToken = this.nixChannel_[&#39;GetAuthToken&#39;]();
<a name="line431"></a>
<a name="line432"></a>  if (remoteAuthToken != this.remoteAuthToken_) {
<a name="line433"></a>    goog.log.error(goog.net.xpc.logger, &#39;Invalid auth token from other party&#39;);
<a name="line434"></a>    return;
<a name="line435"></a>  }
<a name="line436"></a>
<a name="line437"></a>  // Indicate to the CrossPageChannel that the channel is setup
<a name="line438"></a>  // and ready to use.
<a name="line439"></a>  this.channel_.notifyConnected();
<a name="line440"></a>};
<a name="line441"></a>
<a name="line442"></a>
<a name="line443"></a>/**
<a name="line444"></a> * Internal method called by the other page, via the NIX wrapper,
<a name="line445"></a> * to deliver a message.
<a name="line446"></a> * @param {string} serviceName The name of the service the message is to be
<a name="line447"></a> *   delivered to.
<a name="line448"></a> * @param {string} payload The message to process.
<a name="line449"></a> * @private
<a name="line450"></a> */
<a name="line451"></a>goog.net.xpc.NixTransport.prototype.handleMessage_ =
<a name="line452"></a>    function(serviceName, payload) {
<a name="line453"></a>  /** @this {goog.net.xpc.NixTransport} */
<a name="line454"></a>  var deliveryHandler = function() {
<a name="line455"></a>    this.channel_.xpcDeliver(serviceName, payload);
<a name="line456"></a>  };
<a name="line457"></a>  this.getWindow().setTimeout(goog.bind(deliveryHandler, this), 1);
<a name="line458"></a>};
<a name="line459"></a>
<a name="line460"></a>
<a name="line461"></a>/**
<a name="line462"></a> * Sends a message.
<a name="line463"></a> * @param {string} service The name of the service the message is to be
<a name="line464"></a> *   delivered to.
<a name="line465"></a> * @param {string} payload The message content.
<a name="line466"></a> * @override
<a name="line467"></a> */
<a name="line468"></a>goog.net.xpc.NixTransport.prototype.send = function(service, payload) {
<a name="line469"></a>  // Verify that the NIX channel we have is valid.
<a name="line470"></a>  if (typeof(this.nixChannel_) !== &#39;unknown&#39;) {
<a name="line471"></a>    goog.log.error(goog.net.xpc.logger, &#39;NIX channel not connected&#39;);
<a name="line472"></a>  }
<a name="line473"></a>
<a name="line474"></a>  // Send the message via the NIX wrapper object.
<a name="line475"></a>  this.nixChannel_[&#39;SendMessage&#39;](service, payload);
<a name="line476"></a>};
<a name="line477"></a>
<a name="line478"></a>
<a name="line479"></a>/** @override */
<a name="line480"></a>goog.net.xpc.NixTransport.prototype.disposeInternal = function() {
<a name="line481"></a>  goog.net.xpc.NixTransport.base(this, &#39;disposeInternal&#39;);
<a name="line482"></a>  this.nixChannel_ = null;
<a name="line483"></a>};
</pre>


</body>
</html>
